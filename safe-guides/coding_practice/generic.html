<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>泛型 - RustCodingGuidelines</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../../favicon.svg">
        
        
        <link rel="shortcut icon" href="../../favicon.png">
        
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        
        <link rel="stylesheet" href="../../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><li class="part-title">介绍</li><li class="chapter-item "><a href="../../index.html"><strong aria-hidden="true">1.</strong> Rust 编码规范介绍</a></li><li class="chapter-item "><a href="../../contribution.html"><strong aria-hidden="true">2.</strong> 贡献说明</a></li><li class="chapter-item affix "><li class="part-title">安全编码规范</li><li class="chapter-item "><a href="../../safe-guides/intro.html"><strong aria-hidden="true">3.</strong> 前言</a></li><li class="chapter-item "><a href="../../safe-guides/dev_env.html"><strong aria-hidden="true">4.</strong> 开发环境</a></li><li class="chapter-item "><a href="../../safe-guides/code_style.html"><strong aria-hidden="true">5.</strong> 代码风格</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../safe-guides/code_style/naming.html"><strong aria-hidden="true">5.1.</strong> 命名</a></li><li class="chapter-item "><a href="../../safe-guides/code_style/fmt.html"><strong aria-hidden="true">5.2.</strong> 格式</a></li><li class="chapter-item "><a href="../../safe-guides/code_style/comments.html"><strong aria-hidden="true">5.3.</strong> 注释</a></li></ol></li><li class="chapter-item expanded "><a href="../../safe-guides/coding_practice.html"><strong aria-hidden="true">6.</strong> 编程实践</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../safe-guides/coding_practice/consts.html"><strong aria-hidden="true">6.1.</strong> 常量</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/statics.html"><strong aria-hidden="true">6.2.</strong> 静态变量</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/variables.html"><strong aria-hidden="true">6.3.</strong> 本地变量</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/data-type.html"><strong aria-hidden="true">6.4.</strong> 数据类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../safe-guides/coding_practice/data-type/unit.html"><strong aria-hidden="true">6.4.1.</strong> 单元类型</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/data-type/bool.html"><strong aria-hidden="true">6.4.2.</strong> 布尔</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/data-type/char.html"><strong aria-hidden="true">6.4.3.</strong> 字符</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/data-type/int.html"><strong aria-hidden="true">6.4.4.</strong> 整数</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/data-type/float.html"><strong aria-hidden="true">6.4.5.</strong> 浮点数</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/data-type/ref.html"><strong aria-hidden="true">6.4.6.</strong> 引用</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/data-type/slice.html"><strong aria-hidden="true">6.4.7.</strong> 切片</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/data-type/tuple.html"><strong aria-hidden="true">6.4.8.</strong> 元组</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/data-type/array.html"><strong aria-hidden="true">6.4.9.</strong> 固定长度数组</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/data-type/vec.html"><strong aria-hidden="true">6.4.10.</strong> 动态数组</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/data-type/struct.html"><strong aria-hidden="true">6.4.11.</strong> 结构体</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/data-type/enum.html"><strong aria-hidden="true">6.4.12.</strong> 枚举体</a></li></ol></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/expr.html"><strong aria-hidden="true">6.5.</strong> 表达式</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/control-flow.html"><strong aria-hidden="true">6.6.</strong> 流程控制</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/strings.html"><strong aria-hidden="true">6.7.</strong> 字符串</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/collections.html"><strong aria-hidden="true">6.8.</strong> 集合容器</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/fn-and-closure.html"><strong aria-hidden="true">6.9.</strong> 函数与闭包</a></li><li class="chapter-item expanded "><a href="../../safe-guides/coding_practice/generic.html" class="active"><strong aria-hidden="true">6.10.</strong> 泛型</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/traits.html"><strong aria-hidden="true">6.11.</strong> 特质</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../safe-guides/coding_practice/traits/std-buildin.html"><strong aria-hidden="true">6.11.1.</strong> 标准库内置 trait</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/traits/trait-object.html"><strong aria-hidden="true">6.11.2.</strong> trait 对象</a></li></ol></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/error-handle.html"><strong aria-hidden="true">6.12.</strong> 错误处理</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/memory.html"><strong aria-hidden="true">6.13.</strong> 内存管理</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../safe-guides/coding_practice/memory/lifetime.html"><strong aria-hidden="true">6.13.1.</strong> 生存期</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/memory/box.html"><strong aria-hidden="true">6.13.2.</strong> Box&lt;T&gt;</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/memory/drop.html"><strong aria-hidden="true">6.13.3.</strong> Drop 析构</a></li></ol></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/module.html"><strong aria-hidden="true">6.14.</strong> 模块</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/cargo.html"><strong aria-hidden="true">6.15.</strong> 包管理</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/macros.html"><strong aria-hidden="true">6.16.</strong> 宏</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../safe-guides/coding_practice/macros/decl.html"><strong aria-hidden="true">6.16.1.</strong> 声明宏</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/macros/proc.html"><strong aria-hidden="true">6.16.2.</strong> 过程宏</a></li></ol></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/threads.html"><strong aria-hidden="true">6.17.</strong> 多线程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../safe-guides/coding_practice/threads/lock.html"><strong aria-hidden="true">6.17.1.</strong> 锁同步</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/threads/lock-free.html"><strong aria-hidden="true">6.17.2.</strong> 无锁</a></li></ol></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/async-await.html"><strong aria-hidden="true">6.18.</strong> 异步编程</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/unsafe_rust.html"><strong aria-hidden="true">6.19.</strong> Unsafe Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../safe-guides/coding_practice/unsafe_rust/safe_abstract.html"><strong aria-hidden="true">6.19.1.</strong> 安全抽象</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/unsafe_rust/raw_ptr.html"><strong aria-hidden="true">6.19.2.</strong> 裸指针操作</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/unsafe_rust/union.html"><strong aria-hidden="true">6.19.3.</strong> 联合体</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/unsafe_rust/mem.html"><strong aria-hidden="true">6.19.4.</strong> 内存</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/unsafe_rust/ffi.html"><strong aria-hidden="true">6.19.5.</strong> FFi 规范</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/unsafe_rust/io.html"><strong aria-hidden="true">6.19.6.</strong> I/O</a></li></ol></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/no-std.html"><strong aria-hidden="true">6.20.</strong> no-std</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/io.html"><strong aria-hidden="true">6.21.</strong> I/O</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/security.html"><strong aria-hidden="true">6.22.</strong> 信息安全</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/others.html"><strong aria-hidden="true">6.23.</strong> 其他</a></li></ol></li><li class="chapter-item "><a href="../../safe-guides/Appendix/toc.html"><strong aria-hidden="true">7.</strong> 附录</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../safe-guides/Appendix/test.html"><strong aria-hidden="true">7.1.</strong> 测试</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../safe-guides/Appendix/test/unit_test.html"><strong aria-hidden="true">7.1.1.</strong> 单元测试</a></li><li class="chapter-item "><a href="../../safe-guides/Appendix/test/benchmark.html"><strong aria-hidden="true">7.1.2.</strong> 基准测试</a></li><li class="chapter-item "><a href="../../safe-guides/Appendix/test/fuzz.html"><strong aria-hidden="true">7.1.3.</strong> 模糊测试</a></li></ol></li><li class="chapter-item "><a href="../../safe-guides/Appendix/terms.html"><strong aria-hidden="true">7.2.</strong> 术语解释</a></li><li class="chapter-item "><a href="../../safe-guides/Appendix/templates/intro.html"><strong aria-hidden="true">7.3.</strong> 模板</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../safe-guides/Appendix/templates/rustfmt.toml.html"><strong aria-hidden="true">7.3.1.</strong> rustfmt 模板</a></li><li class="chapter-item "><a href="../../safe-guides/Appendix/templates/clippy.toml.html"><strong aria-hidden="true">7.3.2.</strong> clippy 模板</a></li><li class="chapter-item "><a href="../../safe-guides/Appendix/templates/deny.toml.html"><strong aria-hidden="true">7.3.3.</strong> deny 模板</a></li></ol></li><li class="chapter-item "><a href="../../safe-guides/Appendix/tools/intro.html"><strong aria-hidden="true">7.4.</strong> 工具链</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../safe-guides/Appendix/tools/rustfmt.html"><strong aria-hidden="true">7.4.1.</strong> rustfmt</a></li><li class="chapter-item "><a href="../../safe-guides/Appendix/tools/noisy-clippy.html"><strong aria-hidden="true">7.4.2.</strong> noisy-clippy</a></li><li class="chapter-item "><a href="../../safe-guides/Appendix/tools/cargo-udeps.html"><strong aria-hidden="true">7.4.3.</strong> cargo-udeps</a></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">领域最佳实践</li><li class="chapter-item "><a href="../../best-practices/intro.html"><strong aria-hidden="true">8.</strong> 介绍</a></li><li class="chapter-item "><a href="../../best-practices/hpc.html"><strong aria-hidden="true">9.</strong> 高性能计算</a></li><li class="chapter-item "><a href="../../best-practices/embedded.html"><strong aria-hidden="true">10.</strong> 嵌入式 Rust</a></li><li class="chapter-item "><a href="../../best-practices/databases.html"><strong aria-hidden="true">11.</strong> 数据库</a></li><li class="chapter-item "><a href="../../best-practices/games.html"><strong aria-hidden="true">12.</strong> 游戏</a></li><li class="chapter-item "><a href="../../best-practices/cli_app.html"><strong aria-hidden="true">13.</strong> Cli App</a></li><li class="chapter-item "><a href="../../best-practices/gui.html"><strong aria-hidden="true">14.</strong> GUI</a></li><li class="chapter-item "><a href="../../best-practices/web.html"><strong aria-hidden="true">15.</strong> Web 开发</a></li><li class="chapter-item "><a href="../../best-practices/networks.html"><strong aria-hidden="true">16.</strong> 网络服务</a></li><li class="chapter-item "><a href="../../best-practices/webassembly.html"><strong aria-hidden="true">17.</strong> WebAssembly</a></li><li class="chapter-item affix "><li class="part-title">Cheat Sheet</li><li class="chapter-item "><a href="../../cheat-sheet/index.html"><strong aria-hidden="true">18.</strong> 介绍</a></li><li class="chapter-item affix "><li class="part-title">Rust 优化指南</li><li class="chapter-item "><a href="../../optimizing/intro.html"><strong aria-hidden="true">19.</strong> 介绍</a></li><li class="chapter-item affix "><li class="part-title">Rust Cookbook</li><li class="chapter-item "><a href="../../cookbook/intro.html"><strong aria-hidden="true">20.</strong> 介绍</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">RustCodingGuidelines</h1>

                    <div class="right-buttons">
                        
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/Rust-Coding-Guidelines/rust-coding-guidelines-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#泛型" id="泛型">泛型</a></h1>
<p>Rust 中的泛型允许开发人员编写更加简洁、更少重复的代码。但泛型可能会引起编译文件大小膨胀，酌情使用。</p>
<hr />
<h2><a class="header" href="#pgen01----用泛型来抽象公共语义" id="pgen01----用泛型来抽象公共语义">P.GEN.01    用泛型来抽象公共语义</a></h2>
<p><strong>【描述】</strong></p>
<p>应该巧用泛型来抽象公共语义，消除重复代码。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Add;
use std::marker::PhantomData;

#[derive(Debug, Clone, Copy)]
struct Unit&lt;T&gt; {
    value: f64,
    unit_type: PhantomData&lt;T&gt;,
}

impl&lt;T&gt; Unit&lt;T&gt; {
    fn new(value: f64) -&gt; Self {
        Self {
            value,
            unit_type: PhantomData,
        }
    }
}

impl&lt;T&gt; Add for Unit&lt;T&gt; {
    type Output = Unit&lt;T&gt;;

    fn add(self, another: Unit&lt;T&gt;) -&gt; Self::Output {
        let new_value = self.value + another.value;
        Unit::new(new_value)
    }
}

#[derive(Debug, Clone, Copy)]
struct MeterType;

#[derive(Debug, Clone, Copy)]
struct KilogramType;

type Meter = Unit&lt;MeterType&gt;;
type Kilogram = Unit&lt;KilogramType&gt;;
fn main() {
    let one_meter = Meter::new(1.0);
    let two_kilograms = Kilogram::new(2.0);
    
    let two_meters = one_meter + one_meter;
}
</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Add;

#[derive(Debug, Clone, Copy)]
struct Meter {
    value: f64
}

impl Meter {
    fn new(value: f64) -&gt; Self {
        Self { value }
    }
}

impl Add for Meter {
    type Output = Meter;

    fn add(self, another: Meter) -&gt; Self::Output {
        let value = self.value + another.value;
        Meter { value }
    }
}

#[derive(Debug, Clone, Copy)]
struct Kilogram {
    value: f64
}

impl Kilogram {
    fn new(value: f64) -&gt; Self {
        Self { value }
    }
}

impl Add for Kilogram {
    type Output = Kilogram;

    fn add(self, another: Kilogram) -&gt; Self::Output {
        let value = self.value + another.value;
        Kilogram { value }
    }
}
fn main() {
    let one_meter = Meter::new(1.0);
    let two_kilograms = Kilogram::new(2.0);
    
    let two_meters = one_meter + one_meter;
}

</code></pre></pre>
<h2><a class="header" href="#pgen02--不要随便使用-impl-trait-语法替代泛型限定" id="pgen02--不要随便使用-impl-trait-语法替代泛型限定">P.GEN.02  不要随便使用 <code>impl Trait</code> 语法替代泛型限定</a></h2>
<p><strong>【描述】</strong></p>
<p><code>impl Trait</code> 语法 和 泛型限定，虽然都是静态分发，且效果类似，但是它们的语义是不同的。</p>
<p><strong>在类型系统层面上的语义：</strong></p>
<ol>
<li><code>impl Trait</code> 是 存在量化类型。意指，存在某一个被限定的类型。</li>
<li>泛型限定 是 通用量化类型。意指，所有被限定的类型。</li>
</ol>
<p>要根据它们的语义来选择不同的写法。</p>
<p>另外，<code>impl Trait</code> 可以用在函数参数位置和返回值位置，但是不同位置意义不同。</p>
<p><strong>函数参数位置</strong></p>
<p>等价于 泛型参数。</p>
<p>但要注意：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f(b1: impl Bar, b2: impl Bar) -&gt; usize
<span class="boring">}
</span></code></pre></pre>
<p>等价于：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;B1: Bar, B2: Bar&gt;(b1: B1, b2: B2) -&gt; usize
<span class="boring">}
</span></code></pre></pre>
<p>而不是</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;B: Bar&gt;(b1: B, b2: B) -&gt; usize
<span class="boring">}
</span></code></pre></pre>
<p>证明示例：</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

// 函数参数可以传入 整数，但是函数返回值是 String
fn func(arg: impl Display) -&gt; impl Display {
    format!(&quot;Hay! I am not the same as \&quot;{}\&quot;&quot;, arg)
}

// 很明显不等价于下面这类
// fn somefunc2&lt;T: Display&gt;(arg: T) -&gt; T {
//     // 需要指定同一个类型 T 的行为
// }

fn main(){
    let a  = 42;
    let a = func(42);
}
</code></pre></pre>
<p><strong>函数返回值</strong></p>
<p>在返回值位置上，如果是泛型参数，则是由调用者来选择具体类型，比如 <code>parse::&lt;i32&gt;(&quot;32&quot;)</code> ； 如果是 <code>impl Trait</code>，则是由被调用者来决定具体类型，但只能有一种类型。</p>
<p>在返回值位置上的 <code>impl Trait</code> 会根据函数体的返回值自动推断实现了哪些  auto trait。这意味着你不必在 <code>impl Trait</code> 后面再 加 <code>Sync + Send </code> 这种auto trait。</p>
<p>注意下面代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Error： 这里只允许有同一种具体类型，Foo 和 Baz 都实现了 Bar 也是错的。
fn f(a: bool) -&gt; impl Bar {
    if a {
        Foo { ... }
    } else {
        Baz { ... }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#pgen03---不要使用太多泛型参数和-trait-限定否则会增长编译时间" id="pgen03---不要使用太多泛型参数和-trait-限定否则会增长编译时间">P.GEN.03   不要使用太多泛型参数和 trait 限定，否则会增长编译时间</a></h2>
<p><strong>【描述】</strong></p>
<p>为泛型函数添加详细的trait 限定，可以在一定程度上增强用户使用体验，但使用过多的泛型参数和 trait 限定会显著地增长编译时间。</p>
<p>【正例】</p>
<p>来自于 Web 框架 Axum 的代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // From: https://github.com/tokio-rs/axum/pull/198
    fn handle_error&lt;ReqBody, F&gt;(
        self,
        f: F,
    ) -&gt; HandleError&lt;Self, F, ReqBody, HandleErrorFromRouter&gt; {
        HandleError::new(self, f)
    }   
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<p>以下写法比上面的写法编译时间要多十倍。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // From: https://github.com/tokio-rs/axum/pull/198
    fn handle_error&lt;ReqBody, ResBody, F, Res, E&gt;(
        self,
        f: F,
    ) -&gt; HandleError&lt;Self, F, ReqBody, HandleErrorFromRouter&gt;
    where
        Self: Service&lt;Request&lt;ReqBody&gt;, Response = Response&lt;ResBody&gt;&gt;,
        F: FnOnce(Self::Error) -&gt; Result&lt;Res, E&gt;,
        Res: IntoResponse,
        ResBody: http_body::Body&lt;Data = Bytes&gt; + Send + Sync + 'static,
        ResBody::Error: Into&lt;BoxError&gt; + Send + Sync + 'static,
    {
        HandleError::new(self, f)
    }
<span class="boring">}
</span></code></pre></pre>
<hr />
<h2><a class="header" href="#ggen01-----泛型参数必须先声明再使用" id="ggen01-----泛型参数必须先声明再使用">G.GEN.01     泛型参数必须先声明再使用</a></h2>
<h3><a class="header" href="#级别规则" id="级别规则">【级别：规则】</a></h3>
<p>按此规范执行。</p>
<h3><a class="header" href="#lint-检测" id="lint-检测">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>yes</td><td>_</td><td>_</td></tr>
</tbody></table>
<h3><a class="header" href="#描述" id="描述"><strong>【描述】</strong></a></h3>
<p>泛型参数必须先被声明，才能被使用。如果一个类型中包含泛型类型，也必须为其声明泛型参数。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;T&gt; { x: T }

struct Bar&lt;T&gt; { x: Foo&lt;T&gt; }
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;T&gt; { x: T }

struct Bar { x: Foo } // error[E0107]: missing generics for struct `Foo`
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#ggen02---不要在泛型位置上使用内建类型" id="ggen02---不要在泛型位置上使用内建类型">G.GEN.02   不要在泛型位置上使用内建类型</a></h2>
<h3><a class="header" href="#级别建议" id="级别建议">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-1" id="lint-检测-1">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#builtin_type_shadow">builtin_type_shadow</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-1" id="描述-1">【描述】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Foo&lt;T&gt; {
    fn impl_func(&amp;self) -&gt; T {
        42
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<p>这里 <code>u32</code> 会被认为是一个类型参数。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;u32&gt; Foo&lt;u32&gt; {
    fn impl_func(&amp;self) -&gt; u32 {
        42
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#ggen03---使用-rust-标准库中某些方法要注意避免使用其泛型默认实现而应该使用具体类型的实现" id="ggen03---使用-rust-标准库中某些方法要注意避免使用其泛型默认实现而应该使用具体类型的实现">G.GEN.03   使用 Rust 标准库中某些方法，要注意避免使用其泛型默认实现，而应该使用具体类型的实现</a></h2>
<h3><a class="header" href="#级别建议-1" id="级别建议-1">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-2" id="lint-检测-2">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#inefficient_to_string">inefficient_to_string</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-2" id="描述-2">【描述】</a></h3>
<p>Rust 标准库内部某些类型使用了 泛型特化（未稳定特性），比如 <code>ToString</code> trait。</p>
<p>该 trait 有一个<a href="https://doc.rust-lang.org/stable/src/alloc/string.rs.html#2369">泛型默认实现</a>， 并且一些具体类型也实现了它，比如 <code>char</code>/ <code>str</code> /  <code>u8</code>/ <code>i8</code> 等。</p>
<p>在实际代码中，应该选择去调用具体类型实现的 <code>to_string()</code> 方法，而非调用泛型的默认实现。 </p>
<p><strong>这一规则要求开发者对 Rust 标准库的一些方法实现有一定了解。</strong> </p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 闭包参数中， s 为 `&amp;&amp;str` 类型，使用 `|&amp;s|` 对参数模式匹配后，闭包体内 `s` 就变成了 `&amp;str` 类型
// 经过这样的转换，直接调用 `&amp;str`的 `to_string()` 方法，而如果是 `&amp;&amp;str` 就会去调用泛型的默认实现。 
[&quot;foo&quot;, &quot;bar&quot;].iter().map(|&amp;s| s.to_string() );
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 闭包参数中， s 为 `&amp;&amp;str` 类型
//  `&amp;&amp;str` 就会去调用泛型的默认实现
[&quot;foo&quot;, &quot;bar&quot;].iter().map(|&amp;s| s.to_string() );
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#ggen04--为泛型类型实现方法时impl-中声明的泛型类型参数一定要被用到" id="ggen04--为泛型类型实现方法时impl-中声明的泛型类型参数一定要被用到">G.GEN.04  为泛型类型实现方法时，<code>impl</code> 中声明的泛型类型参数一定要被用到</a></h2>
<h3><a class="header" href="#级别规则-1" id="级别规则-1">【级别：规则】</a></h3>
<p>按此规范执行。</p>
<h3><a class="header" href="#lint-检测-3" id="lint-检测-3">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>yes</td><td>_</td><td>_</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-3" id="描述-3"><strong>【描述】</strong></a></h3>
<p>在 <code>impl</code> 中被声明的类型参数，至少要满足下面三种形式：</p>
<ol>
<li><code>impl&lt;T&gt; Foo&lt;T&gt;</code>，  <code>T</code>  出现在实现的<code>Self</code> 类型<code>Foo&lt;T&gt;</code> 中 。</li>
<li><code>impl&lt;T&gt; SomeTrait&lt;T&gt; for Foo</code> ， <code>T</code>出现在要实现的 trait 中 。</li>
<li><code>impl&lt;T, U&gt; SomeTrait for T where T: AnotherTrait&lt;AssocType=U&gt;</code> ， 出现在 <code>T</code> 的 trait 限定的关联类型中。</li>
</ol>
<p>除此之外，都不算 <code>T</code> 被用到（出现在 Self 类型中）。</p>
<p>有这种限制，主要有两个原因：</p>
<ol>
<li>方便 Rust 类型推断。有这些限制才能明确能推断这些泛型参数的行为，避免产生错误。参考 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0447-no-unused-impl-parameters.md">RFC 0447 </a> 。</li>
<li>避免语义定义不明确的情况。如果 <code>impl</code> 上存在自由的 泛型参数，则无法保证这一点。</li>
</ol>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// case 1
struct Foo;

// Move the type parameter from the impl to the method
impl Foo {
    fn get&lt;T: Default&gt;(&amp;self) -&gt; T {
        &lt;T as Default&gt;::default()
    }
}

// case 2
use std::marker::PhantomData;

trait Maker {
    type Item;
    fn make(&amp;mut self) -&gt; Self::Item;
}

struct Foo&lt;T&gt; {
    foo: T
}

// Add a type parameter to `FooMaker`
struct FooMaker&lt;T&gt; {
    phantom: PhantomData&lt;T&gt;,
}

impl&lt;T: Default&gt; Maker for FooMaker&lt;T&gt; {
    type Item = Foo&lt;T&gt;;

    fn make(&amp;mut self) -&gt; Foo&lt;T&gt; {
        Foo {
            foo: &lt;T as Default&gt;::default(),
        }
    }
}

// closue : 相关 issue:  https://github.com/rust-lang/rust/issues/25041 
trait Foo {}
impl&lt;F, A&gt; Foo for F where F: Fn() -&gt; A {} // 此处 A 是 闭包trait内的一个关联类型
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// case 1

struct Foo;

impl&lt;T: Default&gt; Foo {
    // error: the type parameter `T` is not constrained by the impl trait, self
    // type, or predicates [E0207]
    fn get(&amp;self) -&gt; T {
        &lt;T as Default&gt;::default()
    }
}

// case 2
trait Maker {
    type Item;
    fn make(&amp;mut self) -&gt; Self::Item;
}
struct Foo&lt;T&gt; {
    foo: T
}
struct FooMaker;
impl&lt;T: Default&gt; Maker for FooMaker {
// error: the type parameter `T` is not constrained by the impl trait, self
// type, or predicates [E0207]
    type Item = Foo&lt;T&gt;;

    fn make(&amp;mut self) -&gt; Foo&lt;T&gt; {
        Foo { foo: &lt;T as Default&gt;::default() }
    }
}

// error: the type parameter `A` is not constrained by the impl trait, self type, or predicates
trait Foo {}
impl&lt;F, A&gt; Foo for F where F: Fn(A) {} // error
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#ggen05---定义泛型函数时如果该函数实现用到来自-trait-定义的相关行为需要为泛型指定相关-trait-的限定" id="ggen05---定义泛型函数时如果该函数实现用到来自-trait-定义的相关行为需要为泛型指定相关-trait-的限定">G.GEN.05   定义泛型函数时，如果该函数实现用到来自 trait 定义的相关行为，需要为泛型指定相关 trait 的限定</a></h2>
<h3><a class="header" href="#级别规则-2" id="级别规则-2">【级别：规则】</a></h3>
<p>按此规范执行。</p>
<h3><a class="header" href="#lint-检测-4" id="lint-检测-4">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>yes</td><td>_</td><td>_</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-4" id="描述-4"><strong>【描述】</strong></a></h3>
<p>泛型，在 Rust 类型系统中的语义是一种 通用量化l类型（Universally-quantified type），即，泛型类型<code> T</code> 的所有可能 的单态类型。</p>
<p>在泛型函数内部，如果使用了来自某个 trait 定义的行为，则需要为泛型指定相关的 trait 限定，来排除其他没有实现该trait 的类型。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

// 为泛型类型 T 指派 Debug triat 限定
fn some_func&lt;T: fmt::Debug&gt;(foo: T) {
    println!(&quot;{:?}&quot;, foo); 
}

struct A;

fn main() {
   some_func(5i32);
   
   // A 没有实现 Debug trait，会被排除掉
   some_func(A); // error[E0277]: `A` doesn't implement `Debug`
}
</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

// println! 中 `{:?}` 为 Debug triat 定义行为
fn some_func&lt;T&gt;(foo: T) {
    println!(&quot;{:?}&quot;, foo); // error[E0277]: `T` doesn't implement `Debug`
}
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../../safe-guides/coding_practice/fn-and-closure.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../../safe-guides/coding_practice/traits.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../../safe-guides/coding_practice/fn-and-closure.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../../safe-guides/coding_practice/traits.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../../mermaid.min.js"></script>
        
        <script type="text/javascript" src="../../mermaid-init.js"></script>
        

        

    </body>
</html>

<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RustCodingGuidelines</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><li class="part-title">介绍</li><li class="chapter-item "><a href="index.html"><strong aria-hidden="true">1.</strong> Rust 编码规范介绍</a></li><li class="chapter-item "><a href="contribution.html"><strong aria-hidden="true">2.</strong> 贡献说明</a></li><li class="chapter-item affix "><li class="part-title">安全编码规范</li><li class="chapter-item "><a href="safe-guides/intro.html"><strong aria-hidden="true">3.</strong> 前言</a></li><li class="chapter-item "><a href="safe-guides/dev_env.html"><strong aria-hidden="true">4.</strong> 开发环境</a></li><li class="chapter-item "><a href="safe-guides/code_style.html"><strong aria-hidden="true">5.</strong> 代码风格</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/code_style/naming.html"><strong aria-hidden="true">5.1.</strong> 命名</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt.html"><strong aria-hidden="true">5.2.</strong> 格式</a></li><li class="chapter-item "><a href="safe-guides/code_style/comments.html"><strong aria-hidden="true">5.3.</strong> 注释</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice.html"><strong aria-hidden="true">6.</strong> 编程实践</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/consts.html"><strong aria-hidden="true">6.1.</strong> 常量</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/statics.html"><strong aria-hidden="true">6.2.</strong> 静态变量</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/variables.html"><strong aria-hidden="true">6.3.</strong> 本地变量</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type.html"><strong aria-hidden="true">6.4.</strong> 数据类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/unit.html"><strong aria-hidden="true">6.4.1.</strong> 单元类型</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/bool.html"><strong aria-hidden="true">6.4.2.</strong> 布尔</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/char.html"><strong aria-hidden="true">6.4.3.</strong> 字符</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/int.html"><strong aria-hidden="true">6.4.4.</strong> 整数</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/float.html"><strong aria-hidden="true">6.4.5.</strong> 浮点数</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/ref.html"><strong aria-hidden="true">6.4.6.</strong> 引用</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/slice.html"><strong aria-hidden="true">6.4.7.</strong> 切片</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/tuple.html"><strong aria-hidden="true">6.4.8.</strong> 元组</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/array.html"><strong aria-hidden="true">6.4.9.</strong> 固定长度数组</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/vec.html"><strong aria-hidden="true">6.4.10.</strong> 动态数组</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/struct.html"><strong aria-hidden="true">6.4.11.</strong> 结构体</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/enum.html"><strong aria-hidden="true">6.4.12.</strong> 枚举体</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/expr.html"><strong aria-hidden="true">6.5.</strong> 表达式</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/control-flow.html"><strong aria-hidden="true">6.6.</strong> 流程控制</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/strings.html"><strong aria-hidden="true">6.7.</strong> 字符串</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/collections.html"><strong aria-hidden="true">6.8.</strong> 集合容器</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/fn-and-closure.html"><strong aria-hidden="true">6.9.</strong> 函数与闭包</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/generic.html"><strong aria-hidden="true">6.10.</strong> 泛型</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits.html"><strong aria-hidden="true">6.11.</strong> 特质</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-buildin.html"><strong aria-hidden="true">6.11.1.</strong> 标准库内置 trait</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/trait-object.html"><strong aria-hidden="true">6.11.2.</strong> trait 对象</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/error-handle.html"><strong aria-hidden="true">6.12.</strong> 错误处理</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/memory.html"><strong aria-hidden="true">6.13.</strong> 内存管理</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/memory/lifetime.html"><strong aria-hidden="true">6.13.1.</strong> 生存期</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/memory/box.html"><strong aria-hidden="true">6.13.2.</strong> Box&lt;T&gt;</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/memory/drop.html"><strong aria-hidden="true">6.13.3.</strong> Drop 析构</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/module.html"><strong aria-hidden="true">6.14.</strong> 模块</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/cargo.html"><strong aria-hidden="true">6.15.</strong> 包管理</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros.html"><strong aria-hidden="true">6.16.</strong> 宏</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/macros/decl.html"><strong aria-hidden="true">6.16.1.</strong> 声明宏</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/proc.html"><strong aria-hidden="true">6.16.2.</strong> 过程宏</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/threads.html"><strong aria-hidden="true">6.17.</strong> 多线程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/threads/lock.html"><strong aria-hidden="true">6.17.1.</strong> 锁同步</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/threads/lock-free.html"><strong aria-hidden="true">6.17.2.</strong> 无锁</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/async-await.html"><strong aria-hidden="true">6.18.</strong> 异步编程</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust.html"><strong aria-hidden="true">6.19.</strong> Unsafe Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract.html"><strong aria-hidden="true">6.19.1.</strong> 安全抽象</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/raw_ptr.html"><strong aria-hidden="true">6.19.2.</strong> 裸指针操作</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/union.html"><strong aria-hidden="true">6.19.3.</strong> 联合体</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/mem.html"><strong aria-hidden="true">6.19.4.</strong> 内存</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi.html"><strong aria-hidden="true">6.19.5.</strong> FFi 规范</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/io.html"><strong aria-hidden="true">6.19.6.</strong> I/O</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/no-std.html"><strong aria-hidden="true">6.20.</strong> no-std</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/io.html"><strong aria-hidden="true">6.21.</strong> I/O</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/security.html"><strong aria-hidden="true">6.22.</strong> 信息安全</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/others.html"><strong aria-hidden="true">6.23.</strong> 其他</a></li></ol></li><li class="chapter-item "><a href="safe-guides/Appendix/toc.html"><strong aria-hidden="true">7.</strong> 附录</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/Appendix/test.html"><strong aria-hidden="true">7.1.</strong> 测试</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/Appendix/test/unit_test.html"><strong aria-hidden="true">7.1.1.</strong> 单元测试</a></li><li class="chapter-item "><a href="safe-guides/Appendix/test/benchmark.html"><strong aria-hidden="true">7.1.2.</strong> 基准测试</a></li><li class="chapter-item "><a href="safe-guides/Appendix/test/fuzz.html"><strong aria-hidden="true">7.1.3.</strong> 模糊测试</a></li></ol></li><li class="chapter-item "><a href="safe-guides/Appendix/terms.html"><strong aria-hidden="true">7.2.</strong> 术语解释</a></li><li class="chapter-item "><a href="safe-guides/Appendix/templates/intro.html"><strong aria-hidden="true">7.3.</strong> 模板</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/Appendix/templates/rustfmt.toml.html"><strong aria-hidden="true">7.3.1.</strong> rustfmt 模板</a></li><li class="chapter-item "><a href="safe-guides/Appendix/templates/clippy.toml.html"><strong aria-hidden="true">7.3.2.</strong> clippy 模板</a></li><li class="chapter-item "><a href="safe-guides/Appendix/templates/deny.toml.html"><strong aria-hidden="true">7.3.3.</strong> deny 模板</a></li></ol></li><li class="chapter-item "><a href="safe-guides/Appendix/tools/intro.html"><strong aria-hidden="true">7.4.</strong> 工具链</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/Appendix/tools/rustfmt.html"><strong aria-hidden="true">7.4.1.</strong> rustfmt</a></li><li class="chapter-item "><a href="safe-guides/Appendix/tools/noisy-clippy.html"><strong aria-hidden="true">7.4.2.</strong> noisy-clippy</a></li><li class="chapter-item "><a href="safe-guides/Appendix/tools/cargo-udeps.html"><strong aria-hidden="true">7.4.3.</strong> cargo-udeps</a></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">领域最佳实践</li><li class="chapter-item "><a href="best-practices/intro.html"><strong aria-hidden="true">8.</strong> 介绍</a></li><li class="chapter-item "><a href="best-practices/hpc.html"><strong aria-hidden="true">9.</strong> 高性能计算</a></li><li class="chapter-item "><a href="best-practices/embedded.html"><strong aria-hidden="true">10.</strong> 嵌入式 Rust</a></li><li class="chapter-item "><a href="best-practices/databases.html"><strong aria-hidden="true">11.</strong> 数据库</a></li><li class="chapter-item "><a href="best-practices/games.html"><strong aria-hidden="true">12.</strong> 游戏</a></li><li class="chapter-item "><a href="best-practices/cli_app.html"><strong aria-hidden="true">13.</strong> Cli App</a></li><li class="chapter-item "><a href="best-practices/gui.html"><strong aria-hidden="true">14.</strong> GUI</a></li><li class="chapter-item "><a href="best-practices/web.html"><strong aria-hidden="true">15.</strong> Web 开发</a></li><li class="chapter-item "><a href="best-practices/networks.html"><strong aria-hidden="true">16.</strong> 网络服务</a></li><li class="chapter-item "><a href="best-practices/webassembly.html"><strong aria-hidden="true">17.</strong> WebAssembly</a></li><li class="chapter-item affix "><li class="part-title">Cheat Sheet</li><li class="chapter-item "><a href="cheat-sheet/index.html"><strong aria-hidden="true">18.</strong> 介绍</a></li><li class="chapter-item affix "><li class="part-title">Rust 优化指南</li><li class="chapter-item "><a href="optimizing/intro.html"><strong aria-hidden="true">19.</strong> 介绍</a></li><li class="chapter-item affix "><li class="part-title">Rust Cookbook</li><li class="chapter-item "><a href="cookbook/intro.html"><strong aria-hidden="true">20.</strong> 介绍</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">RustCodingGuidelines</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/Rust-Coding-Guidelines/rust-coding-guidelines-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#rust-编码规范介绍" id="rust-编码规范介绍">Rust 编码规范介绍</a></h1>
<h2><a class="header" href="#状态" id="状态">状态</a></h2>
<ul>
<li><a href="./safe-guides/intro.html">《Rust 安全编码规范》</a> 初稿发布 2021-10-31 (V 0.1)</li>
</ul>
<h2><a class="header" href="#介绍" id="介绍">介绍</a></h2>
<p>据了解，Rust 社区内有些公司和组织都各自维护着自己的编码规范。下面罗列了一些已经公开的：</p>
<ul>
<li><a href="https://rust-lang.github.io/api-guidelines/about.html">官方｜Rust API 编写指南</a></li>
<li><a href="https://github.com/rust-dev-tools/fmt-rfcs/blob/master/guide/guide.md">官方 | Rust Style Guide</a></li>
<li><a href="https://rust-lang.github.io/unsafe-code-guidelines/">Rust's Unsafe Code Guidelines Reference</a></li>
<li><a href="https://anssi-fr.github.io/rust-guide">法国国家信息安全局 | Rust 安全（Security）规范</a></li>
<li><a href="https://developers.diem.com/docs/core/coding-guidelines/">Facebook Diem 项目 Rust 编码规范</a></li>
<li><a href="https://teaclave.apache.org/docs/rust-guildeline/">Apache Teaclave 安全计算平台 | Rust 开发规范</a></li>
<li><a href="https://github.com/pingcap/style-guide">PingCAP | 编码风格指南（包括 Rust 和 Go 等）</a></li>
<li><a href="https://fuchsia.dev/fuchsia-src/development/languages/rust">Google Fuchsia 操作系统 Rust 开发指南</a></li>
<li><a href="https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/dev/style.md">RustAnalyzer 编码风格指南</a></li>
<li><a href="https://deterministic.space/elegant-apis-in-rust.html">使用 Rust 设计优雅的 API</a></li>
<li><a href="https://michael-f-bryan.github.io/rust-ffi-guide/">Rust FFI 指南</a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html">大约 478 条 Clippy lint</a></li>
<li><a href="https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html">lints in the rustc book </a></li>
<li><a href="https://github.com/dtolnay/noisy-clippy">Dtolnay 对 crates.io 中 clippy lint 应用统计</a></li>
</ul>
<p>以上公开的编码规范，除官方Rust API 编写指南和法国国家信息安全局是通用目的公布之外，其他编码规范主要是为了开源项目自身统一贡献者编码风格而制作。</p>
<p>随着 Rust 的普及，各大公司应用 Rust 的需求增多，为了方便 Rust 在公司落地，需要一个统一的、通用的、可通过 Clippy 等工具辅助检查的编码规范。</p>
<p>本规范参考但不限于以上公开规范。本规范并非 Rust 教程，但也可以作为学习参考。</p>
<h2><a class="header" href="#编码规范分类" id="编码规范分类">编码规范分类</a></h2>
<ol>
<li>安全编码规范。</li>
<li>领域最佳实践。</li>
<li>工具链使用指南。</li>
<li>Rust优化指南。</li>
<li>常用基础库指南。</li>
</ol>
<h2><a class="header" href="#贡献形式" id="贡献形式">贡献形式</a></h2>
<pre class="mermaid">graph TD
    A{Rust 编码规范}
    A --&gt;|公司A| B[云计算]
    A --&gt;|公司C| C[嵌入式]
    A --&gt;|公司B| D[网络]
    A --&gt;|公司D| E[跨平台组件]
    A --&gt;|公司E| F[WebAssembly]
</pre>
<p>本规范致力于成为统一的 Rust 编码规范，并联合国内外公司共同维护。</p>
<p>公司可以依赖本规范，结合自己的业务领域和团队习惯，形成自己的编码规范，并可以在日常实践中反哺本规范，让本规范更加完善。</p>
<p>个人开发者也可以参与贡献！</p>
<p>如何参与贡献？</p>
<p>请阅读 <a href="./contribution.html">贡献说明</a> 。</p>
<h1><a class="header" href="#贡献者指南" id="贡献者指南">贡献者指南</a></h1>
<p>目前项目处于初期，先以 issues 提建议为主，暂不支持 Pull Request。</p>
<p>等项目整体结构确定以后，再开始接受 Pull Request。</p>
<h3><a class="header" href="#贡献名单" id="贡献名单">贡献名单</a></h3>
<h1><a class="header" href="#rust-安全编码规范" id="rust-安全编码规范">Rust 安全编码规范</a></h1>
<p>Rust 语言虽然以类型安全、内存安全、线程安全和高性能等特性著称，但对于开发者而言，还是需要遵循一定的编码规范，更有助于写出地道安全的 Rust 代码。</p>
<p>虽然 Rust 也提供了 Clippy 这样的静态检查工具来帮助开发者识别代码中的坏味道，但是 Clippy 内部为什么要遵循这些规则，以及它们的分类等，对于大部分开发者还是不太透明。这方面也需要一个文档来进行梳理。</p>
<p>另外，Clippy 也有其局限性：无法检测代码中的语义。 语义在 Rust 里对于写出好代码来说，也是比较重要的参考因素。有时候 clippy 的建议反而会产生负面效果。</p>
<p>所以，为了更好地在公司内落地 Rust， 追求更好的代码质量，制定安全编码规范是必须的。</p>
<blockquote>
<p>注意：本规范并不是 Rust 教程。</p>
</blockquote>
<p><strong>本规范的指导原则：</strong></p>
<p>编码规范 和 Clippy 的关系是相辅相成的。</p>
<p>本规范要做的，就是根据 Clippy 里的lint ，结合社区生态中的一些实践，提炼出一些规则，进一步从语义角度思考这些 lint 的实用性，明确它们的使用边界，帮助开发者在编写代码和使用 Clippy 等工具检查的时候，可以更加有理有据地做出选择。</p>
<p><strong>本规范的目标如下：</strong></p>
<ol>
<li>提高 Unsafe Rust 代码编写的安全性。</li>
<li>提高 代码的健壮性。</li>
<li>提高 代码的可读性、可维护性和可移植性。</li>
<li>编程规范条款力争系统化、易应用、易检查。</li>
</ol>
<p>规范条款分为原则和规则两个类别，</p>
<ul>
<li>原则，就是编程开发时指导的一个大方向，或是指一类情况，没有那么具体。原则只是一种建议。</li>
<li>规则，是相对原则而言，是更加具体的条目。规则里面有写【建议】还是【必须】遵守。规则一般是可lint检测的。</li>
</ul>
<p>本规范中的规则也分三种类型：</p>
<ol>
<li>大部分默认是Clippy支持lint检测的</li>
<li>也有一些是当前clippy 无法检测但可以定制 lint 的规则</li>
<li>编译器可以检测，警告或报错，但是开发者值得了解的一些规则</li>
</ol>
<p>原则没有办法去检测，所以只能是建议。</p>
<p>通过标题前的编号来标识：</p>
<ul>
<li>标识为<code>P</code>为原则（Principle）。编号方式为<code>P.Element.Number</code>。</li>
<li>标识为<code>G</code>为规则（Guideline）。编号方式为<code>G.Element.Number</code>。</li>
<li>当有子目录时。编号方式为 <code>P.Element.SubElement.Number</code> 或 <code>G.Element.SubElement.Number</code>。</li>
</ul>
<p>Number 从<code>01</code>开始递增。<code>Element</code>为领域知识中关键元素的三位英文字母缩略语。</p>
<table><thead><tr><th>Element</th><th>解释</th><th>Element</th><th>解释</th></tr></thead><tbody>
<tr><td>NAM</td><td>命名</td><td>CMT</td><td>注释</td></tr>
<tr><td>FMT</td><td>格式</td><td>TYP</td><td>数据类型</td></tr>
<tr><td>CNS</td><td>常量</td><td>VAR</td><td>变量</td></tr>
<tr><td>EXP</td><td>表达式</td><td>CTL</td><td>流程控制</td></tr>
<tr><td>RFE</td><td>引用</td><td>PTR</td><td>指针</td></tr>
<tr><td>STR</td><td>字符串</td><td>INT</td><td>整数</td></tr>
<tr><td>MOD</td><td>模块</td><td>CAR</td><td>包管理</td></tr>
<tr><td>MEM</td><td>内存</td><td>FUD</td><td>函数设计</td></tr>
<tr><td>MAC</td><td>宏</td><td>STV</td><td>静态变量</td></tr>
<tr><td>GEN</td><td>泛型</td><td>TRA</td><td>特质</td></tr>
<tr><td>ASY</td><td>异步</td><td>UNS</td><td>非安全</td></tr>
<tr><td>SafeAbstract</td><td>安全抽象</td><td>FFI</td><td>外部函数调用</td></tr>
<tr><td>LAY</td><td>内存布局</td><td>ERR</td><td>错误处理</td></tr>
<tr><td>CLT</td><td>集合</td><td>MTH</td><td>多线程</td></tr>
<tr><td>EMB</td><td>嵌入式Rust</td><td>IO</td><td>输入输出</td></tr>
<tr><td>Security</td><td>信息安全</td><td>OTH</td><td>其他</td></tr>
</tbody></table>
<h2><a class="header" href="#鸣谢" id="鸣谢">鸣谢</a></h2>
<p>本指南参考《华为 C 语言编程指南 V 1.0》，感谢华为 开源能力中心 提供编程指南规范协助！</p>
<h1><a class="header" href="#开发环境" id="开发环境">开发环境</a></h1>
<h2><a class="header" href="#编辑器推荐" id="编辑器推荐">编辑器推荐</a></h2>
<p>VSCode + Rust Analyzer 扩展 </p>
<p>其他辅助vscode 扩展：</p>
<p><a href="https://github.com/willcrichton/flowistry">flowistry</a> ，可以帮助开发者理解 Rust 程序。</p>
<h2><a class="header" href="#ide-推荐" id="ide-推荐">IDE 推荐</a></h2>
<p>Clion</p>
<h2><a class="header" href="#工具链安装" id="工具链安装">工具链安装</a></h2>
<p>使用<a href="https://github.com/rust-lang/rustup"> <code>Rustup</code></a>。 如需替代安装方式，为了保证安全，最好选择官方推荐的替代安装方式。</p>
<h2><a class="header" href="#rust--版次edition-说明" id="rust--版次edition-说明"><strong>Rust  版次（Edition）</strong> <strong>说明</strong></a></h2>
<p>Rust从2015开始，每三年发布一个 Edition 版次：</p>
<blockquote>
<ol>
<li>Rust 2015 edition （Rust 0.1.0 ~ Rust 1.0.0）</li>
<li>Rust 2018 edition （Rust 1.0.0 ~ Rust 1.31.0）</li>
<li>Rust 2021 edition (Rust 1.31.0 ~ Rust 1.56.0 )</li>
</ol>
</blockquote>
<p>以此类推。Edition是向前兼容的。Edition 和语义化版本是正交的，不冲突。</p>
<p>关于 Edition 更详细的内容可以查看：<a href="https://doc.rust-lang.org/edition-guide/">https://doc.rust-lang.org/edition-guide/</a></p>
<h2><a class="header" href="#稳定版-开发版和测试版工具链" id="稳定版-开发版和测试版工具链"><strong>稳定版、 开发版和测试版工具链</strong></a></h2>
<p>Rust 工具链提供三种不同的发布渠道：</p>
<blockquote>
<ol>
<li>Nightly（开发版），每晚发布（release）一次。</li>
<li>Beta（测试版），每六周发布一次，基于Nightly版本。</li>
<li>Stable（稳定版），每六周发布一次，基于 beta版本。</li>
</ol>
</blockquote>
<p>注意：</p>
<blockquote>
<ol>
<li>推荐使用 Stable Rust。</li>
<li>在基于Nightly Rust 开发项目的时候，最好通过在项目中增加 rust-toolchain 文件来指定一个固定的版本，避免因为Nightly Rust 的频繁变更而导致项目编译问题。</li>
<li>当在稳定版工作的时候，如果需要Nightly工具链，不需要整体上去切换工具链到Nightly，只需要再命令中指明Nightly就可以了。比如 <code>cargo +nightly fmt</code>。</li>
</ol>
</blockquote>
<h2><a class="header" href="#包管理器-cargo" id="包管理器-cargo"><strong>包管理器 Cargo</strong></a></h2>
<p>Cargo 是 Rust 项目必不可少的包管理器，除此之外，它也是一种工作流：</p>
<blockquote>
<ol>
<li>可以用Cargo创建一个项目（bin/lib）</li>
<li>可以用它编译项目</li>
<li>可以用它生产项目的文档（依据文档注释）</li>
<li>可以用它运行单元测试（test）和基准测试（bench）</li>
<li>可以用它下载和管理crate依赖</li>
<li>可以用它分发软件包，默认分发到 <a href="http://crates.io/">crates.io</a> 上面</li>
<li>可以为它编写插件，使用子命令的方式，扩展它的功能。</li>
</ol>
</blockquote>
<p>Cargo 通过 Cargo.toml 配置文件来管理 crate。</p>
<p>Toml 配置文件是一种最小化且无歧义的文件格式，Rust社区最常用Toml。可以通过 <a href="http://toml.io/">toml.io</a> 进一步了解 Toml 的细节。</p>
<p>值得说明的是，在配置文件中如果有 [profile.*] 这种配置，需要引起注意，因为这类配置决定了编译器的调用方式，比如：</p>
<blockquote>
<ol>
<li>debug-assertions ，决定了是否开启debug断言。</li>
<li>overflow-checks，决定了是否检查整数运算溢出。</li>
</ol>
</blockquote>
<p>关于Cargo的更多细节可以查看：<a href="https://doc.rust-lang.org/cargo/index.html">https://doc.rust-lang.org/cargo/index.html</a></p>
<h2><a class="header" href="#常用cargo插件" id="常用cargo插件">常用Cargo插件</a></h2>
<p><strong>Clippy</strong></p>
<p>Clippy 是一个静态分析工具，它提供了很多检查，比如错误、 样式、 性能问题、 Unsafe UB问题等等。从1.29版本开始，Clippy可以用于 Stable Rust中。</p>
<p>可以通过 <code>rustup component add clippy</code> 来安装此 Cargo 插件。</p>
<p>细节参考：<a href="https://github.com/rust-lang/rust-clippy">https://github.com/rust-lang/rust-clippy</a></p>
<p>Clippy 的全部 lint 检查建议列表： <a href="https://rust-lang.github.io/rust-clippy/master/">https://rust-lang.github.io/rust-clippy/master/</a></p>
<p><strong>Rustfmt</strong></p>
<p>Rustfmt 是一个根据风格指南原则来格式化代码的工具。</p>
<p>可以通过 Rustup 来安装它： <code>rustup component add rustfmt</code></p>
<p>Rustfmt 依赖的社区维护的 Rust风格指南：<a href="https://github.com/rust-dev-tools/fmt-rfcs/tree/master/guide">https://github.com/rust-dev-tools/fmt-rfcs/tree/master/guide</a></p>
<p>开发者也可以通过 <code>rustfmt.toml</code> 或 <code>.rustfmt.toml</code> 来定制团队统一的代码风格，比如：</p>
<pre><code class="language-toml"># Set the maximum line width to 120
max_width = 120
# Maximum line length for single line if-else expressions
single_line_if_else_max_width = 40
</code></pre>
<p><strong>Rustfix</strong></p>
<p>从 Rust 2018 edition开始，Rustfix就被包含在 Rust 中。它可以用来修复编译器警告。</p>
<p>需要注意的是，在使用 cargo fix 进行自动修复警告的时候，需要开发者确认这个警告是否真的需要修复，并且要验证修复的是否正确。</p>
<p><strong>Cargo Edit</strong></p>
<p>Cargo Edit插件为Cargo扩展了三个命令：</p>
<blockquote>
<ol>
<li>Cargo add，在命令行增加新的依赖，而不需要去知道这个依赖的语义版本。</li>
<li>Cargo rm，在命令行删除一个指定依赖。</li>
<li>Cargo upgrade，在命令行升级一个指定依赖。</li>
</ol>
</blockquote>
<p>Cargo-edit地址：<a href="https://github.com/killercup/cargo-edit">https://github.com/killercup/cargo-edit</a></p>
<p><strong>Cargo Audit</strong></p>
<p>Cargo Audit 可以根据 Rust安全警报数据库（RestSec Advisory Database ）的漏洞数据，扫描crate以及它的所有依赖库，然后给出一份安全报告。</p>
<p>更多细节：<a href="https://github.com/RustSec/cargo-audit">https://github.com/RustSec/cargo-audit</a></p>
<p>Rust 安全警报数据库：<a href="https://rustsec.org/">https://rustsec.org/</a></p>
<p><strong>Cargo Outdated</strong></p>
<p>该插件可以检测依赖库是否有新版本可用。</p>
<p>更多细节：<a href="https://github.com/kbknapp/cargo-outdated">https://github.com/kbknapp/cargo-outdated</a></p>
<p><strong>Cargo Deny</strong></p>
<p>该插件可以检测依赖中的软件许可证（License），如果和开发者配置的不符合，则会拒绝使用该依赖。</p>
<p>更多细节：<a href="https://github.com/EmbarkStudios/cargo-deny">https://github.com/EmbarkStudios/cargo-deny</a></p>
<p>Cargo Deny Book： <a href="https://embarkstudios.github.io/cargo-deny/">https://embarkstudios.github.io/cargo-deny/</a></p>
<h2><a class="header" href="#rustup-和-crates-国内镜像" id="rustup-和-crates-国内镜像">Rustup 和 crates 国内镜像</a></h2>
<h3><a class="header" href="#加速-rustup" id="加速-rustup">加速 Rustup</a></h3>
<p>我们需要指定 <code>RUSTUP_DIST_SERVER</code>（默认指向 https://static.rust-lang.org）和 <code>RUSTUP_UPDATE_ROOT</code> （默认指向https://static.rust-lang.org/rustup），这两个网站均在中国大陆境外，因此在中国大陆访问会很慢，需要配置成境内的镜像。</p>
<p>以下<code> RUSTUP_DIST_SERVER</code> 和 <code>RUSTUP_UPDATE_ROOT</code> 可以组合使用。</p>
<pre><code class="language-toml"># 清华大学
RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup

# 中国科学技术大学
RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static
RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup

# 上海交通大学
RUSTUP_DIST_SERVER=https://mirrors.sjtug.sjtu.edu.cn/rust-static/


# 字节跳动
RUSTUP_DIST_SERVER=&quot;https://rsproxy.cn&quot;
RUSTUP_UPDATE_ROOT=&quot;https://rsproxy.cn/rustup&quot;
</code></pre>
<h3><a class="header" href="#加速-crates" id="加速-crates">加速 crates</a></h3>
<p>将如下配置写入 <code>$HOME/.cargo/config</code> 文件：</p>
<pre><code class="language-toml">
# 放到 `$HOME/.cargo/config` 文件中
[source.crates-io]
registry = &quot;https://github.com/rust-lang/crates.io-index&quot;

# 替换成你偏好的镜像源，比如 字节跳动的
replace-with = 'rsproxy'

# 清华大学
[source.tuna]
registry = &quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;

# 中国科学技术大学
[source.ustc]
registry = &quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;

# 上海交通大学
[source.sjtu]
registry = &quot;https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index&quot;

# rustcc社区
[source.rustcc]
registry = &quot;git://crates.rustcc.cn/crates.io-index&quot;

# 字节跳动 https://rsproxy.cn/
[source.rsproxy]
registry = &quot;https://rsproxy.cn/crates.io-index&quot;

[registries.rsproxy]
index = &quot;https://rsproxy.cn/crates.io-index&quot;

[net]
git-fetch-with-cli = true

</code></pre>
<h3><a class="header" href="#安装-rust" id="安装-rust">安装 Rust</a></h3>
<p>使用 字节跳动源：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">export the env above first
</span>curl --proto '=https' --tlsv1.2 -sSf https://rsproxy.cn/rustup-init.sh | sh
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#代码风格" id="代码风格">代码风格</a></h1>
<p>代码风格包含标识符的命名风格、排版与格式风格、注释风格等。一致的编码习惯与风格，可以提高代码可读性和可维护性。</p>
<ul>
<li><a href="safe-guides/./code_style/naming.html">命名</a></li>
<li><a href="safe-guides/./code_style/fmt.html">格式</a></li>
<li><a href="safe-guides/./code_style/comments.html">注释与文档</a></li>
</ul>
<h1><a class="header" href="#命名" id="命名">命名</a></h1>
<p>好的命名风格能让我们快速地了解某个名字代表的含义（类型、变量、函数、常量、宏等），甚至能凸显其在整个代码上下文中的语义。命名管理对提升代码的可读性和维护性相当重要。</p>
<hr />
<h2><a class="header" href="#pnam01--类型名称应该使用统一的词序" id="pnam01--类型名称应该使用统一的词序">P.NAM.01  类型名称应该使用统一的词序</a></h2>
<h3><a class="header" href="#描述" id="描述">【描述】</a></h3>
<p>类型名称都按照 <strong>动词-宾语-error</strong> 的单词顺序。</p>
<p>具体选择什么样的词序并不重要，但务必要保证同一个 crate 内词序的一致性，以及与标准库相似函数的一致性。</p>
<h3><a class="header" href="#示例" id="示例">【示例】</a></h3>
<p>【正例】</p>
<p>以下是来自标准库的处理错误的一些类型：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/env/struct.JoinPathsError.html"><code>JoinPathsError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/str/struct.ParseBoolError.html"><code>ParseBoolError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/char/struct.ParseCharError.html"><code>ParseCharError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/num/struct.ParseFloatError.html"><code>ParseFloatError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>ParseIntError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/sync/mpsc/enum.RecvTimeoutError.html"><code>RecvTimeoutError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/path/struct.StripPrefixError.html"><code>StripPrefixError</code></a></li>
</ul>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 应该为 ParseAddrError
struct AddrParseError {}
<span class="boring">}
</span></code></pre></pre>
<p>如果增加“解析地址错误”类型，为了保持词性一致，应该使用 <code>ParseAddrError</code> 名称，而不是 <code>AddrParseError</code>。</p>
<h2><a class="header" href="#pnam02--cargo-feature-名中不应该含有无意义的占位词" id="pnam02--cargo-feature-名中不应该含有无意义的占位词">P.NAM.02  cargo feature 名中不应该含有无意义的占位词</a></h2>
<h3><a class="header" href="#描述-1" id="描述-1">【描述】</a></h3>
<p>给 <a href="http://doc.crates.io/manifest.html#the-features-section">Cargo feature</a> 命名时，不要带有无实际含义的的词语，比如无需 <code>use-abc</code> 或 <code>with-abc</code> ，而是直接以 <code>abc</code> 命名。</p>
<p>这条原则经常出现在对 Rust 标准库进行 <a href="https://doc.rust-lang.org/cargo/reference/features.html#optional-dependencies">可选依赖</a> 配置的 crate 上。</p>
<h3><a class="header" href="#示例-1" id="示例-1">【示例】</a></h3>
<p>【正例】</p>
<p>最简洁且正确的做法是：</p>
<pre><code class="language-toml"># In Cargo.toml

[features]
default = [&quot;std&quot;]
std = []
</code></pre>
<pre><code class="language-rust ignored">// In lib.rs

#![cfg_attr(not(feature = &quot;std&quot;), no_std)]
</code></pre>
<p>【反例】</p>
<pre><code class="language-toml"># In Cargo.toml

// 不要给 feature 取 `use-std` 或者 `with-std` 或者除 `std` 之外另取名字。
[features]
default = [&quot;use-std&quot;]
std = []
</code></pre>
<pre><code class="language-rust ignored">// In lib.rs

#![cfg_attr(not(feature = &quot;use-std&quot;), no_std)]
</code></pre>
<p>feature 应与 Cargo 在推断可选依赖时隐含的 features 具有一致的名字。</p>
<p>【正例】</p>
<p>假如 <code>x</code> crate 对 Serde 和 标准库具有可选依赖关系：</p>
<pre><code class="language-toml">[package]
name = &quot;x&quot;
version = &quot;0.1.0&quot;

[features]
std = [&quot;serde/std&quot;]

[dependencies]
serde = { version = &quot;1.0&quot;, optional = true }
</code></pre>
<p>当我们使用 <code>x</code> crate 时，可以使用 <code>features = [&quot;serde&quot;]</code> 开启 Serde 依赖。类似地，也可以使用 <code>features = [&quot;std&quot;]</code> 开启标准库依赖。
Cargo 推断的隐含的 features 应该叫做 <code>serde</code> ，而不是 <code>use-serde</code> 或者 <code>with-serde</code> 。</p>
<p>【反例】</p>
<pre><code class="language-toml">[package]
name = &quot;x&quot;
version = &quot;0.1.0&quot;

[features]
std = [&quot;serde/std&quot;]
// Cargo 要求 features 应该是叠加的，所以像 `no-abc` 这种负向的 feature 命名实际上并不正确。
no-abc=[]

[dependencies]
serde = { version = &quot;1.0&quot;, optional = true }
</code></pre>
<hr />
<h2><a class="header" href="#gnam01-标识符命名应该符合阅读习惯" id="gnam01-标识符命名应该符合阅读习惯">G.NAM.01 标识符命名应该符合阅读习惯</a></h2>
<h3><a class="header" href="#级别必须" id="级别必须">【级别：必须】</a></h3>
<p>必须严格按此规范执行。</p>
<h3><a class="header" href="#lint-检测" id="lint-检测">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制化参考】</p>
<p>检测错误的英文拼写，检测出后提示；检测拼音，检测出来提示。拼写错误可参考 <a href="https://github.com/client9/misspell">client9/misspell</a> 。</p>
<h3><a class="header" href="#描述-2" id="描述-2">【描述】</a></h3>
<p>标识符的命名要清晰、明了，有明确含义，容易理解。符合英文阅读习惯的命名将明显提高代码可读性。</p>
<p>一些好的实践包括但不限于：</p>
<ul>
<li>使用正确的英文单词并符合英文语法，不要使用拼音</li>
<li>仅使用常见或领域内通用的单词缩写</li>
<li>布尔型变量或函数避免使用否定形式</li>
<li>尽量不要使用 Unicode 标识符。</li>
</ul>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let first_name: &amp;str = &quot;John&quot;;
let last_name: &amp;str = &quot;Smith&quot;;
const ERROR_DIRECTORY_NOT_SUPPORTED: u32 = 336;
const ERROR_DRIVER_CANCEL_TIMEOUT: u32 = 594;
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ming: &amp;str = &quot;John&quot;;
let xing: &amp;str = &quot;Smith&quot;;
const ERROR_NO_1: u32 = 336;
const ERROR_NO_2: u32 = 594;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gnam02-使用统一的命名风格" id="gnam02-使用统一的命名风格">G.NAM.02 使用统一的命名风格</a></h2>
<h3><a class="header" href="#级别必须-1" id="级别必须-1">【级别：必须】</a></h3>
<p>必须严格按此规范执行。</p>
<h3><a class="header" href="#lint-检测-1" id="lint-检测-1">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th></tr></thead><tbody>
<tr><td><a href="https://doc.rust-lang.org/rustc/lints/listing/warn-by-default.html#non-camel-case-types"><code>Rustc: non_camel_case_types</code></a></td><td>no</td><td>yes</td><td>Style</td></tr>
<tr><td><a href="https://doc.rust-lang.org/rustc/lints/listing/warn-by-default.html#non-snake-case"><code>Rustc: non_snake_case</code></a></td><td>no</td><td>yes</td><td>Style</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-3" id="描述-3">【描述】</a></h3>
<p>Rust 命名规范在 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0430-finalizing-naming-conventions.md">RFC 0430</a> 中有描述。总的来说，Rust 倾向于在“类型级别”的结构中使用 <code>UpperCamelCase</code> 命名风格，在 “值（实例）级别”的结构中使用 <code>snake_case</code>命名风格。</p>
<p>下面是具体汇总。</p>
<table><thead><tr><th>Item</th><th>规范</th></tr></thead><tbody>
<tr><td>包（Crates）</td><td><a href="https://github.com/rust-lang/api-guidelines/issues/29">最好使用 snake_case</a> <sup class="footnote-reference"><a href="#crate-name">1</a></sup></td></tr>
<tr><td>模块（Modules）</td><td><code>snake_case</code></td></tr>
<tr><td>类型（Types）</td><td><code>UpperCamelCase</code></td></tr>
<tr><td>特质（Traits）</td><td><code>UpperCamelCase</code></td></tr>
<tr><td>枚举体（Enum variants）</td><td><code>UpperCamelCase</code></td></tr>
<tr><td>函数（Functions）</td><td><code>snake_case</code></td></tr>
<tr><td>方法（Methods）</td><td><code>snake_case</code></td></tr>
<tr><td>通用构造函数（General constructors）</td><td><code>new</code> 或者 <code>with_more_details</code></td></tr>
<tr><td>转换构造函数（Conversion constructors）</td><td><code>from_some_other_type</code></td></tr>
<tr><td>宏（Macros）</td><td><code>snake_case!</code></td></tr>
<tr><td>本地变量（Local variables）</td><td><code>snake_case</code></td></tr>
<tr><td>静态变量（Statics）</td><td><code>SCREAMING_SNAKE_CASE</code></td></tr>
<tr><td>常量（Constants）</td><td><code>SCREAMING_SNAKE_CASE</code></td></tr>
<tr><td>类型参数（Type parameters）</td><td>简明的 <code>UpperCamelCase</code> ，通常使用单个大写字母： <code>T</code></td></tr>
<tr><td>生存期（Lifetimes）</td><td>简短的 <code>lowercase</code>，通常使用单个小写字母 <code>'a</code>, <code>'de</code>, <code>'src</code>，尽量保持语义</td></tr>
<tr><td>特性（Features）</td><td><a href="https://github.com/rust-lang/api-guidelines/issues/101">有争议</a> ，但是一般遵照 [C-FEATURE]</td></tr>
</tbody></table>
<p>说明 :</p>
<ol>
<li>在 <code>UpperCamelCase</code>情况下，由首字母缩写组成的缩略语和 复合词的缩写，算作一个词。比如，应该使用 <code>Uuid</code> 而非 <code>UUID</code>，使用 <code>Usize</code> 而不是 <code>USize</code>，或者是 <code>Stdin</code> 而不是 <code>StdIn</code>。</li>
<li>在<code>snake_case</code>中，首字母缩写和缩略词是小写的：is_xid_start。</li>
<li>在 <code>snake_case</code> 或者 <code>SCREAMING_SNAKE_CASE</code> 情况下，每个词不应该由单个字母组成——除非这个字母是最后一个词。比如，使用 <code>btree_map</code> 而不使用 <code>b_tree_map</code>，使用 <code>PI_2</code> 而不使用 <code>PI2</code> 。</li>
</ol>
<p>关于包命名：</p>
<ul>
<li><sup class="footnote-reference"><a href="#crate-name">1</a></sup>: 由于历史问题，包名有两种形式 <code>snake_case</code> 或 <code>kebab-case</code> ，但实际在代码中需要引入包名的时候，Rust 只能识别 <code>snake_case</code>，也会自动将 <code>kebab-case</code> 识别为  <code>kebab_case</code>。</li>
<li>Crate 的名称通常不应该使用 <code>-rs</code> 或者 <code>-rust</code> 作为后缀或者前缀。 因为每个 crate 都是 Rust 编写的！ 没必要一直提醒使用者这一点。但是有些情况下，比如是其他语言移植的同名 Rust 实现，则可以使用 <code>-rs</code> 后缀来表明这是 Rust 实现的版本。</li>
</ul>
<h2><a class="header" href="#gnam03-作用域越大命名越精确反之应简短" id="gnam03-作用域越大命名越精确反之应简短">G.NAM.03 作用域越大，命名越精确；反之应简短</a></h2>
<h3><a class="header" href="#级别建议" id="级别建议">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-2" id="lint-检测-2">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#module_name_repetitions">module_name_repetitions</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-4" id="描述-4">【描述】</a></h3>
<ol>
<li>对于全局函数、全局变量、宏、类型名、枚举命名，应当精确描述并全局唯一。</li>
<li>对于函数局部变量，或者结构体、枚举中的成员变量，在其命名能够准确表达含义的前提下，应该尽量简短，避免冗余信息重复描述。</li>
</ol>
<h3><a class="header" href="#示例-2" id="示例-2">【示例】</a></h3>
<p><strong>全局静态变量示例</strong></p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static GET_MAX_THREAD_COUNT: i32 = 42;  // 符合
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static GET_COUNT: i32 = 42;  // 不符合：描述不精确
<span class="boring">}
</span></code></pre></pre>
<p><strong>枚举类型的成员命名的例子：</strong></p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合： 上下文信息已经知道它是 Event
enum WebEvent {
    // An `enum` may either be `unit-like`,
    PageLoad,
    PageUnload,
    // like tuple structs,
    KeyPress(char),
    Paste(String),
    // or c-like structures.
    Click { x: i64, y: i64 },
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>// 不符合

enum WebEvent {
    // An `enum` may either be `unit-like`,
    PageLoadEvent,
    PageUnloadEvent,
    // like tuple structs,
    KeyPressEvent(char),
    PasteEvent(String),
    // or c-like structures.
    ClickEvent { x: i64, y: i64 },
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>类型别名示例</strong></p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Size = u16; 

pub struct HeaderMap {
    // 在使用它的地方自然就知道是描述谁的大小
    mask: Size,
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type MaskSize = u16; 

pub struct HeaderMap {
    // 这样使用就显得有些冗余
    mask: MaskSize,
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gnam04-类型转换函数命名需要遵循所有权语义" id="gnam04-类型转换函数命名需要遵循所有权语义">G.NAM.04 类型转换函数命名需要遵循所有权语义</a></h2>
<h3><a class="header" href="#级别必须-2" id="级别必须-2">【级别：必须】</a></h3>
<p>必须严格按此规范执行。</p>
<h3><a class="header" href="#lint-检测-3" id="lint-检测-3">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>Lint Level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/index.html#wrong_self_convention">wrong_self_convention</a></td><td>yes</td><td>no</td><td>Style</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-5" id="描述-5">【描述】</a></h3>
<p>应该使用带有以下前缀名称方法来进行特定类型转换：</p>
<table><thead><tr><th>名称前缀</th><th>内存代价</th><th>所有权</th></tr></thead><tbody>
<tr><td><code>as_</code></td><td>无代价</td><td>borrowed -&gt; borrowed</td></tr>
<tr><td><code>to_</code></td><td>代价昂贵</td><td>borrowed -&gt; borrowed<br>borrowed -&gt; owned (非 Copy 类型)<br>owned -&gt; owned (Copy 类型)</td></tr>
<tr><td><code>into_</code></td><td>看情况</td><td>owned -&gt; owned (非 Copy 类型)</td></tr>
</tbody></table>
<h3><a class="header" href="#示例-3" id="示例-3">【示例】</a></h3>
<p>【正例】</p>
<ul>
<li><code>as_</code>
<ul>
<li><a href="https://doc.rust-lang.org/std/primitive.str.html#method.as_bytes"><code>str::as_bytes()</code></a> 
用于查看 UTF-8 字节的 <code>str</code> 切片，
这是无内存代价的（不会产生内存分配）。
传入值是 <code>&amp;str</code> 类型，输出值是 <code>&amp;[u8]</code> 类型。</li>
</ul>
</li>
<li><code>to_</code>
<ul>
<li><a href="https://doc.rust-lang.org/std/path/struct.Path.html#method.to_str"><code>Path::to_str</code></a> 
对操作系统路径进行 UTF-8 字节检查，开销昂贵。
虽然输入和输出都是借用，但是这个方法对运行时产生不容忽视的代价，
所以不应使用 <code>as_str</code> 名称。</li>
<li><a href="https://doc.rust-lang.org/std/primitive.str.html#method.to_lowercase"><code>str::to_lowercase()</code></a> 
生成正确的 Unicode 小写字符，
涉及遍历字符串的字符，可能需要分配内存。
输入值是 <code>&amp;str</code> 类型，输出值是 <code>String</code> 类型。</li>
<li><a href="https://doc.rust-lang.org/std/primitive.f64.html#method.to_radians"><code>f64::to_radians()</code></a> 
把浮点数的角度制转换成弧度制。
输入和输出都是 <code>f64</code> 。没必要传入 <code>&amp;f64</code> ，因为复制 <code>f64</code> 花销很小。
但是使用 <code>into_radians</code> 名称就会具有误导性，因为输入数据没有被消耗。</li>
</ul>
</li>
<li><code>into_</code>
<ul>
<li><a href="https://doc.rust-lang.org/std/string/struct.String.html#method.into_bytes"><code>String::into_bytes()</code></a>
从 <code>String</code> 提取出背后的 <code>Vec&lt;u8&gt;</code> 数据，这是无代价的。
它转移了 <code>String</code> 的所有权，然后返回具有所有权的 <code>Vec&lt;u8&gt;</code> 。</li>
<li><a href="https://doc.rust-lang.org/std/io/struct.BufReader.html#method.into_inner"><code>BufReader::into_inner()</code></a> 
转移了 buffered reader 的所有权，取出其背后的 reader ，这是无代价的。
存于缓冲区的数据被丢弃了。</li>
<li><a href="https://doc.rust-lang.org/std/io/struct.BufWriter.html#method.into_inner"><code>BufWriter::into_inner()</code></a> 
转移了 buffered writer 的所有权，取出其背后的 writer ，这可能以很大的代价刷新所有缓存数据。</li>
</ul>
</li>
</ul>
<p>以 <code>as_</code> 和 <code>into_</code> 作为前缀的类型转换通常是 <em>降低抽象层次</em> ，要么是查看背后的数据 ( <code>as</code> ) ，要么是分解 (deconstructe) 背后的数据 ( <code>into</code> ) 。
相对来说，以 <code>to_</code> 作为前缀的类型转换处于同一个抽象层次，但是做了更多的工作。</p>
<p>当一个类型用更高级别的语义 (higher-level semantics) 封装 (wraps) 一个与之有关的值时，应该使用 <code>into_inner()</code> 方法名来取出被封装的值。</p>
<p>这适用于以下封装器：</p>
<p>读取缓存 (<a href="https://doc.rust-lang.org/std/io/struct.BufReader.html#method.into_inner"><code>BufReader</code></a>) 、编码或解码 (<a href="https://docs.rs/flate2/1.0.20/flate2/read/struct.GzDecoder.html#method.into_inner"><code>GzDecoder</code></a>) 、取出原子 (<a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html#method.into_inner"><code>AtomicBool</code></a>) 、
或者任何相似的语义 (<a href="https://doc.rust-lang.org/std/io/struct.BufWriter.html#method.into_inner"><code>BufWriter</code></a>)。</p>
<p>如果类型转换方法返回的类型具有 <code>mut</code> 标识符，那么这个方法的名称应如同返回类型组成部分的顺序那样，带有 <code>mut</code> 名。
比如 <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.as_mut_slice"><code>Vec::as_mut_slice</code></a> 返回 <code>mut slice</code> 类型，这个方法的功能正如其名称所述，所以这个名称优于 <code>as_slice_mut</code> 。</p>
<pre><code class="language-rust.ignored">// Return type is a mut slice.
fn as_mut_slice(&amp;mut self) -&gt; &amp;mut [T];
</code></pre>
<p>更多来自标准库的例子：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.as_ref"><code>Result::as_ref</code></a></li>
<li><a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.as_ptr"><code>RefCell::as_ptr</code></a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.to_vec"><code>slice::to_vec</code></a></li>
<li><a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.into_iter"><code>Option::into_iter</code></a></li>
</ul>
<h2><a class="header" href="#gnam05-用于访问或获取数据的-gettersetter-类方法通常不要使用-get_-或-set_-等前缀" id="gnam05-用于访问或获取数据的-gettersetter-类方法通常不要使用-get_-或-set_-等前缀">G.NAM.05 用于访问或获取数据的 <code>getter/setter</code> 类方法通常不要使用 <code>get_</code> 或 <code>set_</code> 等前缀</a></h2>
<h3><a class="header" href="#级别建议-1" id="级别建议-1">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-4" id="lint-检测-4">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制化参考】</p>
<p>检测 Struct 实现的方法名是否包含 <code>get_/set_</code> 前缀，如果包含，则给予警告。 </p>
<h3><a class="header" href="#描述-6" id="描述-6">【描述】</a></h3>
<p>因为 Rust 所有权语义的存在，此例子中两个方法的参数分别是共享引用 <code>&amp;self</code> 和 独占引用 <code>&amp;mut self</code>，分别代表了 getter 和 setter 的语义。</p>
<h3><a class="header" href="#示例-4" id="示例-4">【示例】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct First;
pub struct Second;

pub struct S {
    first: First,
    second: Second,
}

impl S {
    // 不建议 `get_first`。
    pub fn first(&amp;self) -&gt; &amp;First {
        &amp;self.first
    }

    // 不建议 `get_first_mut`, `get_mut_first`, or `mut_first`.
    pub fn first_mut(&amp;mut self) -&gt; &amp;mut First {
        &amp;mut self.first
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct First;
pub struct Second;

pub struct S {
    first: First,
    second: Second,
}

impl S {
    // 不符合：访问成员函数名字不用get_前缀。
    pub fn get_first(&amp;self) -&gt; &amp;First {
        &amp;self.first
    }

    // 不符合：
    // 同样不建议 `get_mut_first`, or `mut_first`.
    pub fn get_first_mut(&amp;mut self) -&gt; &amp;mut First {
        &amp;mut self.first
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>【例外】</p>
<p>但也存在例外情况：只有当有一个明显的东西可以通过<code>getter</code>得到时，才会使用<code>get</code>命名。例如，<code>Cell::get</code>可以访问一个<code>Cell</code>的内容。</p>
<p>对于进行运行时验证的getter，例如边界检查，可以考虑添加一个 Unsafe 的<code>_unchecked</code> 配套方法。一般来说，会有以下签名。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 进行一些运行时验证，例如边界检查
fn get(&amp;self, index: K) -&gt; Option&lt;&amp;V&gt;;
fn get_mut(&amp;mut self, index: K) -&gt; Option&lt;&amp;mut V&gt;;
// 没有运行时验证，用于在某些情况下提升性能。比如，在当前运行环境中不可能发生越界的情况。
unsafe fn get_unchecked(&amp;self, index: K) -&gt; &amp;V;
unsafe fn get_unchecked_mut(&amp;mut self, index: K) -&gt; &amp;mut V;
<span class="boring">}
</span></code></pre></pre>
<p>getter 和类型转换 (G.NAM.02) 之间的区别很小，大部分时候不那么清晰可辨。比如 <a href="https://docs.rs/tempdir/0.3.7/tempdir/struct.TempDir.html#method.path"><code>TempDir::path</code></a> 可以被理解为临时目录的文件系统路径的 getter ，而 <a href="https://docs.rs/tempdir/0.3.7/tempdir/struct.TempDir.html#method.into_path"><code>TempDir::into_path</code></a> 负责把删除临时目录时转换的数据传给调用者。</p>
<p>因为 <code>path</code> 方法是一个 getter ，如果用 <code>get_path</code> 或者 <code>as_path</code> 就不对了。</p>
<p>来自标准库的例子：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/io/struct.Cursor.html#method.get_mut"><code>std::io::Cursor::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/ptr/struct.Unique.html#method.get_mut"><code>std::ptr::Unique::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/sync/struct.PoisonError.html#method.get_mut"><code>std::sync::PoisonError::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html#method.get_mut"><code>std::sync::atomic::AtomicBool::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/hash_map/struct.OccupiedEntry.html#method.get_mut"><code>std::collections::hash_map::OccupiedEntry::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get_unchecked"><code>&lt;[T]&gt;::get_unchecked</code></a></li>
</ul>
<h2><a class="header" href="#gnam06-遵循-iter-iter_mut-into_iter-规范来生成迭代器" id="gnam06-遵循-iter-iter_mut-into_iter-规范来生成迭代器">G.NAM.06 遵循 <code>iter/ iter_mut/ into_iter</code> 规范来生成迭代器</a></h2>
<h3><a class="header" href="#级别必须-3" id="级别必须-3">【级别：必须】</a></h3>
<p>必须严格按此规范执行。</p>
<h3><a class="header" href="#lint-检测-5" id="lint-检测-5">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制化参考】</p>
<p>检测 <code>iter/iter_mut/into_iter</code> 方法的返回类型是否对应 <code>Iter/IterMut/IntoIter</code> ，如果不是，则给予警告。</p>
<h3><a class="header" href="#描述-7" id="描述-7">【描述】</a></h3>
<p>对于容纳 <code>U</code> 类型的容器 (container) ，其迭代器方法应该这样命名：</p>
<pre><code class="language-rust ignored">fn iter(&amp;self) -&gt; Iter             // Iter 实现 Iterator&lt;Item = &amp;U&gt;
fn iter_mut(&amp;mut self) -&gt; IterMut  // IterMut 实现 Iterator&lt;Item = &amp;mut U&gt;
fn into_iter(self) -&gt; IntoIter     // IntoIter 实现 Iterator&lt;Item = U&gt;
</code></pre>
<p>此规则适用于在概念上属于同质集合的数据结构的方法，而非函数。例如，第三方库 <code>url</code>  中的 <a href="https://docs.rs/url/1.4.0/url/percent_encoding/fn.percent_encode.html">percent_encode</a> 返回一个 URL 编码的字符串片段的迭代器。使用<code>iter/iter_mut/into_iter</code>约定的话，函数名就不会有任何明确的语义了。</p>
<h3><a class="header" href="#示例-5" id="示例-5">【示例】</a></h3>
<p>【正例】</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter"><code>Vec::iter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter_mut"><code>Vec::iter_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.into_iter"><code>Vec::into_iter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.iter"><code>BTreeMap::iter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.iter_mut"><code>BTreeMap::iter_mut</code></a></li>
</ul>
<p>【反例】</p>
<p>标准库中存在一个反例： <code>str</code> 类型是有效 UTF-8 字节的切片（slice），概念上与同质集合略有差别，所以 <code>str</code> 没有提供 <code>iter</code>/<code>iter_mut</code>/<code>into_iter</code> 命名的迭代器方法，而是提供 <a href="https://doc.rust-lang.org/std/primitive.str.html#method.bytes"><code>str::bytes</code></a> 方法来输出字节迭代器、<a href="https://doc.rust-lang.org/std/primitive.str.html#method.chars"><code>str::chars</code></a> 方法来输出字符迭代器。</p>
<h3><a class="header" href="#参考" id="参考">【参考】</a></h3>
<p>参考 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0199-ownership-variants.md">RFC 199</a> 。</p>
<h2><a class="header" href="#gnam07-迭代器类型名称应该与产生它们的方法相匹配" id="gnam07-迭代器类型名称应该与产生它们的方法相匹配">G.NAM.07 迭代器类型名称应该与产生它们的方法相匹配</a></h2>
<h3><a class="header" href="#级别必须-4" id="级别必须-4">【级别：必须】</a></h3>
<p>必须严格按此规范执行。</p>
<h3><a class="header" href="#lint-检测-6" id="lint-检测-6">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制化参考】</p>
<p>检测返回迭代器的方法，其返回类型应该与方法名相匹配，否则给予警告。</p>
<h3><a class="header" href="#描述-8" id="描述-8">【描述】</a></h3>
<p>一个叫做<code>into_iter()</code>的方法应该返回一个叫做<code>IntoIter</code>的类型，同样，所有其他返回迭代器的方法也是如此。</p>
<p>这条规则主要适用于方法，但通常对函数也有意义。例如，第三方库 <code>url</code>  中的 <a href="https://docs.rs/url/1.4.0/url/percent_encoding/fn.percent_encode.html">percent_encode</a> 返回一个<code>PercentEncode</code> 类型的迭代器。</p>
<h3><a class="header" href="#示例-6" id="示例-6">【示例】</a></h3>
<p>【正例】</p>
<p>来自标准库的例子：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter"><code>Vec::iter</code></a> 返回 <a href="https://doc.rust-lang.org/std/slice/struct.Iter.html"><code>Iter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter_mut"><code>Vec::iter_mut</code></a> 返回 <a href="https://doc.rust-lang.org/std/slice/struct.IterMut.html"><code>IterMut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.into_iter"><code>Vec::into_iter</code></a> 返回 <a href="https://doc.rust-lang.org/std/vec/struct.IntoIter.html"><code>IntoIter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.keys"><code>BTreeMap::keys</code></a> 返回 <a href="https://doc.rust-lang.org/std/collections/btree_map/struct.Keys.html"><code>Keys</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.values"><code>BTreeMap::values</code></a> 返回 <a href="https://doc.rust-lang.org/std/collections/btree_map/struct.Values.html"><code>Values</code></a></li>
</ul>
<h2><a class="header" href="#gnam8--避免使用语言内置保留字关键字内置类型和trait等特殊名称" id="gnam8--避免使用语言内置保留字关键字内置类型和trait等特殊名称">G.NAM.8  避免使用语言内置保留字、关键字、内置类型和<code>trait</code>等特殊名称</a></h2>
<h3><a class="header" href="#级别必须-5" id="级别必须-5">【级别：必须】</a></h3>
<p>必须严格按此规范执行。</p>
<h3><a class="header" href="#lint-检测-7" id="lint-检测-7">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制化参考】</p>
<p>可以检测 标识符 是否通过<code>r#</code>使用了 语言内置的保留字、关键字、内置类型和<code>trait</code>等特殊名称，如果使用，则给予警告。</p>
<h3><a class="header" href="#描述-9" id="描述-9">【描述】</a></h3>
<p>命名必须要避免使用语言内置的保留字、关键字、内置类型和<code>trait</code>等特殊名称。</p>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">// Sized ： Rust 内置了同名 trait 
type Sized = u16; 

fn main() {
    // try 为保留关键字，使用`r#`前缀可以使用它，但要尽力避免
    let r#try = 1;
}
</code></pre></pre>
<hr />
<h1><a class="header" href="#格式" id="格式">格式</a></h1>
<p>Rust 有自动化格式化工具 rustfmt ，可以帮助开发者摆脱手工调整代码格式的工作，提升生产力。但是，rustfmt 遵循什么样的风格规范，作为开发者应该需要了解，在编写代码的时候可以主动按这样的风格编写。</p>
<p>说明：以下 <code>rustfmt</code> 配置中对应配置项如果 <code>Stable</code>为<code>No</code>，则表示该配置项不能用于 Stable Rust 下在 <code>rustfmt.toml</code> 中自定义，但其默认值会在<code>cargo fmt</code>时生效。在 Nightly Rust 下则都可以自定义。</p>
<p>在 Stable Rust 下使用未稳定配置项的方法、了解配置示例及其他全局配置项说明请参阅：<a href="safe-guides/code_style/../../tools/rustfmt.html">Rustfmt 配置相关说明</a> 。</p>
<p>注意： 以下规则 针对 rustfmt  version 1.4.36 版本。</p>
<hr />
<h2><a class="header" href="#pfmt01-代码格式以保证可读性为前提" id="pfmt01-代码格式以保证可读性为前提">P.FMT.01 代码格式以保证可读性为前提</a></h2>
<h3><a class="header" href="#描述-10" id="描述-10">【描述】</a></h3>
<p>制定统一的编码风格，是为了提升代码的可读性，让日常代码维护和团队之间审查代码更加方便。</p>
<hr />
<h2><a class="header" href="#gfmt01-始终使用-rustfmt-进行自动格式化代码" id="gfmt01-始终使用-rustfmt-进行自动格式化代码">G.FMT.01 始终使用 rustfmt 进行自动格式化代码</a></h2>
<h3><a class="header" href="#级别建议-2" id="级别建议-2">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-8" id="lint-检测-8">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制化建议】</p>
<p>通过检测 项目 根目录下是否存在 <code>rustfmt.toml</code> 或 <code>.rustfmt.toml</code> ，如果没有该文件，则发出警告，让开发者使用 rustfmt 来格式化代码。</p>
<h3><a class="header" href="#描述-11" id="描述-11">【描述】</a></h3>
<p>应该总是在项目中添加 <code>rustfmt.toml</code> 或 <code>.rustfmt.toml</code>文件，即使它是空文件。这是向潜在的合作者表明你希望代码是自动格式化的。</p>
<h3><a class="header" href="#例外" id="例外">【例外】</a></h3>
<p>在特殊的情况下，可以通过条件编译属性 <code>#[cfg_attr(rustfmt, rustfmt_skip)]</code> 或 <code>#[rustfmt::skip]</code> 来关闭自动格式化。</p>
<p>比如下面示例：</p>
<p><code>vec!</code> 中的元素排布是固定格式，这样有助于开发的便利。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let got = vec![
            0x00, 0x05, 0x01, 0x00,
            0xff,
            0x00,
            0x00,
    
            0x01, 0x0c, 0x02, 0x00,
            0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef,
            b'd', b'e', b'a', b'd', b'b', b'e', b'e', b'f', 0x00,
            0x00,
    
            127, 0x06, 0x03, 0x00,
            0x01, 0x02,
            b'a', b'b', b'c', b'd', 0x00,
            b'1', b'2', b'3', b'4', 0x00,
            0x00,
    ];
}
</code></pre></pre>
<p>如果使用 自动格式化，会变成：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let got = vec![
        0x00, 0x05, 0x01, 0x00, 0xff, 0x00, 0x00, 0x01, 0x0c, 0x02, 0x00, 0xde, 0xad, 0xbe, 0xef,
        0xde, 0xad, 0xbe, 0xef, b'd', b'e', b'a', b'd', b'b', b'e', b'e', b'f', 0x00, 0x00, 127,
        0x06, 0x03, 0x00, 0x01, 0x02, b'a', b'b', b'c', b'd', 0x00, b'1', b'2', b'3', b'4', 0x00,
        0x00,
    ];
}
</code></pre></pre>
<p>但是加上 <code>#[rustfmt::skip]</code> 就不会被自动格式化影响：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    #[rustfmt::skip] 
    let got = vec![
            0x00, 0x05, 0x01, 0x00,
            0xff,
            0x00,
            0x00,
    
            0x01, 0x0c, 0x02, 0x00,
            0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef,
            b'd', b'e', b'a', b'd', b'b', b'e', b'e', b'f', 0x00,
            0x00,
    
            127, 0x06, 0x03, 0x00,
            0x01, 0x02,
            b'a', b'b', b'c', b'd', 0x00,
            b'1', b'2', b'3', b'4', 0x00,
            0x00,
    ];
}

</code></pre></pre>
<h2><a class="header" href="#gfmt02-缩进始终使用空格space而非制表符tab" id="gfmt02-缩进始终使用空格space而非制表符tab">G.FMT.02 缩进始终使用空格（space）而非制表符（tab）</a></h2>
<h3><a class="header" href="#级别必须-6" id="级别必须-6">【级别：必须】</a></h3>
<p>必须严格按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置" id="rustfmt-配置">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/#tab_spaces"><code>tab_spaces</code></a></td><td>4</td><td>yes（默认）</td><td>缩进空格数｜</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/#hard_tabs"><code>hard_tabs</code></a></td><td>false</td><td>yes（默认）</td><td>禁止使用tab缩进｜</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-12" id="描述-12">【描述】</a></h3>
<ol>
<li>缩进要使用 四个 空格，不要使用制表符（<code>\t</code>）代替。</li>
<li>通过 IDE/Editor 为缩进默认好设置值。</li>
</ol>
<h2><a class="header" href="#gfmt03-每行最大宽度为-100-个字符" id="gfmt03-每行最大宽度为-100-个字符">G.FMT.03 每行最大宽度为 100 个字符</a></h2>
<h3><a class="header" href="#级别建议-3" id="级别建议-3">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-1" id="rustfmt-配置-1">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#max_width"><code>max_width</code></a></td><td>100</td><td>yes（默认）</td><td>行最大宽度默认值</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#error_on_line_overflow"><code>error_on_line_overflow</code></a></td><td>false（默认）</td><td>No (tracking issue: #3391)</td><td>如果超过最大行宽设置则报错</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#use_small_heuristics"><code>use_small_heuristics</code></a></td><td>Default（默认）Max（推荐）</td><td>Yes</td><td>统一管理宽度设置</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-13" id="描述-13">【描述】</a></h3>
<p>代码行宽不宜过长，否则不利于阅读。
建议每行字符数不要超过 100 个字符。</p>
<p><code>rustfmt</code> 还提供很多其他宽度设置：</p>
<ul>
<li>fn_call_width, 函数调用最大宽度设置，其默认值是 <code>max_width</code>的 <code>60%</code>。</li>
<li>attr_fn_like_width, 像函数那样使用的属性宏最大宽度，其默认值是 <code>max_width</code>的 <code>70%</code>。</li>
<li>struct_lit_width,  结构体字面量最大宽度，其默认值是 <code>max_width</code>的 <code>18%</code>。</li>
<li>struct_variant_width, 结构体变量最大宽度，其默认值是 <code>max_width</code>的 <code>35%</code>。</li>
<li>array_width, 数组最大宽度，其默认值是 <code>max_width</code>的 <code>60%</code>。</li>
<li>chain_width, 链式结构最大宽度，其默认值是 <code>max_width</code>的 <code>60%</code>。</li>
<li>single_line_if_else_max_width，单行 <code>if-else</code> 最大宽度，其默认值是 <code>max_width</code>的 <code>50%</code>。</li>
</ul>
<p>这么多宽度设置管理起来比较麻烦，所以使用 <code>use_small_heuristics</code> 来管理更好。</p>
<h3><a class="header" href="#示例-7" id="示例-7">【示例】</a></h3>
<p><code>use_small_heuristics</code> 默认配置示例。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">enum Lorem {
    Ipsum,
    Dolor(bool),
    Sit { amet: Consectetur, adipiscing: Elit },
}

fn main() {
    lorem(
        &quot;lorem&quot;,
        &quot;ipsum&quot;,
        &quot;dolor&quot;,
        &quot;sit&quot;,
        &quot;amet&quot;,
        &quot;consectetur&quot;,
        &quot;adipiscing&quot;,
    );

    let lorem = Lorem {
        ipsum: dolor,
        sit: amet,
    };
    let lorem = Lorem { ipsum: dolor };

    let lorem = if ipsum { dolor } else { sit };
}
</code></pre></pre>
<p>【反例】</p>
<p>当<code>use_small_heuristics</code> 配置为 <code>Off</code> :</p>
<pre><pre class="playground"><code class="language-rust">enum Lorem {
    Ipsum,
    Dolor(bool),
    Sit {
        amet: Consectetur,
        adipiscing: Elit,
    },
}

fn main() {
    lorem(&quot;lorem&quot;, &quot;ipsum&quot;, &quot;dolor&quot;, &quot;sit&quot;, &quot;amet&quot;, &quot;consectetur&quot;, &quot;adipiscing&quot;);

    let lorem = Lorem {
        ipsum: dolor,
        sit: amet,
    };

    let lorem = if ipsum {
        dolor
    } else {
        sit
    };
}
</code></pre></pre>
<p>当<code>use_small_heuristics</code> 配置为 <code>Max</code> :</p>
<pre><pre class="playground"><code class="language-rust">enum Lorem {
    Ipsum,
    Dolor(bool),
    Sit { amet: Consectetur, adipiscing: Elit },
}

fn main() {
    lorem(&quot;lorem&quot;, &quot;ipsum&quot;, &quot;dolor&quot;, &quot;sit&quot;, &quot;amet&quot;, &quot;consectetur&quot;, &quot;adipiscing&quot;);

    let lorem = Lorem { ipsum: dolor, sit: amet };

    let lorem = if ipsum { dolor } else { sit };
}
</code></pre></pre>
<h2><a class="header" href="#gfmt04-行间距最大宽度空一行" id="gfmt04-行间距最大宽度空一行">G.FMT.04 行间距最大宽度空一行</a></h2>
<h3><a class="header" href="#级别建议-4" id="级别建议-4">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-2" id="rustfmt-配置-2">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#blank_lines_lower_bound"><code>blank_lines_lower_bound</code></a></td><td>0（默认）</td><td>No</td><td>不空行</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#blank_lines_upper_bound"><code>blank_lines_upper_bound</code></a></td><td>1（默认）</td><td>No</td><td>最大空一行</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-14" id="描述-14">【描述】</a></h3>
<p>代码行之间，最小间隔 <code>0</code> 行，最大间隔<code>1</code>行。</p>
<h3><a class="header" href="#示例-8" id="示例-8">【示例】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    println!(&quot;a&quot;);
}
// 1
fn bar() {
    println!(&quot;b&quot;);
    println!(&quot;c&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>或者</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    println!(&quot;a&quot;);
}
fn bar() {
    println!(&quot;b&quot;);
	// 1
    println!(&quot;c&quot;);
}

<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    println!(&quot;a&quot;);
}
// 1
// 2
fn bar() {
    println!(&quot;b&quot;);
// 1
// 2
    println!(&quot;c&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gfmt05-语言项item-定义时花括号brace位置应该与语言项保持同一行" id="gfmt05-语言项item-定义时花括号brace位置应该与语言项保持同一行">G.FMT.05 语言项（Item) 定义时花括号（brace）位置应该与语言项保持同一行</a></h2>
<h3><a class="header" href="#级别建议-5" id="级别建议-5">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-3" id="rustfmt-配置-3">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#brace_style"><code>brace_style</code></a></td><td>SameLineWhere （默认）</td><td>No</td><td>应该与语言项保持同一行，但是 where 语句例外</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#brace_style"><code>brace_style</code></a></td><td>AlwaysNextLine</td><td>No</td><td>应该在语言项的下一行</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#brace_style"><code>brace_style</code></a></td><td>PreferSameLine</td><td>No</td><td>总是优先与语言项保持同一行，where 语句也不例外</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#where_single_line"><code>where_single_line</code></a></td><td>false（默认）</td><td>No</td><td>强制将 <code>where</code> 子句放在同一行上</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#AlwaysSameLine"><code>brace_style</code> in control-flow</a></td><td>AlwaysSameLine （默认）</td><td>No</td><td>总在同一行上，用于控制流程中默认值</td></tr>
<tr><td>[<a href="https://rust-lang.github.io/rustfmt/?#ClosingNextLine"><code>brace_style</code> in control-flow</a></td><td>ClosingNextLine</td><td>No</td><td>用于控制流程中 else 分支在 if 分支结尾处换行</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-15" id="描述-15">【描述】</a></h3>
<p>花括号的位置风格默认使用 <code>SameLineWhere</code>，但是也根据不同的语言项略有区别。</p>
<h3><a class="header" href="#示例-9" id="示例-9">【示例】</a></h3>
<h4><a class="header" href="#函数" id="函数">函数</a></h4>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn lorem() { // 花括号和fn定义在同一行
    // body
}

fn lorem(ipsum: usize) { // 花括号和fn定义在同一行
    // body
}

// 当有 `where` 子句的时候，花括号换行
// 并且，`where` 子句和 `where` 关键字不在同一行
fn lorem&lt;T&gt;(ipsum: T)
where
    T: Add + Sub + Mul + Div,
{
    // body
}
<span class="boring">}
</span></code></pre></pre>
<p>通过配置 <code>where_single_line</code> 为 true，方可设置 <code>where</code>子句在同一行，如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 当有 `where` 子句的时候，花括号换行
// 设置了 `where_single_line=true` ，则`where` 子句和 `where` 关键字在同一行
fn lorem&lt;T&gt;(ipsum: T)
where T: Add + Sub + Mul + Div,
{
    // body
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<p>如果设置 <code>brace_style = &quot;AlwaysNextLine&quot;</code>，则：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn lorem()
{
    // body
}

fn lorem(ipsum: usize)
{
    // body
}

fn lorem&lt;T&gt;(ipsum: T)
where
    T: Add + Sub + Mul + Div,
{
    // body
}
<span class="boring">}
</span></code></pre></pre>
<p>如果设置 <code>brace_style = &quot;PreferSameLine&quot;</code>，则：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn lorem() {
    // body
}

fn lorem(ipsum: usize) {
    // body
}

fn lorem&lt;T&gt;(ipsum: T)
where
    T: Add + Sub + Mul + Div, { // 注意这里和 `SameLineWhere`的区别
    // body
}
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#结构体与枚举" id="结构体与枚举">结构体与枚举</a></h4>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Lorem {
    ipsum: bool,
}

struct Dolor&lt;T&gt;
where
    T: Eq,
{
    sit: T,
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<p>如果设置 <code>brace_style = &quot;AlwaysNextLine&quot;</code>，则：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Lorem
{
    ipsum: bool,
}

struct Dolor&lt;T&gt;
where
    T: Eq,
{
    sit: T,
}
<span class="boring">}
</span></code></pre></pre>
<p>如果设置 <code>brace_style = &quot;PreferSameLine&quot;</code>，则：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Lorem {
    ipsum: bool,
}

struct Dolor&lt;T&gt;
where
    T: Eq, {
    sit: T,
}
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#流程控制" id="流程控制">流程控制</a></h4>
<p>流程控制倾向于默认使用 <code>AlwaysSameLine</code>，即，总在同一行。因为流程控制没有<code>where</code>子句。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">// &quot;AlwaysSameLine&quot; (default)
fn main() {
    if lorem {
        println!(&quot;ipsum!&quot;);
    } else {
        println!(&quot;dolor!&quot;);
    }
}
</code></pre></pre>
<p>【反例】</p>
<p>如果设置 <code>brace_style = &quot;AlwaysNextLine&quot;</code>，则：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    if lorem
    {
        println!(&quot;ipsum!&quot;);
    }
    else
    {
        println!(&quot;dolor!&quot;);
    }
}
</code></pre></pre>
<p>如果设置 <code>brace_style = &quot;ClosingNextLine&quot;</code>，则：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    if lorem {
        println!(&quot;ipsum!&quot;);
    } // 注意这里 if 分支结尾处，else 换行
    else { 
        println!(&quot;dolor!&quot;);
    }
}
</code></pre></pre>
<h2><a class="header" href="#gfmt06-单行规则" id="gfmt06-单行规则">G.FMT.06 单行规则</a></h2>
<h3><a class="header" href="#级别建议-6" id="级别建议-6">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-4" id="rustfmt-配置-4">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>默认值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#empty_item_single_line"><code>empty_item_single_line</code></a></td><td>true（默认）</td><td>No</td><td>当语言项内容为空时，要保持单行</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#empty_item_single_line"><code>fn_single_line</code></a></td><td>false（默认）</td><td>No</td><td>当函数中只有一个表达式时不要保持单行</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#struct_lit_single_line"><code>struct_lit_single_line</code></a></td><td>true（默认）</td><td>No</td><td>当函数中只有一个表达式时不要保持单行</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-16" id="描述-16">【描述】</a></h3>
<p>当语言项内容为空时，即空函数，空结构体，空实现等，要保持单独一行。但是，当函数中只有一个表达式时，请不要保持单行。</p>
<h3><a class="header" href="#示例-10" id="示例-10">【示例】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">fn lorem() {}

impl Lorem {}

fn lorem() -&gt; usize {
    42
}

fn main() {
    let lorem = Lorem { foo: bar, baz: ofo };
}

</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">fn lorem() {
}

impl Lorem {
}

fn lorem() -&gt; usize { 42 }

fn main() {
    let lorem = Lorem {
        foo: bar,
        baz: ofo,
    };
}
</code></pre></pre>
<h2><a class="header" href="#gfmt07-存在多个标识符时应该保持块状block缩进" id="gfmt07-存在多个标识符时应该保持块状block缩进">G.FMT.07 存在多个标识符时应该保持块状（Block）缩进</a></h2>
<h3><a class="header" href="#级别建议-7" id="级别建议-7">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-5" id="rustfmt-配置-5">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#indent_style"><code>indent_style</code></a></td><td>Block（默认）</td><td>No</td><td>多个标识符定义保持块状风格，但看上去可能不太工整</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#indent_style"><code>indent_style</code></a></td><td>Visual</td><td>No</td><td>多个标识符定义保持对齐风格，为了看上去工整</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-17" id="描述-17">【描述】</a></h3>
<p>当在表达式或语言项定义中出现多个标识符，则应该让其保持块状风格缩进。</p>
<h3><a class="header" href="#示例-11" id="示例-11">【示例】</a></h3>
<h4><a class="header" href="#数组" id="数组">数组</a></h4>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let lorem = vec![
        &quot;ipsum&quot;,
        &quot;dolor&quot;,
        &quot;sit&quot;,
        &quot;amet&quot;,
        &quot;consectetur&quot;,
        &quot;adipiscing&quot;,
        &quot;elit&quot;,
    ];
}
</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let lorem = vec![&quot;ipsum&quot;,
                     &quot;dolor&quot;,
                     &quot;sit&quot;,
                     &quot;amet&quot;,
                     &quot;consectetur&quot;,
                     &quot;adipiscing&quot;,
                     &quot;elit&quot;];
}
</code></pre></pre>
<h4><a class="header" href="#流程控制-1" id="流程控制-1">流程控制</a></h4>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    if lorem_ipsum
        &amp;&amp; dolor_sit
        &amp;&amp; amet_consectetur
        &amp;&amp; lorem_sit
        &amp;&amp; dolor_consectetur
        &amp;&amp; amet_ipsum
        &amp;&amp; lorem_consectetur
    {
        // ...
    }
}
</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    if lorem_ipsum
       &amp;&amp; dolor_sit // 注意：这里缩进只是三个空格，仅仅是和前一行 `lorem_ipsum`对齐
       &amp;&amp; amet_consectetur
       &amp;&amp; lorem_sit
       &amp;&amp; dolor_consectetur
       &amp;&amp; amet_ipsum
       &amp;&amp; lorem_consectetur
    {
        // ...
    }
}
</code></pre></pre>
<h4><a class="header" href="#函数参数" id="函数参数">函数参数</a></h4>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn lorem() {}

fn lorem(ipsum: usize) {}

fn lorem(
    ipsum: usize,
    dolor: usize,
    sit: usize,
    amet: usize,
    consectetur: usize,
    adipiscing: usize,
    elit: usize,
) {
    // body
}

<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn lorem() {}

fn lorem(ipsum: usize) {}

fn lorem(ipsum: usize,
         dolor: usize,
         sit: usize,
         amet: usize,
         consectetur: usize,
         adipiscing: usize,
         elit: usize) {
    // body
}
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#函数调用" id="函数调用">函数调用</a></h4>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    lorem(
        &quot;lorem&quot;,
        &quot;ipsum&quot;,
        &quot;dolor&quot;,
        &quot;sit&quot;,
        &quot;amet&quot;,
        &quot;consectetur&quot;,
        &quot;adipiscing&quot;,
        &quot;elit&quot;,
    );
}
</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    lorem(&quot;lorem&quot;,
          &quot;ipsum&quot;,
          &quot;dolor&quot;,
          &quot;sit&quot;,
          &quot;amet&quot;,
          &quot;consectetur&quot;,
          &quot;adipiscing&quot;,
          &quot;elit&quot;);
}
</code></pre></pre>
<h4><a class="header" href="#泛型" id="泛型">泛型</a></h4>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn lorem&lt;
    Ipsum: Eq = usize,
    Dolor: Eq = usize,
    Sit: Eq = usize,
    Amet: Eq = usize,
    Adipiscing: Eq = usize,
    Consectetur: Eq = usize,
    Elit: Eq = usize,
&gt;(
    ipsum: Ipsum,
    dolor: Dolor,
    sit: Sit,
    amet: Amet,
    adipiscing: Adipiscing,
    consectetur: Consectetur,
    elit: Elit,
) -&gt; T {
    // body
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn lorem&lt;Ipsum: Eq = usize,
         Dolor: Eq = usize,
         Sit: Eq = usize,
         Amet: Eq = usize,
         Adipiscing: Eq = usize,
         Consectetur: Eq = usize,
         Elit: Eq = usize&gt;(
    ipsum: Ipsum,
    dolor: Dolor,
    sit: Sit,
    amet: Amet,
    adipiscing: Adipiscing,
    consectetur: Consectetur,
    elit: Elit)
    -&gt; T {
    // body
}
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#结构体" id="结构体">结构体</a></h4>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let lorem = Lorem {
        ipsum: dolor,
        sit: amet,
    };
}
</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let lorem = Lorem { ipsum: dolor,
                        sit: amet };
}
</code></pre></pre>
<h2><a class="header" href="#gfmt08-换行样式以文件自动检测为主" id="gfmt08-换行样式以文件自动检测为主">G.FMT.08 换行样式以文件自动检测为主</a></h2>
<h3><a class="header" href="#级别建议-8" id="级别建议-8">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-6" id="rustfmt-配置-6">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#newline_style"><code>newline_style</code></a></td><td>Auto（默认）</td><td>Yes</td><td>换行样式以文件自动检测为主</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-18" id="描述-18">【描述】</a></h3>
<p>换行样式是基于每个文件自动检测的。 具有混合行尾的文件将转换为第一个检测到的行尾样式。</p>
<p>不同平台换行符不同：</p>
<ul>
<li><code>Windows</code> 以 <code>\r\n</code>结尾。</li>
<li><code>Unix</code> 以 <code>\n</code> 结尾。</li>
</ul>
<h2><a class="header" href="#gfmt09-当有多行表达式操作时操作符应该置于行首" id="gfmt09-当有多行表达式操作时操作符应该置于行首">G.FMT.09 当有多行表达式操作时，操作符应该置于行首</a></h2>
<h3><a class="header" href="#级别建议-9" id="级别建议-9">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-7" id="rustfmt-配置-7">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#binop_separator"><code>binop_separator</code></a></td><td>Front（默认）</td><td>No</td><td>换行后，操作符置于行首</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-19" id="描述-19">【描述】</a></h3>
<p>当有多行表达式操作时，操作符应该置于行首。</p>
<h3><a class="header" href="#示例-12" id="示例-12">【示例】</a></h3>
<p>【正例】</p>
<p>操作符置于行首</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let or = foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoo
        || barbarbarbarbarbarbarbarbarbarbarbarbarbarbarbar;

    let sum = 123456789012345678901234567890
        + 123456789012345678901234567890
        + 123456789012345678901234567890;

    let range = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
        ..bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb;
}
</code></pre></pre>
<p>【反例】</p>
<p>操作符置于行尾</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let or = foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoo ||
        barbarbarbarbarbarbarbarbarbarbarbarbarbarbarbar;

    let sum = 123456789012345678901234567890 +
        123456789012345678901234567890 +
        123456789012345678901234567890;

    let range = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa..
        bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb;
}
</code></pre></pre>
<h2><a class="header" href="#gfmt10-枚举变体和结构体字段相互之间默认左对齐" id="gfmt10-枚举变体和结构体字段相互之间默认左对齐">G.FMT.10 枚举变体和结构体字段相互之间默认左对齐</a></h2>
<h3><a class="header" href="#级别建议-10" id="级别建议-10">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-8" id="rustfmt-配置-8">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#enum_discrim_align_threshold"><code>enum_discrim_align_threshold</code></a></td><td>0（默认）</td><td>No</td><td>具有判别式的枚举变体与其他变体进行垂直对齐的最大长度。没有判别符的变体在对齐时将被忽略。</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#struct_field_align_threshold"><code>struct_field_align_threshold</code></a></td><td>0（默认）</td><td>No</td><td>结构体字段垂直对齐的最大长度</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-20" id="描述-20">【描述】</a></h3>
<p>对于自定义了判别式的枚举体，和有字段的结构体而言，默认只需要左对齐就可以。这个宽度可以设置为任意值，但默认是0。此宽度并不是指插入多少空格，而是指需要对齐的字符长度。</p>
<h3><a class="header" href="#示例-13" id="示例-13">【示例】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>enum Bar {
    A = 0,
    Bb = 1,
    RandomLongVariantGoesHere = 10,
    Ccc = 71,
}

enum Bar {
    VeryLongVariantNameHereA = 0,
    VeryLongVariantNameHereBb = 1,
    VeryLongVariantNameHereCcc = 2,
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<p>当 <code>enum_discrim_align_threshold = 20</code> 时。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Foo {
    A   = 0,
    Bb  = 1,
    RandomLongVariantGoesHere = 10, // 注意，该变体长度已经超过了20，所以它不会被对齐
    Ccc = 2,
}

enum Bar {
    VeryLongVariantNameHereA = 0, // 注意，该变体长度已经超过了20，所以它不会被对齐
    VeryLongVariantNameHereBb = 1, // 注意，该变体长度已经超过了20，所以它不会被对齐
    VeryLongVariantNameHereCcc = 2,// 注意，该变体长度已经超过了20，所以它不会被对齐
}
<span class="boring">}
</span></code></pre></pre>
<p>当 <code>enum_discrim_align_threshold = 50</code> 时。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>enum Foo {
    A                         = 0,
    Bb                        = 1,
    RandomLongVariantGoesHere = 10, // 注意，该变体长度未超过50，所以它会被对齐
    Ccc                       = 2,
}

enum Bar {
    VeryLongVariantNameHereA   = 0, // 注意，该变体长度未超过50，所以它会被对齐
    VeryLongVariantNameHereBb  = 1, // 注意，该变体长度未超过50，所以它会被对齐
    VeryLongVariantNameHereCcc = 2, // 注意，该变体长度未超过50，所以它会被对齐
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gfmt11-多个函数参数和导入模块的布局" id="gfmt11-多个函数参数和导入模块的布局">G.FMT.11 多个函数参数和导入模块的布局</a></h2>
<h3><a class="header" href="#级别建议-11" id="级别建议-11">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-9" id="rustfmt-配置-9">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#fn_args_layout"><code>fn_args_layout</code></a></td><td>Tall（默认）</td><td>Yes</td><td>函数参数五个或以内可以一行，超过五个则使用块状缩进</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#imports_layout"><code>imports_layout</code></a></td><td>Mixed（默认）</td><td>No</td><td>导入模块每行超过四个则换行</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-21" id="描述-21">【描述】</a></h3>
<ol>
<li>五个以内函数参数可以置于一行，超过五个则使用「块」状缩进。</li>
<li>导入模块每行超过四个，则换行。</li>
</ol>
<h3><a class="header" href="#示例-14" id="示例-14">【示例】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>trait Lorem {
    fn lorem(ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet, consectetur: Consectetur);

    fn lorem(ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet) {
        // body
    }

    fn lorem(
        ipsum: Ipsum,
        dolor: Dolor,
        sit: Sit,
        amet: Amet,
        consectetur: Consectetur,
        adipiscing: Adipiscing,
        elit: Elit,
    );

    fn lorem(
        ipsum: Ipsum,
        dolor: Dolor,
        sit: Sit,
        amet: Amet,
        consectetur: Consectetur,
        adipiscing: Adipiscing,
        elit: Elit,
    ) {
        // body
    }
}

use foo::{xxxxxxxxxxxxxxxxxx, yyyyyyyyyyyyyyyyyy, zzzzzzzzzzzzzzzzzz};

use foo::{
    aaaaaaaaaaaaaaaaaa, bbbbbbbbbbbbbbbbbb, cccccccccccccccccc, dddddddddddddddddd,
    eeeeeeeeeeeeeeeeee,
};
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<p>当 <code>fn_args_layout</code> 和 <code>imports_layout</code> 被设置为其他值时：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Lorem {
    fn lorem(ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet);

    fn lorem(ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet) {
        // body
    }

    fn lorem(
        ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet, consectetur: Consectetur,
        adipiscing: Adipiscing, elit: Elit,
    );

    fn lorem(
        ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet, consectetur: Consectetur,
        adipiscing: Adipiscing, elit: Elit,
    ) {
        // body
    }
}

use foo::{xxxxxxxxxxxxxxxxxx, yyyyyyyyyyyyyyyyyy, zzzzzzzzzzzzzzzzzz};

use foo::{
    aaaaaaaaaaaaaaaaaa,
    bbbbbbbbbbbbbbbbbb,
    cccccccccccccccccc,
    dddddddddddddddddd,
    eeeeeeeeeeeeeeeeee,
    ffffffffffffffffff,
};

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gfmt12--空格使用规则" id="gfmt12--空格使用规则">G.FMT.12  空格使用规则</a></h2>
<h3><a class="header" href="#级别建议-12" id="级别建议-12">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-10" id="rustfmt-配置-10">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#space_after_colon"><code>space_after_colon</code></a></td><td>true（默认）</td><td>No</td><td>在冒号后面要加空格</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#space_before_colon"><code>space_before_colon</code></a></td><td>false（默认）</td><td>No</td><td>在冒号前面不要加空格</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#spaces_around_ranges"><code>spaces_around_ranges</code></a></td><td>false（默认）</td><td>No</td><td>在<code>..</code>和<code>..=</code>范围操作符前后不要加空格</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#type_punctuation_density"><code>type_punctuation_density</code></a></td><td>&quot;Wide&quot;（默认）</td><td>No</td><td>在 <code>+</code>或<code>=</code>操作符前后要加空格（此处特指类型签名）</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-22" id="描述-22">【描述】</a></h3>
<p>总结：</p>
<ol>
<li>在冒号之后添加空格，在冒号之前不要加空格。</li>
<li>在范围（range）操作符（<code>..</code>和<code>..=</code>）前后不要使用空格。</li>
<li>在<code>+</code>或<code>=</code>操作符前后要加空格。</li>
</ol>
<h3><a class="header" href="#示例-15" id="示例-15">【示例】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 当 `space_after_colon=true`
fn lorem&lt;T: Eq&gt;(t: T) {
    let lorem: Dolor = Lorem {
        ipsum: dolor,
        sit: amet,
    };
}

// 当 `space_before_colon=false`
fn lorem&lt;T: Eq&gt;(t: T) {
    let lorem: Dolor = Lorem {
        ipsum: dolor,
        sit: amet,
    };
}

// 当 `spaces_around_ranges=false`
let lorem = 0..10;
let ipsum = 0..=10;

// 当 `type_punctuation_density=&quot;Wide&quot;`
fn lorem&lt;Ipsum: Dolor + Sit = Amet&gt;() {
    // body
    let answer = 1 + 2;
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 当 `space_after_colon=false`
fn lorem&lt;T:Eq&gt;(t:T) {
    let lorem:Dolor = Lorem {
        ipsum:dolor,
        sit:amet,
    };
}

// 当 `space_before_colon=true`
fn lorem&lt;T : Eq&gt;(t : T) {
    let lorem : Dolor = Lorem {
        ipsum : dolor,
        sit : amet,
    };
}

// 当 `spaces_around_ranges=true`
let lorem = 0 .. 10;
let ipsum = 0 ..= 10;

// 当 `type_punctuation_density=&quot;Compressed&quot;`
fn lorem&lt;Ipsum: Dolor+Sit=Amet&gt;() {
    // body
    let answer = 1 + 2;
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gfmt13--结尾逗号规则" id="gfmt13--结尾逗号规则">G.FMT.13  结尾逗号规则</a></h2>
<h3><a class="header" href="#级别建议-13" id="级别建议-13">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-11" id="rustfmt-配置-11">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#trailing_comma"><code>trailing_comma</code></a></td><td>&quot;Vertical&quot;（默认）</td><td>No</td><td>当多个字段在不同行时，在最后一个字段结尾添加逗号，如果在同一行，则不加逗号</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#match_block_trailing_comma"><code>match_block_trailing_comma</code></a></td><td>false（默认）</td><td>No</td><td>在match分支中，如果包含了块，则不需要加逗号，否则需要加</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-23" id="描述-23">【描述】</a></h3>
<ol>
<li>当多个字段在不同行时，在最后一个字段结尾添加逗号，如果在同一行，则不加逗号。</li>
<li>在match分支中，如果包含了块，则不需要加逗号，否则需要加。</li>
</ol>
<h3><a class="header" href="#示例-16" id="示例-16">【示例】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">// 当 `trailing_comma=&quot;Vertical&quot;`
fn main() {
    let Lorem { ipsum, dolor, sit } = amet;
    let Lorem {
        ipsum,
        dolor,
        sit,
        amet,
        consectetur,
        adipiscing,
    } = elit;
}

// 当 `match_block_trailing_comma=false`
fn main() {
    match lorem {
        Lorem::Ipsum =&gt; {
            println!(&quot;ipsum&quot;);
        }
        Lorem::Dolor =&gt; println!(&quot;dolor&quot;),
    }
}

</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">// 当 `trailing_comma=&quot;Always&quot;`
fn main() {
    let Lorem { ipsum, dolor, sit, } = amet;
    let Lorem {
        ipsum,
        dolor,
        sit,
        amet,
        consectetur,
        adipiscing,
    } = elit;
}

// 当 `trailing_comma=&quot;Never&quot;`
fn main() {
    let Lorem { ipsum, dolor, sit } = amet;
    let Lorem {
        ipsum,
        dolor,
        sit,
        amet,
        consectetur,
        adipiscing
    } = elit;
}

// 当 `match_block_trailing_comma=true`
fn main() {
    match lorem {
        Lorem::Ipsum =&gt; {
            println!(&quot;ipsum&quot;);
        },
        Lorem::Dolor =&gt; println!(&quot;dolor&quot;),
    }
}

</code></pre></pre>
<h2><a class="header" href="#gfmt14--match-分支格式" id="gfmt14--match-分支格式">G.FMT.14  <code>match</code> 分支格式</a></h2>
<h3><a class="header" href="#级别建议-14" id="级别建议-14">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-12" id="rustfmt-配置-12">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#match_arm_blocks"><code>match_arm_blocks</code></a></td><td>true（默认）</td><td>No</td><td>当match分支右侧代码体太长无法和<code>=&gt;</code>置于同一行需要使用块(block)来包裹</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#match_arm_leading_pipes"><code>match_arm_leading_pipes</code></a></td><td>Never（默认）</td><td>No</td><td>在match分支左侧匹配表达式前不要增加管道符(`</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-24" id="描述-24">【描述】</a></h3>
<ol>
<li>当match分支右侧代码体太长无法和<code>=&gt;</code>置于同一行需要使用块(block)来包裹。</li>
<li>在match分支左侧匹配表达式前不要增加管道符(<code>|</code>)</li>
</ol>
<h3><a class="header" href="#示例-17" id="示例-17">【示例】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">// 当 `match_arm_blocks=true`
fn main() {
    match lorem {
        ipsum =&gt; { 
            foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo(x)
        }
        dolor =&gt; println!(&quot;{}&quot;, sit),
        sit =&gt; foo(
            &quot;foooooooooooooooooooooooo&quot;,
            &quot;baaaaaaaaaaaaaaaaaaaaaaaarr&quot;,
            &quot;baaaaaaaaaaaaaaaaaaaazzzzzzzzzzzzz&quot;,
            &quot;qqqqqqqqquuuuuuuuuuuuuuuuuuuuuuuuuuxxx&quot;,
        ),
    }
}

// 当 `match_arm_leading_pipes=&quot;Never&quot;`
fn foo() {
    match foo {
        &quot;foo&quot; | &quot;bar&quot; =&gt; {}
        &quot;baz&quot;
        | &quot;something relatively long&quot;
        | &quot;something really really really realllllllllllllly long&quot; =&gt; println!(&quot;x&quot;),
        &quot;qux&quot; =&gt; println!(&quot;y&quot;),
        _ =&gt; {}
    }
}



</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">// 当 `match_arm_blocks=false`
fn main() {
    match lorem {
        ipsum =&gt; 
            foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo(x),
        dolor =&gt; println!(&quot;{}&quot;, sit),
        sit =&gt; foo(
            &quot;foooooooooooooooooooooooo&quot;,
            &quot;baaaaaaaaaaaaaaaaaaaaaaaarr&quot;,
            &quot;baaaaaaaaaaaaaaaaaaaazzzzzzzzzzzzz&quot;,
            &quot;qqqqqqqqquuuuuuuuuuuuuuuuuuuuuuuuuuxxx&quot;,
        ),
    }
}

// 当 `match_arm_leading_pipes=&quot;Alaways&quot;`
fn foo() {
    match foo {
        | &quot;foo&quot; | &quot;bar&quot; =&gt; {}
        | &quot;baz&quot;
        | &quot;something relatively long&quot;
        | &quot;something really really really realllllllllllllly long&quot; =&gt; println!(&quot;x&quot;),
        | &quot;qux&quot; =&gt; println!(&quot;y&quot;),
        | _ =&gt; {}
    }
}

</code></pre></pre>
<h2><a class="header" href="#gfmt15--导入模块分组规则" id="gfmt15--导入模块分组规则">G.FMT.15  导入模块分组规则</a></h2>
<h3><a class="header" href="#级别建议-15" id="级别建议-15">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-13" id="rustfmt-配置-13">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#imports_granularity"><code>imports_granularity</code></a></td><td>（Preserve（默认），Crate(推荐)）</td><td>No</td><td>默认保留开发者的模块导入顺序</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#reorder_imports"><code>reorder_imports</code></a></td><td>true（默认）</td><td>No</td><td>模块分组内根据模块首字母按字典序进行排序</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#group_imports"><code>group_imports</code></a></td><td>（Preserve（默认）， StdExternalCrate（建议））</td><td>No</td><td>默认保留开发者的模块导入分组</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-25" id="描述-25">【描述】</a></h3>
<ol>
<li>导入同一模块的类型，应该置于同一个块内（<code>imports_granularity=&quot;Crate&quot;</code>）。</li>
<li>模块导入应该按以下规则进行分组（<code>group_imports=&quot;StdExternalCrate&quot;</code>）：
<ul>
<li>导入来自 <code>std</code>、<code>core</code> 和 <code>alloc</code>的模块需要置于前面一组。</li>
<li>导入来自 第三方库的模块 应该置于中间一组。</li>
<li>导入来自本地 <code>self</code>、<code>super</code>和<code>crate</code>前缀的模块，置于后面一组。</li>
</ul>
</li>
<li>分组内使用字典序进行排序（<code>reorder_imports=true</code>）。</li>
</ol>
<p>说明： 默认 rustfmt 不会对导入的模块自动分组，而是保留开发者的导入顺序。所以，这里需要修改rustfmt 默认配置，但因为这几个配置项暂时未稳定，所以需要在 Nightly 下使用。</p>
<h3><a class="header" href="#示例-18" id="示例-18">【示例】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 当 `imports_granularity=&quot;Crate&quot;`
use foo::{
    a, b,
    b::{f, g},
    c,
    d::e,
};
use qux::{h, i};


// 当 `group_imports=&quot;StdExternalCrate` 且 `reorder_imports=true`
use alloc::alloc::Layout;
use core::f32;
use std::sync::Arc;

use broker::database::PooledConnection;
use chrono::Utc;
use juniper::{FieldError, FieldResult};
use uuid::Uuid;

use super::schema::{Context, Payload};
use super::update::convert_publish_payload;
use crate::models::Event;
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>// 当 `imports_granularity=&quot;Preserve&quot;`
use foo::b;
use foo::b::{f, g};
use foo::{a, c, d::e};
use qux::{h, i};


// 当按默认值设置时，模块导入比较乱，影响可读性
use super::update::convert_publish_payload;
use chrono::Utc;

use alloc::alloc::Layout;
use juniper::{FieldError, FieldResult};
use uuid::Uuid;

use std::sync::Arc;

use broker::database::PooledConnection;

use super::schema::{Context, Payload};
use crate::models::Event;
use core::f32;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gfmt16--声明宏分支格式" id="gfmt16--声明宏分支格式">G.FMT.16  声明宏分支格式</a></h2>
<h3><a class="header" href="#级别建议-16" id="级别建议-16">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-14" id="rustfmt-配置-14">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#format_macro_matchers"><code>format_macro_matchers</code></a></td><td>（false（默认），true(建议)）</td><td>No</td><td>声明宏 模式匹配分支（<code>=&gt;</code> 左侧）中要使用紧凑格式</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#format_macro_bodies"><code>format_macro_bodies</code></a></td><td>true（默认）</td><td>No</td><td>声明宏分支代码体（<code>=&gt;</code> 右侧） 使用宽松格式</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-26" id="描述-26">【描述】</a></h3>
<ol>
<li>在声明宏中，模式匹配分支（<code>=&gt;</code> 左侧）应该使用紧凑格式（<code>format_macro_matchers=true</code>）。</li>
<li>而分支代码体（<code>=&gt;</code> 右侧） 使用宽松格式。详细请看示例。</li>
</ol>
<p>一切都是为了提升可读性。</p>
<p>说明：因为这里需要修改<code>format_macro_matchers</code>的默认值，且该配置项并未 Stable ，所以需要 Nightly 下格式化。</p>
<h3><a class="header" href="#示例-19" id="示例-19">【示例】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 当 `format_macro_matchers=true` 且 `format_macro_bodies=true`
macro_rules! foo {
    // 匹配分支紧凑格式， `$a:ident` 和 `$b:ty` 各自配对
    ($a:ident : $b:ty) =&gt; {
        $a(42): $b; // 在代码体内，则宽松一点
    };
    ($a:ident $b:ident $c:ident) =&gt; {
        $a = $b + $c;
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 当 `format_macro_matchers=false`且 `format_macro_bodies=true`
macro_rules! foo {
    ($a: ident : $b: ty) =&gt; {
        $a(42): $b;
    };
    ($a: ident $b: ident $c: ident) =&gt; {
        $a = $b + $c;
    };
}

// 当 `format_macro_matchers=false`且 `format_macro_bodies=false`
macro_rules! foo {
    ($a: ident : $b: ty) =&gt; {
        $a(42):$b;
    };
    ($a: ident $b: ident $c: ident) =&gt; {
        $a=$b+$c;
    };
}

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gfmt17--具名结构体字段初始化不要省略字段名" id="gfmt17--具名结构体字段初始化不要省略字段名">G.FMT.17  具名结构体字段初始化不要省略字段名</a></h2>
<h3><a class="header" href="#级别建议-17" id="级别建议-17">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-15" id="rustfmt-配置-15">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#use_field_init_shorthand"><code>use_field_init_shorthand</code></a></td><td>false（默认）</td><td>Yes</td><td>具名结构体字段初始化不能省略字段名</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-27" id="描述-27">【描述】</a></h3>
<p>具名结构体字段初始化不能省略字段名。</p>
<h3><a class="header" href="#示例-20" id="示例-20">【示例】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
struct Foo {
    x: u32,
    y: u32,
    z: u32,
}

fn main() {
    let x = 1;
    let y = 2;
    let z = 3;
    let a = Foo { x: x, y: y, z: z };
}
</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">struct Foo {
    x: u32,
    y: u32,
    z: u32,
}

fn main() {
    let x = 1;
    let y = 2;
    let z = 3;
    let a = Foo { x, y, z };
}
</code></pre></pre>
<h2><a class="header" href="#gfmt18--extern-外部函数需要指定-abi" id="gfmt18--extern-外部函数需要指定-abi">G.FMT.18  extern 外部函数需要指定 ABI</a></h2>
<h3><a class="header" href="#级别建议-18" id="级别建议-18">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-16" id="rustfmt-配置-16">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#force_explicit_abi"><code>force_explicit_abi</code></a></td><td>true（默认）</td><td>Yes</td><td>extern 外部函数总是要指定 ABI</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-28" id="描述-28">【描述】</a></h3>
<p>当使用 <code>extern</code> 指定外部函数时，建议显式指定 <code>C-ABI</code>。<code>extern</code> 不指定的话默认就是 <code>C-ABI</code>，但是 Rust 语言显式指定是一种约定俗成。如果是 <code>Rust-ABI</code>则不会省略。</p>
<h3><a class="header" href="#示例-21" id="示例-21">【示例】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;C&quot; {
    pub static lorem: c_int;
}

extern &quot;Rust&quot; {
    type MyType;
    fn f(&amp;self) -&gt; usize;
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 省略 ABI 指定，则默认是 C-ABI
extern {
    pub static lorem: c_int;
}

// 非 C-ABI 是无法省略的
extern &quot;Rust&quot; {
    type MyType;
    fn f(&amp;self) -&gt; usize;
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gfmt19---解构元组的时候允许使用来指代剩余元素" id="gfmt19---解构元组的时候允许使用来指代剩余元素">G.FMT.19   解构元组的时候允许使用<code>..</code>来指代剩余元素</a></h2>
<h3><a class="header" href="#级别建议-19" id="级别建议-19">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-17" id="rustfmt-配置-17">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#condense_wildcard_suffixes"><code>condense_wildcard_suffixes</code></a></td><td>false（默认） true （推荐）</td><td>No</td><td>解构元组的时候是否允许使用<code>..</code>来指代剩余元素</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-29" id="描述-29">【描述】</a></h3>
<p>默认选项是 false，表示不允许 解构元组的时候使用<code>..</code>来指代剩余元素</p>
<h3><a class="header" href="#示例-22" id="示例-22">【示例】</a></h3>
<p>【正例】</p>
<p>设置 <code>condense_wildcard_suffixes = true</code> :</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let (lorem, ipsum, ..) = (1, 2, 3, 4);
}
</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let (lorem, ipsum, _, _) = (1, 2, 3, 4);
    let (lorem, ipsum, ..) = (1, 2, 3, 4);
}
</code></pre></pre>
<h2><a class="header" href="#gfmt20----不要将多个-derive-宏合并为同一行" id="gfmt20----不要将多个-derive-宏合并为同一行">G.FMT.20    不要将多个 Derive 宏合并为同一行</a></h2>
<h3><a class="header" href="#级别建议-20" id="级别建议-20">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-18" id="rustfmt-配置-18">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#merge_derives"><code>merge_derives</code></a></td><td>true（默认） false（推荐）</td><td>Yes</td><td>是否将多个 Derive 宏合并为同一行</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-30" id="描述-30">【描述】</a></h3>
<p>不要将多个 Derive 宏合并为同一行，可以增加代码可读性，明确语义。</p>
<h3><a class="header" href="#示例-23" id="示例-23">【示例】</a></h3>
<p>【正例】</p>
<p>修改默认设置 <code>merge_derives = false</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Eq, PartialEq)]
#[derive(Debug)]
#[derive(Copy, Clone)]
pub enum Foo {}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<p>用默认设置  <code>merge_derives = true</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Eq, PartialEq, Debug, Copy, Clone)]
pub enum Foo {}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#注释与文档" id="注释与文档">注释与文档</a></h1>
<p>在 Rust 中，注释分为两类：普通注释和文档注释。普通注释使用 <code>//</code> 或 <code>/* ... */</code>，文档注释使用 <code>///</code>、<code>//!</code> 或 <code>/** ... **/</code>。</p>
<p>在原则和规则中提到「注释」时，包括普通注释和文档注释。当提到「文档」时，特指文档注释。</p>
<hr />
<h2><a class="header" href="#pcmt01-不到必要的时候不要添加注释" id="pcmt01-不到必要的时候不要添加注释">P.CMT.01 不到必要的时候不要添加注释</a></h2>
<h3><a class="header" href="#描述-31" id="描述-31">【描述】</a></h3>
<p>注释固然很重要, 但最好的代码应当本身就是文档。有意义的类型名、函数名和变量名, 要远胜过要用注释解释的含糊不清的名字。当有意义的类型名、函数名和变量名还不能表达完整的语义时，再使用注释。</p>
<p>不要描述显而易见的现象, 永远不要用自然语言翻译代码作为注释。</p>
<h2><a class="header" href="#pcmt02-文档应该始终基于-rustdoc-工具来构建" id="pcmt02-文档应该始终基于-rustdoc-工具来构建">P.CMT.02 文档应该始终基于 <code>rustdoc</code> 工具来构建</a></h2>
<h3><a class="header" href="#描述-32" id="描述-32">【描述】</a></h3>
<p>Rust 语言提供 <code>rustdoc</code> 工具来帮助构建文档，所以应该始终围绕<code>rustdoc</code>工具的特性来构建项目文档。</p>
<h2><a class="header" href="#pcmt03-文档应该围绕-what-和-how-为核心来构建" id="pcmt03-文档应该围绕-what-和-how-为核心来构建">P.CMT.03 文档应该围绕 What 和 How 为核心来构建</a></h2>
<h3><a class="header" href="#描述-33" id="描述-33">【描述】</a></h3>
<p>文档应该始终围绕两个方向来构建：</p>
<ol>
<li>What : 用于阐述代码为什么而构建。</li>
<li>how : 用于阐述代码如何去使用。</li>
</ol>
<h2><a class="header" href="#pcmt04-注释和文档应该保持简短精干" id="pcmt04-注释和文档应该保持简短精干">P.CMT.04 注释和文档应该保持简短精干</a></h2>
<h3><a class="header" href="#描述-34" id="描述-34">【描述】</a></h3>
<ol>
<li>文档内容用语应该尽量简短精干，不宜篇幅过长。请确保你的代码注释良好并且易于他人理解。</li>
<li>使用通俗易懂的描述而尽量避免使用专业技术术语。好的注释能够传达上下文关系和代码目的。</li>
</ol>
<h2><a class="header" href="#pcmt05-注释和文档使用的自然语言要保持一致" id="pcmt05-注释和文档使用的自然语言要保持一致">P.CMT.05 注释和文档使用的自然语言要保持一致</a></h2>
<h3><a class="header" href="#描述-35" id="描述-35">【描述】</a></h3>
<p>注释和文档尽量使用英文来填写，如果要使用中文，整个项目必须都使用中文。请确保整个项目中文档和注释都使用同一种文本语言，保持一致性。</p>
<h2><a class="header" href="#pcmt06-在文档中应该使用-markdown-格式" id="pcmt06-在文档中应该使用-markdown-格式">P.CMT.06 在文档中应该使用 Markdown 格式</a></h2>
<h3><a class="header" href="#描述-36" id="描述-36">【描述】</a></h3>
<p>Rust 文档注释支持 Markdown ，所以在编写文档注释的时候，应该使用 Markdown 格式。</p>
<h3><a class="header" href="#示例-24" id="示例-24">【示例】</a></h3>
<p>模块级文档，来自于 Rust 标准库<code>std::vec</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! # The Rust core allocation and collections library
//!
//! This library provides smart pointers and collections for managing
//! heap-allocated values.
//!
//! This library, like libcore, normally doesn’t need to be used directly
//! since its contents are re-exported in the [`std` crate](../std/index.html).
//! Crates that use the `#![no_std]` attribute however will typically
//! not depend on `std`, so they’d use this crate instead.
//!
//! ## Boxed values
//!
//! The [`Box`] type is a smart pointer type. There can only be one owner of a
//! [`Box`], and the owner can decide to mutate the contents, which live on the
//! heap.
<span class="boring">}
</span></code></pre></pre>
<p>普通文档注释示例，来自标准库<code>Vec::new</code>方法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Constructs a new, empty `Vec&lt;T&gt;`.
    ///
    /// The vector will not allocate until elements are pushed onto it.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![allow(unused_mut)]
    /// let mut vec: Vec&lt;i32&gt; = Vec::new();
    /// ```
    #[inline]
    #[rustc_const_stable(feature = &quot;const_vec_new&quot;, since = &quot;1.39.0&quot;)]
    #[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
    pub const fn new() -&gt; Self {
        Vec { buf: RawVec::NEW, len: 0 }
    }
<span class="boring">}
</span></code></pre></pre>
<hr />
<h2><a class="header" href="#gcmt01-注释应该有一定宽度限制" id="gcmt01-注释应该有一定宽度限制">G.CMT.01 注释应该有一定宽度限制</a></h2>
<h3><a class="header" href="#级别建议-21" id="级别建议-21">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-19" id="rustfmt-配置-19">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#comment_width"><code>comment_width</code></a></td><td>80（默认）</td><td>No</td><td>指定一行注释允许的最大宽度</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#wrap_comments"><code>wrap_comments</code></a></td><td>false（默认），true（建议）</td><td>No</td><td>运行多行注释按最大宽度自动换成多行注释</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-37" id="描述-37">【描述】</a></h3>
<p>每行注释的宽度不能过长，需要设置一定的宽度，有助于提升可读性。<code>comment_width</code>可配合 <code>wrap_comments</code> 将超过宽度限制的注释自动分割为多行。</p>
<p>注意：<code>use_small_heuristics</code>配置项并不包括<code>comment_width</code>。</p>
<h3><a class="header" href="#示例-25" id="示例-25">【示例】</a></h3>
<p>【正例】</p>
<p>当 <code>comment_width=80</code> 且 <code>wrap_comments=true</code>时。</p>
<p>注意：这里 <code>wrap_comments</code>并未使用默认值，需要配置为 true。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Lorem ipsum dolor sit amet, consectetur adipiscing elit,
// sed do eiusmod tempor incididunt ut labore et dolore
// magna aliqua. Ut enim ad minim veniam, quis nostrud
// exercitation ullamco laboris nisi ut aliquip ex ea
// commodo consequat.
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gcmt02-使用行注释而避免使用块注释" id="gcmt02-使用行注释而避免使用块注释">G.CMT.02 使用行注释而避免使用块注释</a></h2>
<h3><a class="header" href="#级别建议-22" id="级别建议-22">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-20" id="rustfmt-配置-20">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#normalize_comments"><code>normalize_comments</code></a></td><td>false（默认） true（推荐）</td><td>No</td><td>将 <code>/**/</code> 注释转为 <code>//</code></td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#normalize_doc_attributes"><code>normalize_doc_attributes</code></a></td><td>false（默认）</td><td>No</td><td>将 <code>#![doc]</code> 和 <code>#[doc]</code> 注释转为 <code>//!</code> 和 <code>///</code></td></tr>
</tbody></table>
<h3><a class="header" href="#描述-38" id="描述-38">【描述】</a></h3>
<p>尽量使用行注释（<code>//</code> 或 <code>///</code>），而非块注释。</p>
<p>对于文档注释，仅在编写模块级文档时使用 <code>//!</code>，在其他情况使用 <code>///</code>更好。</p>
<h3><a class="header" href="#示例-26" id="示例-26">【示例】</a></h3>
<p>【正例】</p>
<p>当 <code>normalize_comments = true</code>  时：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Wait for the main task to return, and set the process error code
// appropriately.

// 在使用 `mod` 关键字定义模块时，在 `mod`之上使用 `///` 更好。
/// This module contains tests
mod tests {
    // ...
}

//! Example documentation

/// Example item documentation
pub enum Foo {}

<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/*
 * Wait for the main task to return, and set the process error code
 * appropriately.
 */

mod tests {
    //! This module contains tests

    // ...
}

#![doc = &quot;Example documentation&quot;]

#[doc = &quot;Example item documentation&quot;]
pub enum Foo {}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gcmt03-在每一个文件开头加入版权公告" id="gcmt03-在每一个文件开头加入版权公告">G.CMT.03 在每一个文件开头加入版权公告</a></h2>
<h3><a class="header" href="#级别建议-23" id="级别建议-23">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-21" id="rustfmt-配置-21">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#license_template_path"><code>license_template_path</code></a></td><td>格式化每一个Rust文件（默认）</td><td>No</td><td>指定许可证模版路径</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-39" id="描述-39">【描述】</a></h3>
<p>每个文件都应该包含许可证引用。为项目选择合适的许可证版本.(比如, Apache 2.0, BSD, LGPL, GPL)。</p>
<p>可以通过 <code>rustfmt</code> 的 <code>license_template_path</code> 配置项 和 <code>license.template</code>来自动化此操作。</p>
<h3><a class="header" href="#示例-27" id="示例-27">【示例】</a></h3>
<p>【正例】</p>
<p>来自 <a href="https://github.com/tikv/tikv/blob/master/etc/license.template">TiKV</a> 项目的案例。可以命名为<code>.rustfmt.license-template</code>许可证模版。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Copyright {\d+} TiKV Project Authors. Licensed under Apache-2.0.
<span class="boring">}
</span></code></pre></pre>
<p>在 <code>rustfmt.toml</code> 中配置：</p>
<pre><code class="language-toml">license_template_path = &quot;.rustfmt.license-template&quot;
</code></pre>
<p>在代码文件中手工添加对应的注释 （自动插入功能还未支持）：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Copyright 2021 TiKV Project Authors. Licensed under Apache-2.0.
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gcmt04-在注释中使用-fixme-和-todo-来帮助任务协作" id="gcmt04-在注释中使用-fixme-和-todo-来帮助任务协作">G.CMT.04 在注释中使用 <code>FIXME</code> 和 <code>TODO</code> 来帮助任务协作</a></h2>
<h3><a class="header" href="#级别建议-24" id="级别建议-24">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-22" id="rustfmt-配置-22">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#report_fixme"><code>report_fixme</code></a></td><td>Never（默认），Unnumbered（推荐）</td><td>No</td><td>是否报告 FIXME 注释</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#report_todo"><code>report_todo</code></a></td><td>Never（默认），Unnumbered（推荐）</td><td>No</td><td>是否报告 FIXME 注释</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-40" id="描述-40">【描述】</a></h3>
<p>通过在注释中开启 <code>FIXME</code> 和 <code>TODO</code> 可以方便协作。rustfmt 默认不开启该项，所以需要配置。</p>
<p>但是配置为 <code>Always</code> 没必要，只需要配置为 <code>Unnumbered</code> 针对编号的 <code>FXIME</code> 和 <code>TODO</code> 报告即可。</p>
<p>这两个配置目前有 Bug ，无法正确识别报告，但不影响这个规则的应用。</p>
<h3><a class="header" href="#示例-28" id="示例-28">【示例】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>// TODO(calebcartwright): consider enabling box_patterns feature gate
fn annotation_type_for_level(level: Level) -&gt; AnnotationType {
    match level {
        Level::Bug | Level::Fatal | Level::Error =&gt; AnnotationType::Error,
        Level::Warning =&gt; AnnotationType::Warning,
        Level::Note =&gt; AnnotationType::Note,
        Level::Help =&gt; AnnotationType::Help,
        // FIXME(#59346): Not sure how to map these two levels
        Level::Cancelled | Level::FailureNote =&gt; AnnotationType::Error,
        Level::Allow =&gt; panic!(&quot;Should not call with Allow&quot;),
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gcmt05-在-公开的返回result类型返回的函数文档中增加--error-注释" id="gcmt05-在-公开的返回result类型返回的函数文档中增加--error-注释">G.CMT.05 在 公开的返回<code>Result</code>类型返回的函数文档中增加 <code># Error</code> 注释</a></h2>
<h3><a class="header" href="#级别建议-25" id="级别建议-25">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-9" id="lint-检测-9">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>默认 level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/index.html#missing_errors_doc">missing_errors_doc </a></td><td>yes</td><td>no</td><td>Style</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-41" id="描述-41">【描述】</a></h3>
<p>在公开（pub）的返回<code>Result</code>类型函数文档中，建议增加 <code># Error</code> 注释来解释该函数返回的错误类型，方便用户处理错误。</p>
<p>说明： 该规则通过 cargo clippy 来检测。默认不会警告。</p>
<h3><a class="header" href="#示例-29" id="示例-29">【示例】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::io;
</span>/// # Errors
///
/// Will return `Err` if `filename` does not exist or the user does not have
/// permission to read it.
pub fn read(filename: String) -&gt; io::Result&lt;String&gt; {
    unimplemented!();
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::io;
</span>pub fn read(filename: String) -&gt; io::Result&lt;String&gt; {
    unimplemented!();
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gcmt06--在-公开的函数文档中增加--panic-注释" id="gcmt06--在-公开的函数文档中增加--panic-注释">G.CMT.06  在 公开的函数文档中增加 <code># Panic</code> 注释</a></h2>
<h3><a class="header" href="#级别建议-26" id="级别建议-26">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-10" id="lint-检测-10">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>默认 level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/index.html#missing_panics_doc">missing_panics_doc </a></td><td>yes</td><td>no</td><td>Style</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-42" id="描述-42">【描述】</a></h3>
<p>在公开（pub）函数文档中，建议增加 <code># Panic</code> 注释来解释该函数在什么条件下会 Panic，便于使用者进行预处理。</p>
<p>说明： 该规则通过 cargo clippy 来检测。默认不会警告。</p>
<h3><a class="header" href="#示例-30" id="示例-30">【示例】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// # Panics
///
/// Will panic if y is 0
pub fn divide_by(x: i32, y: i32) -&gt; i32 {
    if y == 0 {
        panic!(&quot;Cannot divide by 0&quot;)
    } else {
        x / y
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn divide_by(x: i32, y: i32) -&gt; i32 {
    if y == 0 {
        panic!(&quot;Cannot divide by 0&quot;)
    } else {
        x / y
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gcmt07---在-文档注释中要使用-空格代替-tab" id="gcmt07---在-文档注释中要使用-空格代替-tab">G.CMT.07   在 文档注释中要使用 空格代替 tab</a></h2>
<h3><a class="header" href="#级别建议-27" id="级别建议-27">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-11" id="lint-检测-11">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>默认 level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/index.html#tabs_in_doc_comments">tabs_in_doc_comments </a></td><td>yes</td><td>no</td><td>Style</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-43" id="描述-43">【描述】</a></h3>
<p>Rust 代码风格中提倡使用空格代替tab，在文档注释中也应该统一使用空格。</p>
<h3><a class="header" href="#示例-31" id="示例-31">【示例】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>///
/// Struct to hold two strings:
///     - first        one
///     - second    one
pub struct DoubleString {
   ///
   ///     - First String:
   ///         - needs to be inside here
   first_string: String,
   ///
   ///     - Second String:
   ///         - needs to be inside here
   second_string: String,
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<p>下面文档注释中使用了 tab。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>///
/// Struct to hold two strings:
/// 	- first		one
/// 	- second	one
pub struct DoubleString {
   ///
   /// 	- First String:
   /// 		- needs to be inside here
   first_string: String,
   ///
   /// 	- Second String:
   /// 		- needs to be inside here
   second_string: String,
}

<span class="boring">}
</span></code></pre></pre>
<hr />
<h2><a class="header" href="#参考-1" id="参考-1">参考</a></h2>
<ol>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md">RFC 505: API 注释约定</a></li>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/1574-more-api-documentation-conventions.md">RFC 1574: API 文档约定</a></li>
<li><a href="https://www.tangramvision.com/blog/making-great-docs-with-rustdoc">Making Great Docs with Rustdoc</a></li>
<li><a href="https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html">Rust Doc book</a></li>
</ol>
<h1><a class="header" href="#编程实践" id="编程实践">编程实践</a></h1>
<ul>
<li><a href="safe-guides/./coding_practice/consts.html">常量</a></li>
<li><a href="safe-guides/./coding_practice/statics.html">静态变量</a></li>
<li><a href="safe-guides/./coding_practice/variables.html">本地变量</a></li>
<li><a href="safe-guides/./coding_practice/data-type.html">数据类型</a>
<ul>
<li><a href="safe-guides/./coding_practice/data-type/unit.html">单元类型</a></li>
<li><a href="safe-guides/./coding_practice/data-type/bool.html">布尔</a></li>
<li><a href="safe-guides/./coding_practice/data-type/char.html">字符</a></li>
<li><a href="safe-guides/./coding_practice/data-type/int.html">整数</a></li>
<li><a href="safe-guides/./coding_practice/data-type/float.html">浮点数</a></li>
<li><a href="safe-guides/./coding_practice/data-type/slice-and-str.html">切片</a></li>
<li><a href="safe-guides/./coding_practice/data-type/tuple.html">元组</a></li>
<li><a href="safe-guides/./coding_practice/data-type/array.html">数组</a></li>
<li><a href="safe-guides/./coding_practice/data-type/struct.html">结构体</a></li>
<li><a href="safe-guides/./coding_practice/data-type/enum.html">枚举体</a></li>
</ul>
</li>
<li><a href="safe-guides/./coding_practice/expr.html">表达式</a></li>
<li><a href="safe-guides/./coding_practice/control-flow.html">流程控制</a></li>
<li><a href="safe-guides/./coding_practice/strings.html">字符串</a></li>
<li><a href="safe-guides/./coding_practice/collections.html">集合容器</a></li>
<li><a href="safe-guides/./coding_practice/fn-and-closure.html">函数与闭包</a></li>
<li><a href="safe-guides/./coding_practice/generic.html">泛型</a></li>
<li><a href="safe-guides/./coding_practice/traits.html">特质</a>
<ul>
<li><a href="safe-guides/./coding_practice/traits/std-buildin.html">标准库内置 trait</a></li>
<li><a href="safe-guides/./coding_practice/traits/trait-object.html">trait 对象</a></li>
</ul>
</li>
<li><a href="safe-guides/./coding_practice/error-handle.html">错误处理</a></li>
<li><a href="safe-guides/./coding_practice/memory.html">内存管理</a>
<ul>
<li><a href="safe-guides/./coding_practice/memory/lifetime.html">生存期</a></li>
<li><a href="safe-guides/./coding_practice/memory/box.html"><code>Box&lt;T&gt;</code></a></li>
<li><a href="safe-guides/./coding_practice/memory/drop.html">Drop 析构</a></li>
</ul>
</li>
<li><a href="safe-guides/./coding_practice/module.html">模块</a></li>
<li><a href="safe-guides/./coding_practice/cargo.html">包管理</a></li>
<li><a href="safe-guides/./coding_practice/macros.html">宏</a>
<ul>
<li><a href="safe-guides/./coding_practice/macros/declarative.html">声明宏</a></li>
<li><a href="safe-guides/./coding_practice/macros/Procedural.html">过程宏</a></li>
</ul>
</li>
<li><a href="safe-guides/./coding_practice/threads.html">多线程</a>
<ul>
<li><a href="safe-guides/./coding_practice/threads/lock.html">有锁</a></li>
<li><a href="safe-guides/./coding_practice/threads/lock-free.html">无锁</a></li>
</ul>
</li>
<li><a href="safe-guides/./coding_practice/async-await.html">异步编程</a></li>
<li><a href="safe-guides/./coding_practice/unsafe_rust.html">Unsafe Rust</a>
<ul>
<li><a href="safe-guides/./coding_practice/unsafe_rust/safe_abstract.html">安全抽象</a></li>
<li><a href="safe-guides/./coding_practice/unsafe_rust/raw_ptr.html">裸指针操作</a></li>
<li><a href="safe-guides/./coding_practice/unsafe_rust/union.html">联合体</a></li>
<li><a href="safe-guides/./coding_practice/unsafe_rust/layout.html">内存布局</a></li>
<li><a href="safe-guides/./coding_practice/unsafe_rust/ffi.html">FFi 规范</a></li>
</ul>
</li>
<li><a href="safe-guides/./coding_practice/no-std.html">no-std</a></li>
<li><a href="safe-guides/./coding_practice/security.html">信息安全</a></li>
<li><a href="safe-guides/./coding_practice/others.html">其他</a></li>
</ul>
<h1><a class="header" href="#常量" id="常量">常量</a></h1>
<p>在 Rust 中，常量有两种用途：</p>
<ul>
<li>编译时常量（Compile-time constants）</li>
<li>编译时求值 （CTEF, compile-time evaluable functions）</li>
</ul>
<p>常量命名风格指南请看 <a href="safe-guides/coding_practice/../code_style/naming.html">编码风格-命名</a></p>
<hr />
<h2><a class="header" href="#gcns01-对于科学计算中涉及浮点数近似值的常量要尽量使用预定义常量" id="gcns01-对于科学计算中涉及浮点数近似值的常量要尽量使用预定义常量">G.CNS.01 对于科学计算中涉及浮点数近似值的常量要尽量使用预定义常量</a></h2>
<h3><a class="header" href="#级别建议-28" id="级别建议-28">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-12" id="lint-检测-12">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#approx_constant">approx_constant</a></td><td>yes</td><td>no</td><td>Correctness</td><td>deny</td></tr>
</tbody></table>
<p>该 Lint 默认为 <code>deny</code>，但在某些场景下，可以设置为<code>allow</code>.</p>
<h3><a class="header" href="#描述-44" id="描述-44">【描述】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = std::f32::consts::PI;
let y = std::f64::consts::FRAC_1_PI;
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 3.14;
let y = 1_f64 / x;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gcns02-不要断言常量布尔类型" id="gcns02-不要断言常量布尔类型">G.CNS.02 不要断言常量布尔类型</a></h2>
<h3><a class="header" href="#级别必须-7" id="级别必须-7">【级别：必须】</a></h3>
<p>必须按此规范执行。</p>
<h3><a class="header" href="#lint-检测-13" id="lint-检测-13">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#assertions_on_constants">assertions_on_constants</a></td><td>yes</td><td>no</td><td>Style</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-45" id="描述-45">【描述】</a></h3>
<p>因为有可能被编译器优化掉。最好直接使用 <code>panic!</code> 代替。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>panic!（&quot;something&quot;）;
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const B: bool = false;
assert!(B);
<span class="boring">}
</span></code></pre></pre>
<p>【例外】</p>
<p>该示例需要维护一个常量的不变性，确保它在未来修改时不会被无意中破坏。类似于 <a href="https://docs.rs/static_assertions/1.1.0/static_assertions/">static_assertions/</a> 的作用。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![allow(clippy::assertions_on_constants)]
<span class="boring">fn main() {
</span>const MIN_OVERFLOW: usize = 8192;
const MAX_START: usize = 2048;
const MAX_END: usize = 2048;
const MAX_PRINTED: usize = MAX_START + MAX_END;
assert!(MAX_PRINTED &lt; MIN_OVERFLOW);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gcns03-不要将内部可变性容器声明为常量" id="gcns03-不要将内部可变性容器声明为常量">G.CNS.03 不要将内部可变性容器声明为常量</a></h2>
<h3><a class="header" href="#级别必须-8" id="级别必须-8">【级别：必须】</a></h3>
<p>必须按此规范执行。</p>
<h3><a class="header" href="#lint-检测-14" id="lint-检测-14">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#borrow_interior_mutable_const">borrow_interior_mutable_const</a></td><td>yes</td><td>no</td><td>Style</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#declare_interior_mutable_const">declare_interior_mutable_const</a></td><td>yes</td><td>no</td><td>Style</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-46" id="描述-46">【描述】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};
const CONST_ATOM: AtomicUsize = AtomicUsize::new(12);

// Good.
static STATIC_ATOM: AtomicUsize = CONST_ATOM;
STATIC_ATOM.store(9, SeqCst);
assert_eq!(STATIC_ATOM.load(SeqCst), 9); // use a `static` item to refer to the same instance
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};
const CONST_ATOM: AtomicUsize = AtomicUsize::new(12);

// Bad.
CONST_ATOM.store(6, SeqCst); // the content of the atomic is unchanged
assert_eq!(CONST_ATOM.load(SeqCst), 12); // because the CONST_ATOM in these lines are distinct

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gcns04-不要在常量定义中增加显式的-static-生命周期" id="gcns04-不要在常量定义中增加显式的-static-生命周期">G.CNS.04 不要在常量定义中增加显式的 <code>'static</code> 生命周期</a></h2>
<h3><a class="header" href="#级别必须-9" id="级别必须-9">【级别：必须】</a></h3>
<p>必须按此规范执行。</p>
<h3><a class="header" href="#lint-检测-15" id="lint-检测-15">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#redundant_static_lifetimes">redundant_static_lifetimes</a></td><td>yes</td><td>no</td><td>Style</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-47" id="描述-47">【描述】</a></h3>
<p>没必要加。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const FOO: &amp;[(&amp;str, &amp;str, fn(&amp;Bar) -&gt; bool)] = &amp;[...]
 static FOO: &amp;[(&amp;str, &amp;str, fn(&amp;Bar) -&gt; bool)] = &amp;[...]
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const FOO: &amp;'static [(&amp;'static str, &amp;'static str, fn(&amp;Bar) -&gt; bool)] =
&amp;[...]
static FOO: &amp;'static [(&amp;'static str, &amp;'static str, fn(&amp;Bar) -&gt; bool)] =
&amp;[...]
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gcns05--对于函数或方法应尽可能地使用-const-fn" id="gcns05--对于函数或方法应尽可能地使用-const-fn">G.CNS.05  对于函数或方法应尽可能地使用 <code>const fn</code></a></h2>
<h3><a class="header" href="#级别建议-29" id="级别建议-29">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-16" id="lint-检测-16">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#missing_const_for_fn">missing_const_for_fn</a></td><td>yes</td><td>no</td><td>Perf</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-48" id="描述-48">【描述】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn new() -&gt; Self {
    Self { random_number: 42 }
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn new() -&gt; Self {
    Self { random_number: 42 }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gcns06-注意避免将量大的数据结构定义为常量" id="gcns06-注意避免将量大的数据结构定义为常量">G.CNS.06 注意避免将量大的数据结构定义为常量</a></h2>
<h3><a class="header" href="#级别建议-30" id="级别建议-30">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-17" id="lint-检测-17">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制化参考】</p>
<p>这条规则如果需要定制Lint，则需要找出每个定义的常量再判断其空间占用，或可直接排除基础类型以外的数据类型。</p>
<p><strong>【描述】</strong></p>
<p>常量会内联到使用它的地方而静态变量不会内联，它是全局的，且有一个引用地址。
当创建一个很大的常量数组时，应该考虑将其换成静态变量，因为常量会到处内联。</p>
<p><strong>【示例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    static MONTHS: [&amp;str; 12] = [&quot;January&quot;, &quot;Feburary&quot;, &quot;March&quot;, &quot;April&quot;,
                                &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;,
                                &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
}
</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    const MONTHS: [&amp;str; 12] = [&quot;January&quot;, &quot;Feburary&quot;, &quot;March&quot;, &quot;April&quot;,
                                &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;,
                                &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
}
</code></pre></pre>
<h1><a class="header" href="#静态变量" id="静态变量">静态变量</a></h1>
<hr />
<h2><a class="header" href="#gstv01--不要直接使用可变静态变量作为全局变量" id="gstv01--不要直接使用可变静态变量作为全局变量">G.STV.01  不要直接使用可变静态变量作为全局变量</a></h2>
<h3><a class="header" href="#级别建议-31" id="级别建议-31">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-18" id="lint-检测-18">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制化参考】</p>
<p>这条规则如果需要定制 Lint，则可以先检查代码是否使用到 FFI，然后再检测代码中是否有已定义为可变的静态变量（static mut），以及其是否用在用于调用外部函数上，若此条件不达标则发出告警。</p>
<h3><a class="header" href="#描述-49" id="描述-49">【描述】</a></h3>
<p>对可变静态变量进行全局修改是 Unsafe 的。在多线程应用中，修改静态变量会导致数据争用（data race），此未定义行为目前并不会被Clippy或Rustc检测出。</p>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut NUM_OF_APPLES: i32 = 0;

unsafe fn buy_apple() {
    NUM_OF_APPLES += 1;
}

unsafe fn eat_apple() {
    NUM_OF_APPLES -= 1;
}
<span class="boring">}
</span></code></pre></pre>
<p>【例外】</p>
<p>在使用FFI引用外部，例如C的函数时，其本身有可能会返回全局变量。当rust接入这些函数时需要指定输入的变量类型为静态（static），而若要改变它们的值的时候就需要将其定义为可变静态变量（static mut）。</p>
<pre><pre class="playground"><code class="language-rust">use std::ffi::CString;
use std::ptr;

#[link(name = &quot;readline&quot;)]
extern {
    static mut rl_prompt: *const libc::c_char;
}

fn main() {
    let prompt = CString::new(&quot;[my-awesome-shell] $&quot;).unwrap();
    unsafe {
        rl_prompt = prompt.as_ptr();

        println!(&quot;{:?}&quot;, rl_prompt);

        rl_prompt = ptr::null();
    }
}
</code></pre></pre>
<h1><a class="header" href="#变量" id="变量">变量</a></h1>
<p>这里所说变量是指局部变量。默认情况下，Rust 会强制初始化所有值，以防止使用未初始化的内存。</p>
<p>变量命名风格指南请看 <a href="safe-guides/coding_practice/../code_style/naming.html">编码风格-命名</a></p>
<hr />
<h2><a class="header" href="#pvar01-非必要不要像-c-语言那样先声明可变变量然后再去赋值" id="pvar01-非必要不要像-c-语言那样先声明可变变量然后再去赋值">P.VAR.01 非必要不要像 C 语言那样先声明可变变量然后再去赋值</a></h2>
<p><strong>【描述】</strong></p>
<p>不要先声明一个可变的变量，然后再后续过程中去改变它的值。一般情况下，声明一个变量的时候，要对其进行初始化。如果后续可能会改变其值，要考虑优先使用变量遮蔽（继承式可变）功能。如果需要在一个子作用域内改变其值，再使用可变绑定或可变引用。</p>
<h2><a class="header" href="#pvar02-避免大量栈分配" id="pvar02-避免大量栈分配">P.VAR.02 避免大量栈分配</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 默认在栈上存储。局部变量占用过多栈空间，会栈溢出。</p>
<h2><a class="header" href="#pvar03-禁止将局部变量的引用返回函数外" id="pvar03-禁止将局部变量的引用返回函数外">P.VAR.03 禁止将局部变量的引用返回函数外</a></h2>
<p><strong>【描述】</strong></p>
<p>局部变量生命周期始于其声明终于其作用域结束。如果在其生命周期之外被引用，则程序的行为是未定义的。当然，Rust 编译器也会阻止你这么干。</p>
<h2><a class="header" href="#pvar04--变量的命名中不需要添加类型标识" id="pvar04--变量的命名中不需要添加类型标识">P.VAR.04  变量的命名中不需要添加类型标识</a></h2>
<p><strong>【描述】</strong></p>
<p>因为 Rust 语言类型系统崇尚显式的哲学，所以不需要在变量命名中也添加关于类型的标识。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let account: Vec&lt;u8&gt; = read_some_input();   // account 的类型很清楚
let account = String::from_utf8(account)?;  // account 的类型很清楚
let account: Account = account.parse()?;   // account 的类型很清楚
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let account_bytes: Vec&lt;u8&gt; = read_some_input();   // account 的类型很清楚，没必要在命名中加 `_bytes`
let account_str = String::from_utf8(account_bytes)?; // account 的类型很清楚，没必要在命名中加 `_str`
let account: Account = account_str.parse()?;   // account 的类型很清楚，没必要在命名中加 `_str`
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#pvar05---利用变量遮蔽功能保证变量安全使用" id="pvar05---利用变量遮蔽功能保证变量安全使用">P.VAR.05   利用变量遮蔽功能保证变量安全使用</a></h2>
<p><strong>【描述】</strong></p>
<p>在某些场景，可能会临时准备或处理一些数据，但在此之后，数据只用于检查而非修改。</p>
<p>那么可以将其通过变量遮蔽功能，重写绑定为不可变变量，来表明这种 临时可变，但后面不变的意图。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut data = get_vec();
data.sort(); // 临时需要排序
let data = data; //  后面就不需要改动了，由编译器可以确保

// Here `data` is immutable.
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data = { 
    let mut data = get_vec();
    data.sort();
    data // 虽然后面不再改动，但代码语义上没有表现出来先改变，后不变那种顺序语义
};

// Here `data` is immutable.
<span class="boring">}
</span></code></pre></pre>
<hr />
<h2><a class="header" href="#gvar01-交换两个变量的值应该使用-stdmemswap-而非赋值" id="gvar01-交换两个变量的值应该使用-stdmemswap-而非赋值">G.VAR.01 交换两个变量的值应该使用 <code>std::mem::swap</code> 而非赋值</a></h2>
<h3><a class="header" href="#级别必须-10" id="级别必须-10">【级别：必须】</a></h3>
<p>必须按此规范执行。</p>
<h3><a class="header" href="#lint-检测-19" id="lint-检测-19">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#almost_swapped">almost_swapped</a></td><td>yes</td><td>no</td><td>Correctness</td><td>deny</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-50" id="描述-50">【描述】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut a = 1;
let mut b = 2;
std::mem::swap(&amp;mut a, &amp;mut b);
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut a = 1;
let mut b = 2;
a = b;
b = a;  
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gvar02---使用解构元组方式定义多个变量时不要使用太多单个字符来命名变量" id="gvar02---使用解构元组方式定义多个变量时不要使用太多单个字符来命名变量">G.VAR.02   使用解构元组方式定义多个变量时不要使用太多单个字符来命名变量</a></h2>
<h3><a class="header" href="#级别建议-32" id="级别建议-32">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-20" id="lint-检测-20">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#many_single_char_names">many_single_char_names</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-51" id="描述-51">【描述】</a></h3>
<p>在解构元组的方式定义多个变量时，有时候变量命名可能是无特别语义的，比如临时值，可以用简单的单个字符来定义变量名，但是不宜太多。</p>
<p>该 lint 对应 <code>clippy.toml</code> 配置项：</p>
<pre><code class="language-toml"># 修改可以绑定的单个字符变量名最大数量。默认为 4
single-char-binding-names-threshold=4
</code></pre>
<p>【正例】</p>
<p>超过四个的，就需要起带语义的命名。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (a, b, c, d) = (...);
let (width, high, len, shape, color, status) = (...);
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (a, b, c, d, e, f, g) = (...);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gvar03---通常不要使用非-ascii-字符作为标识符" id="gvar03---通常不要使用非-ascii-字符作为标识符">G.VAR.03   通常不要使用非 ASCII 字符作为标识符</a></h2>
<h3><a class="header" href="#级别建议-33" id="级别建议-33">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-21" id="lint-检测-21">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#non-ascii-idents">rustc-lint: non-ascii-idents</a></td><td>no</td><td>yes</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-52" id="描述-52">【描述】</a></h3>
<p>Rust 语言默认支持 Non ASCII 字符作为合法标识符。但是，为了统一团队代码风格，建议使用最常用的 ASCII 字符作为合法标识符。</p>
<p>另外，只有使用英文的命名才能让<strong>命名相关</strong>的 Lint 生效。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct People {
    name: String,
    addr: String,
}

fn main () {
    let name = &quot;मनीष&quot;.to_string();
    let addr = &quot;Berkeley&quot;.to_string();
    
    // मराठी
    let me = People {
        name: name,
        addr: addr,
    };
    
    // हिंदी
    let name = &quot;مصطفى&quot;.to_string();
    let addr = &quot;Oakland&quot;.to_string();
   
    // اردو     
    let he = People {
        name: name,
        addr: addr,
    }; 
    
    println!(&quot;my name: {:?}&quot;, me);
    println!(&quot;his name: {:?}&quot;, he);
}

// 输出
// my name: People { name: &quot;मनीष&quot;, addr: &quot;Berkeley&quot; }
// his name: People { name: &quot;مصطفى&quot;, addr: &quot;Oakland&quot; }
</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct 人 {
    /// 普通话
    名字: String,
    /// 廣東話
    屋企: String,
}

fn main () {
    let 我的名字 = &quot;मनीष&quot;.to_string();
    let 我嘅屋企 = &quot;Berkeley&quot;.to_string();
    
    // मराठी
    let मनीष = 人 {
        名字: 我的名字,
        屋企: 我嘅屋企,
    };
    
    // हिंदी
    let उसका_नाम = &quot;مصطفى&quot;.to_string();
    let 他的家 = &quot;Oakland&quot;.to_string();
   
    // اردو 
    let مصطفى = 人 {
        名字: उसका_नाम,
        屋企: 他的家,
    }; 
    
    println!(&quot;मी: {:?}&quot;, मनीष);
    println!(&quot;माझा मित्र: {:?}&quot;, مصطفى);
}

// 输出：
// मी: 人 { 名字: &quot;मनीष&quot;, 屋企: &quot;Berkeley&quot; }
// माझा मित्र: 人 { 名字: &quot;مصطفى&quot;, 屋企: &quot;Oakland&quot; }
</code></pre></pre>
<h2><a class="header" href="#gvar04-不要在子作用域中使用变量遮蔽功能" id="gvar04-不要在子作用域中使用变量遮蔽功能">G.VAR.04 不要在子作用域中使用变量遮蔽功能</a></h2>
<h3><a class="header" href="#级别建议-34" id="级别建议-34">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-22" id="lint-检测-22">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制化参考】
这条规则如果需要定制Lint，则可以分别扫描当前作用域和子作用域中的变量，判断是否存在同名问题。</p>
<p><strong>【描述】</strong></p>
<p>当两个作用域存在包含关系时，不要使用变量遮蔽功能，即在较小的作用域内定义与较大作用域中相同的变量名，以免引起逻辑Bug。</p>
<p><strong>【示例】</strong>
【反例】</p>
<pre><pre class="playground"><code class="language-rust">fn main(){
    let mut a = 0;
    {
        // do something
        a = 42;
        
        // bug
        // let a = 42;
    }
    
    a; // use a again
}
</code></pre></pre>
<h2><a class="header" href="#gvar05--不要在当前作用域使用变量遮蔽功能" id="gvar05--不要在当前作用域使用变量遮蔽功能">G.VAR.05  不要在当前作用域使用变量遮蔽功能</a></h2>
<h3><a class="header" href="#级别建议-35" id="级别建议-35">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-23" id="lint-检测-23">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#shadow_reuse">shadow_reuse</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#shadow_same">shadow_same</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#shadow_unrelated">shadow_unrelated</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-53" id="描述-53">【描述】</a></h3>
<p>在同一个作用域中，非必要时不要通过新变量声明遮蔽旧变量声明的方式来修改变量。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 2;
let y = x + 1; // 不改变x的值，声明新的变量y

let y = &amp;x; // 不改变x的绑定，声明新的变量

let w = z; // 使用不同的名字
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 2;
let x = x + 1; // 将会改变x的值

let x = &amp;x; // 只是改变引用级别

let x = y; // 更早的绑定
let x = z; // 遮蔽了更早的绑定
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gvar06--避免局部变量导致的大量栈分配" id="gvar06--避免局部变量导致的大量栈分配">G.VAR.06  避免局部变量导致的大量栈分配</a></h2>
<h3><a class="header" href="#级别建议-36" id="级别建议-36">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-24" id="lint-检测-24">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制化参考】
这条规则如果需要定制Lint，则可以分别检测每个局部变量占用的栈空间，并统计总体占用情况，进行告警。</p>
<h3><a class="header" href="#描述-54" id="描述-54">【描述】</a></h3>
<p>Rust 局部变量默认分配在栈上。当局部变量占用栈空间过大时，可以采用Box<T>使变量在堆上分配</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _: Box&lt;[i32; 8000]&gt; = Box::new([1; 8000]);
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _: [i32; 8000] = [1; 8000];
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gvar07--避免在变量的命名中添加类型标识" id="gvar07--避免在变量的命名中添加类型标识">G.VAR.07  避免在变量的命名中添加类型标识</a></h2>
<h3><a class="header" href="#级别建议-37" id="级别建议-37">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-25" id="lint-检测-25">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制化参考】
这条规则如果需要定制Lint，则可以获取变量命名的结尾部分和变量类型，进行匹配，判断是否重复。</p>
<h3><a class="header" href="#描述-55" id="描述-55">【描述】</a></h3>
<p>变量的名字需要保持简洁清晰，不需要在变量命名中也添加关于类型的标识。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let count: i32 = 12;   // count 的类型已经很清楚
<span class="boring">}
</span></code></pre></pre>
<p>更多例子: <strong>P.VAR.04  变量的命名中不需要添加类型标识</strong></p>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let count_int: i32 = 12;   // count 的类型已经很清楚，没必要在命名中加 `_int`
<span class="boring">}
</span></code></pre></pre>
<p>更多例子: <strong>P.VAR.04  变量的命名中不需要添加类型标识</strong></p>
<h1><a class="header" href="#数据类型" id="数据类型">数据类型</a></h1>
<p>数据类型记录 Rust 标准库提供的 原生类型，以及结构体和枚举体等编码实践。</p>
<ul>
<li><a href="safe-guides/coding_practice/data-type/unit.html">单元类型</a></li>
<li><a href="safe-guides/coding_practice/data-type/bool.html">布尔</a></li>
<li><a href="safe-guides/coding_practice/data-type/char.html">字符</a></li>
<li><a href="safe-guides/coding_practice/data-type/int.html">整数</a></li>
<li><a href="safe-guides/coding_practice/data-type/float.html">浮点数</a></li>
<li><a href="safe-guides/coding_practice/data-type/ref.html">引用</a></li>
<li><a href="safe-guides/coding_practice/data-type/slice-and-str.html">切片</a></li>
<li><a href="safe-guides/coding_practice/data-type/tuple.html">元组</a></li>
<li><a href="safe-guides/coding_practice/data-type/array.html">固定长度数组</a></li>
<li><a href="safe-guides/coding_practice/data-type/vec.html">动态数组</a></li>
<li><a href="safe-guides/coding_practice/data-type/struct.html">结构体</a></li>
<li><a href="safe-guides/coding_practice/data-type/enum.html">枚举</a></li>
</ul>
<hr />
<h2><a class="header" href="#ptyp01-类型转换要尽量使用安全的方式" id="ptyp01-类型转换要尽量使用安全的方式">P.TYP.01 类型转换要尽量使用安全的方式</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 中的类型转换有多种方式，包括 <code>as</code> 强转、<code>From/Into</code>安全转换函数、<code>Deref</code>、以及 Unsafe 的 <code>std::mem::transmute</code> 等。在使用类型转换的时候，要注意场景，选择合适的方式和安全条件，不要让转换产生未定义行为。</p>
<h2><a class="header" href="#ptyp02--对数组和集合容器进行索引要使用-usize-类型" id="ptyp02--对数组和集合容器进行索引要使用-usize-类型">P.TYP.02  对数组和集合容器进行索引要使用 <code>usize</code> 类型</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 中只允许索引为 <code>usize</code> 类型，因为：</p>
<ol>
<li>负索引是无意义的。</li>
<li><code>usize</code>和 裸指针大小相同，意味着指针算法不会有任何隐藏的强制转换</li>
<li><code>std::mem::size_of()</code> 和 <code>std::mem::align_of()</code> 的函数返回 <code>usize</code> 类型。</li>
<li><code>usize</code> 不会因为平台架构的切换而导致索引值被截断的问题，比如 将<code>u32</code>类型的索引 用到 16位大小的嵌入式平台就会出问题。</li>
</ol>
<h2><a class="header" href="#ptyp03---必要时应该使得类型可以表达更明确的语义而不是只是直接使用原生类型" id="ptyp03---必要时应该使得类型可以表达更明确的语义而不是只是直接使用原生类型">P.TYP.03   必要时，应该使得类型可以表达更明确的语义，而不是只是直接使用原生类型</a></h2>
<p><strong>【描述】</strong></p>
<p>这样可以增加代码的可读性。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">struct Years(i64);

fn main() {
    let years = Years(1942);
    let years_as_primitive_1: i64 = years.0; // Tuple
    let Years(years_as_primitive_2) = years; // Destructuring
}
</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let years = 1942;
}
</code></pre></pre>
<hr />
<h2><a class="header" href="#gtyp01-类型转换尽可能使用安全的转换函数代替-as" id="gtyp01-类型转换尽可能使用安全的转换函数代替-as">G.TYP.01 类型转换尽可能使用安全的转换函数代替 <code>as</code></a></h2>
<h3><a class="header" href="#级别建议-38" id="级别建议-38">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-26" id="lint-检测-26">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#as_conversions">as_conversions</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cast_lossless">cast_lossless</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cast_possible_truncation">cast_possible_truncation</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cast_possible_wrap">cast_possible_wrap</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cast_precision_loss">cast_precision_loss</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cast_sign_loss">cast_sign_loss</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#fn_to_numeric_cast">fn_to_numeric_cast</a></td><td>yes</td><td>no</td><td>Style</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#fn_to_numeric_cast_with_truncation">fn_to_numeric_cast_with_truncation</a></td><td>yes</td><td>no</td><td>Style</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#char_lit_as_u8">char_lit_as_u8</a></td><td>yes</td><td>no</td><td>Complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cast_ref_to_mut">cast_ref_to_mut</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#ptr_as_ptr">ptr_as_ptr</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-56" id="描述-56">【描述】</a></h3>
<p>Rust 的 <code>as</code> 转换包含了「静默的有损转换(lossy conversion)」。诸如 <code>i32::from</code> 之类的转换函数只会执行无损转换(lossless conversion)。 如果输入表达式的类型发生变化，使用转换函数可以防止转换变成无声的有损转换，并使阅读代码的人更容易知道转换是无损的。</p>
<h2><a class="header" href="#gtyp02--数字字面量在使用的时候应该明确标注好类型" id="gtyp02--数字字面量在使用的时候应该明确标注好类型">G.TYP.02  数字字面量在使用的时候应该明确标注好类型</a></h2>
<h3><a class="header" href="#级别建议-39" id="级别建议-39">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-27" id="lint-检测-27">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#default_numeric_fallback">default_numeric_fallback</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-57" id="描述-57">【描述】</a></h3>
<p>如果数字字面量没有被指定具体类型，那么单靠类型推导，整数类型会被默认绑定为 <code>i32</code> 类型，而浮点数则默认绑定为 <code>f64</code>类型。这可能导致某些运行时的意外。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let i = 10u32;
let f = 1.23f32;
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let i = 10; // i32
let f = 1.23; // f64
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gtyp03---不要用数字类型边界值去判断能否安全转换而应该使用-try_from-相关方法" id="gtyp03---不要用数字类型边界值去判断能否安全转换而应该使用-try_from-相关方法">G.TYP.03   不要用数字类型边界值去判断能否安全转换，而应该使用 <code>try_from</code> 相关方法</a></h2>
<h3><a class="header" href="#级别建议-40" id="级别建议-40">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-28" id="lint-检测-28">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#checked_conversions">checked_conversions</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-58" id="描述-58">【描述】</a></h3>
<p>在 Rust 中 <code>From</code> 代表不能失败的转换，而 <code>TryFrom</code> 则允许返回错误。</p>
<p>一般在数字类型转换的时候，不需要防御式地去判断数字大小边界，那样可读性比较差，应该使用 <code>try_from</code> 方法，在无法转换的时候处理错误即可。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo: u32 = 5; 
let f = i16::try_from(foo).is_ok(); // 返回 false
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo: u32 = 5;
let _ = foo &lt;= i16::MAX as u32; // 等价于 let _ = foo &lt;= (i32::MAX as u32);
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#单元类型" id="单元类型">单元类型</a></h1>
<p>Rust 中单元类型为零大小类型。其类型签名和值都为 <code>()</code>，它也是一个空元组。</p>
<hr />
<h2><a class="header" href="#gtypunit01---当函数不关心返回值但要处理错误时应使用单元类型" id="gtypunit01---当函数不关心返回值但要处理错误时应使用单元类型">G.TYP.Unit.01   当函数不关心返回值但要处理错误时应使用单元类型</a></h2>
<h3><a class="header" href="#级别建议-41" id="级别建议-41">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint检测" id="lint检测">【Lint检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制化参考】</p>
<p>可以检测使用 <code>Option&lt;T&gt;</code> 包含 <code>Error</code> 类型的情况，发出警告。</p>
<p><strong>【描述】</strong></p>
<p>单元类型代表 <code>无返回值</code>。当返回类型无返回值但要处理错误时，应使用Result&lt;(), Error&gt;类型，</p>
<p>而非Option类型。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 表示该函数要么成功，要么返回各自错误
fn f() -&gt; Result&lt;(), Error&gt; {
    
    // ...
    
    // Error handle
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f() -&gt; Option&lt;Error&gt; {
    
    // ...
    
    None
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#布尔" id="布尔">布尔</a></h1>
<h2><a class="header" href="#ptypbool01--不要使用数字来代替-布尔值" id="ptypbool01--不要使用数字来代替-布尔值">P.TYP.Bool.01  不要使用数字来代替 布尔值</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 中布尔值就是 <code>true</code>  和 <code>false</code>。 不要试图使用数字 <code>1</code> 和 <code>0</code> 来代替布尔值。</p>
<p>虽然 布尔值 可以强转为 对应的数字，但是反之则不行。</p>
<p>不要通过判断数字来代替 布尔值，除非是 FFi 场景通过 C-ABI 和其他语言打交道。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = true;
let b = false;
assert_eq!(1, a as u32);
assert_eq!(0, b as u32);
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 1;
let b = 0;
assert_eq!(true, a == 1);  
assert_eq!(false, b == 0);
<span class="boring">}
</span></code></pre></pre>
<hr />
<h2><a class="header" href="#gtypbool01-返回为布尔值的表达式或函数值不需要和布尔字面量进行比较" id="gtypbool01-返回为布尔值的表达式或函数值不需要和布尔字面量进行比较">G.TYP.Bool.01 返回为布尔值的表达式或函数值不需要和布尔字面量进行比较</a></h2>
<h3><a class="header" href="#级别必须-11" id="级别必须-11">【级别：必须】</a></h3>
<p>必须按此规范执行。</p>
<h3><a class="header" href="#lint-检测-29" id="lint-检测-29">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#bool_comparison">bool_comparison </a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#bool_assert_comparison">bool_assert_comparison </a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#needless_bool">needless_bool </a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#nonminimal_bool">nonminimal_bool  </a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#needless_bitwise_bool">needless_bitwise_bool  </a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#needless_bitwise_bool">assertions_on_constants  </a></td><td>yes</td><td>no</td><td>pedantic</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-59" id="描述-59">【描述】</a></h3>
<p>在 Rust 中，返回为布尔值的表达式或函数值可以直接当作布尔值使用。</p>
<p>总之，使用布尔表达式的时候，要尽可能地简洁明了。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if x {}
if !y {}

assert!(!&quot;a&quot;.is_empty());
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if x == true {}
if y == false {}

assert_eq!(&quot;a&quot;.is_empty(), false);
assert_ne!(&quot;a&quot;.is_empty(), true);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gtypbool02-使用多个布尔表达式条件的时候要避免引入不必要的条件" id="gtypbool02-使用多个布尔表达式条件的时候要避免引入不必要的条件">G.TYP.Bool.02 使用多个布尔表达式条件的时候要避免引入不必要的条件</a></h2>
<h3><a class="header" href="#级别必须-12" id="级别必须-12">【级别：必须】</a></h3>
<p>必须按此规范执行。</p>
<h3><a class="header" href="#lint-检测-30" id="lint-检测-30">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#logic_bug">logic_bug </a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-60" id="描述-60">【描述】</a></h3>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if a &amp;&amp; b || a { ... }
<span class="boring">}
</span></code></pre></pre>
<p>该示例中，条件 <code>b</code> 是不需要的，它等价于 <code>if a {...}</code>。</p>
<h2><a class="header" href="#gtypbool03-如果-match-匹配表达式为布尔类型建议使用-if-表达式来代替" id="gtypbool03-如果-match-匹配表达式为布尔类型建议使用-if-表达式来代替">G.TYP.Bool.03 如果 match 匹配表达式为布尔类型，建议使用 <code>if</code> 表达式来代替</a></h2>
<h3><a class="header" href="#级别建议-42" id="级别建议-42">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-31" id="lint-检测-31">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#logic_bug">logic_bug </a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#match_bool">match_bool</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-61" id="描述-61">【描述】</a></h3>
<p>对于布尔表达式更倾向于使用 <code>if ... else ...</code>，相比较 <code>match</code> 模式匹配更有利于代码可读性。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn foo() {}
</span><span class="boring">fn bar() {}
</span>let condition: bool = true;
if condition {
    foo();
} else {
    bar();
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn foo() {}
</span><span class="boring">fn bar() {}
</span>let condition: bool = true;
match condition {
    true =&gt; foo(),
    false =&gt; bar(),
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gtypbool04-不要尝试将数字类型转换为布尔值" id="gtypbool04-不要尝试将数字类型转换为布尔值">G.TYP.Bool.04 不要尝试将数字类型转换为布尔值</a></h2>
<h3><a class="header" href="#级别必须-13" id="级别必须-13">【级别：必须】</a></h3>
<p>必须按此规范执行。</p>
<h3><a class="header" href="#lint-检测-32" id="lint-检测-32">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#transmute_int_to_bool">transmute_int_to_bool </a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-62" id="描述-62">【描述】</a></h3>
<p>这可能会让布尔值在内存中的表示无效。</p>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1_u8;
unsafe {
    let _: bool = std::mem::transmute(x); // where x: u8
}

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gtypbool05-不要在-if-表达式条件中使用块block结构" id="gtypbool05-不要在-if-表达式条件中使用块block结构">G.TYP.Bool.05 不要在 if 表达式条件中使用块（block）结构</a></h2>
<h3><a class="header" href="#级别必须-14" id="级别必须-14">【级别：必须】</a></h3>
<p>必须按此规范执行。</p>
<h3><a class="header" href="#lint-检测-33" id="lint-检测-33">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#blocks_in_if_conditions">blocks_in_if_conditions  </a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-63" id="描述-63">【描述】</a></h3>
<p>为了增加可读性。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if true { /* ... */ }

<span class="boring">fn somefunc() -&gt; bool { true };
</span>let res = { let x = somefunc(); x };
if res { /* ... */ }
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if { true } { /* ... */ }

<span class="boring">fn somefunc() -&gt; bool { true };
</span>if { let x = somefunc(); x } { /* ... */ }
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gtypbool06-------非必要时布尔运算优先使用-逻辑运算符-而非-位运算符-" id="gtypbool06-------非必要时布尔运算优先使用-逻辑运算符-而非-位运算符-">G.TYP.Bool.06       非必要时，布尔运算优先使用 逻辑运算符( <code>&amp;&amp;/||</code>)而非 位运算符 (<code>&amp;/|</code>)</a></h2>
<h3><a class="header" href="#级别必须-15" id="级别必须-15">【级别：必须】</a></h3>
<p>必须按此规范执行。</p>
<h3><a class="header" href="#lint-检测-34" id="lint-检测-34">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#needless_bitwise_bool">needless_bitwise_bool</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-64" id="描述-64">【描述】</a></h3>
<p>位运算不支持短路（short-circuiting），所以会影响性能。逻辑运算符则支持短路。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (x,y) = (true, false);
if x &amp;&amp; !y {} //  逻辑运算符，支持短路
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (x,y) = (true, false);
if x &amp; !y {} //  位运算符，不支持短路
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#字符" id="字符">字符</a></h1>
<p>在 Rust 中，字符是一个合法的 Unicode 标量值（Unicode scalar value），一个字符大小为 4 字节，对应一个 Unicode 码位（CodePoint）。</p>
<hr />
<h2><a class="header" href="#gtypchar01--不要将-字符字面量强转为-u8-去使用" id="gtypchar01--不要将-字符字面量强转为-u8-去使用">G.TYP.Char.01  不要将 字符字面量强转为 <code>u8</code> 去使用</a></h2>
<h3><a class="header" href="#级别建议-43" id="级别建议-43">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-35" id="lint-检测-35">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#char_lit_as_u8">char_lit_as_u8</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-65" id="描述-65">【描述】</a></h3>
<p>应该使用 字节字面量 去代替 将 字符字面量强转为 <code>u8</code>。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>b'x'
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>'x' as u8
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gtypchar02----字符串方法中如果需要单个字符的值作为参数最好使用字符而非字符串" id="gtypchar02----字符串方法中如果需要单个字符的值作为参数最好使用字符而非字符串">G.TYP.Char.02    字符串方法中如果需要单个字符的值作为参数，最好使用字符而非字符串</a></h2>
<h3><a class="header" href="#级别建议-44" id="级别建议-44">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-36" id="lint-检测-36">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#single_char_pattern">single_char_pattern</a></td><td>yes</td><td>no</td><td>perf</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-66" id="描述-66">【描述】</a></h3>
<p>使用 字符 比 用字符串性能更好一些。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;yxz&quot;;
s.split('x');
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;yxz&quot;;
s.split(&quot;x&quot;);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gtypchar03----当需要将整数转换为字符时请使用安全转换函数而非-transmute" id="gtypchar03----当需要将整数转换为字符时请使用安全转换函数而非-transmute">G.TYP.Char.03    当需要将整数转换为字符时，请使用安全转换函数，而非 <code>transmute</code></a></h2>
<h3><a class="header" href="#级别建议-45" id="级别建议-45">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-37" id="lint-检测-37">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#transmute_int_to_char">transmute_int_to_char</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-67" id="描述-67">【描述】</a></h3>
<p>并非每个整数都对应一个合法的 Unicode 标量值，使用 <code>transmute</code> 转换会有未定义行为。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 37_u32;
unsafe {
    let x = std::char::from_u32(x).unwrap(); // 请按情况处理 None
    // let x = std::char::from_u32_unchecked(x);  // 如果确定该整数对应合法的unicode，可以使用 uncheck 方法加速
    assert_eq!('%', x);
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 37_u32;
unsafe {
    let x: char = std::mem::transmute(x); // where x: u32
    assert_eq!('%', x);
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#整数" id="整数">整数</a></h1>
<p>Rust 中有目前有 十二种整数类型：<code>i8/u8</code>, <code>i16/u16</code>, <code>i32/u32</code>, <code>i64/u64</code>, <code>i128/u128</code>, <code>isize/usize</code> 。</p>
<hr />
<h2><a class="header" href="#gtypint01--在用整数计算的时候需要考虑整数溢出回绕和截断的风险" id="gtypint01--在用整数计算的时候需要考虑整数溢出回绕和截断的风险">G.TYP.INT.01  在用整数计算的时候需要考虑整数溢出、回绕和截断的风险</a></h2>
<h3><a class="header" href="#级别建议-46" id="级别建议-46">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-38" id="lint-检测-38">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#integer_arithmetic">integer_arithmetic</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#manual_saturating_arithmetic">manual_saturating_arithmetic</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-68" id="描述-68">【描述】</a></h3>
<p>需要结合场景和业务来考虑如果发生溢出、回绕或截断的时候，是否会引起严重的问题。</p>
<p>比如，对于时间要求精准的系统，如果在计算时间发生整数溢出，或者去计算某个数组的索引等，那可能会发生严重问题。但如果你只是一个简单的计算器，不会被用到具体的业务场合，那溢出也没有关系，因为你只需要在合理的数字范围内计算性能最好。</p>
<p>在 Rust 标准库中，提供 <code>add</code>/ <code>checked_add</code> / <code> saturating_add</code>/<code>overflowing_add</code> / <code>wrapping_add</code> 不同系列方法，返回值不同，根据不同的场合选择适合的方法。</p>
<ol>
<li><code>check_*</code>函数返回<code>Option</code>，一旦发生溢出则返回None。</li>
<li><code>saturating_*</code>系列函数返回类型是整数，如果溢出，则给出该类型可表示范围的“最大/最小”值。</li>
<li><code>wrapping_*</code>系列函数则是直接抛弃已经溢出的最高位，将剩下的部分返回。</li>
</ol>
<p>Rust 编译器在编译时默认没有溢出检查（可通过编译参数来引入），但在运行时会有 Rust 内置 lint (<code>#[deny(arithmetic_overflow)]</code>)来检查，如果有溢出会 Panic。</p>
<p>无符号整数使用时要注意回绕(wrap around)，不同整数类型转换时需注意截断。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!((-5i32).checked_abs(), Some(5));
assert_eq!(100i32.saturating_add(1), 101);
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!((-5i32).abs(), 5);
assert_eq!(100i32+1, 101);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gtypint02-对于大整数字面量使用十六进制表示比十进制更好" id="gtypint02-对于大整数字面量使用十六进制表示比十进制更好">G.TYP.INT.02 对于大整数字面量使用十六进制表示比十进制更好</a></h2>
<h3><a class="header" href="#级别建议-47" id="级别建议-47">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-39" id="lint-检测-39">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#decimal_literal_representation">decimal_literal_representation</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-69" id="描述-69">【描述】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = `0xFF`
let b = `0xFFFF`
let c = `0xF0F0_F0F0
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = `255` 
let b = `65_535`
let c =`4_042_322_160` 
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gtypint03--避免将有符号整数和无符号整数之间强制转换" id="gtypint03--避免将有符号整数和无符号整数之间强制转换">G.TYP.INT.03  避免将有符号整数和无符号整数之间强制转换</a></h2>
<h3><a class="header" href="#级别建议-48" id="级别建议-48">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-40" id="lint-检测-40">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cast_sign_loss">cast_sign_loss</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<p>注意：默认情况下该 lint 是<code> allow</code>，如果需要检查这种转换，则需要设置为 <code>warn</code>或 <code>deny</code>。</p>
<h3><a class="header" href="#描述-70" id="描述-70">【描述】</a></h3>
<p>当有符号整数被强制转换为无符号整数时，负值会发生回绕，变成更大的正值，这在实际应用时有可能助长缓冲区溢出风险。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let y : i8 = -1;
// Error: 
// the trait `From&lt;i8&gt;` is not implemented for `u128`
// the trait bound `u128: From&lt;i8&gt;` is not satisfied
let z = u128::from(y);
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let y: i8 = -1;
y as u128; // will return 18446744073709551615
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gtypint04--对负数取模计算的时候不要使用-" id="gtypint04--对负数取模计算的时候不要使用-">G.TYP.INT.04  对负数取模计算的时候不要使用 <code>%</code></a></h2>
<h3><a class="header" href="#级别建议-49" id="级别建议-49">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-41" id="lint-检测-41">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#modulo_arithmetic">modulo_arithmetic</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-71" id="描述-71">【描述】</a></h3>
<p>Rust 当前的这个 <code>%</code>形式是余数运算符，它的行为与<code>C</code>或<code>Java</code>等语言中相同符号的运算符相同。它也类似于<code>Python</code>或<code>Haskell</code>等语言中的模（modulo）运算符，只是它对 负数 的行为不同：余数是基于截断除法，而模运算是基于向下取整（floor）除法。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a: i32 = -1;
    let b: i32 = 6;
	//  取模是严格低于第二个操作数的自然数（所以是非负数），与第二个操作数的最大倍数相加，也低于或等于第一个操作数，则为第一个操作数。
    //  6的最大倍数低于或等于-1 是 -6（6*-1），模数是5，因为-6+5=-1。
    assert_eq!(a.rem_euclid(b), 5);
}
</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a: i32 = -1;
    let b: i32 = 6;
    // 余数运算符只是返回第一个操作数除以第二个操作数的余数。所以 -1/6 给出 0，余数为 -1
    assert_eq!(a % b, -1);
}
</code></pre></pre>
<h1><a class="header" href="#浮点数" id="浮点数">浮点数</a></h1>
<p>Rust 的浮点数包括 <code>f32</code> 和 <code>f64</code> 两种类型。Rust 编译器默认推断的 Float 类型是 <code>f64</code>。</p>
<hr />
<h2><a class="header" href="#gtypfloat01----使用-f32-字面量时小心被-rust-编译器截断" id="gtypfloat01----使用-f32-字面量时小心被-rust-编译器截断">G.TYP.Float.01    使用 <code>f32</code> 字面量时，小心被 Rust 编译器截断</a></h2>
<h3><a class="header" href="#级别建议-50" id="级别建议-50">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-42" id="lint-检测-42">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#excessive_precision">excessive_precision</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-72" id="描述-72">【描述】</a></h3>
<p>当指定超过 <code>f32</code> 精度的字面量值时，Rust 会默认截断该值。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: f64 = 0.123_456_789_9;
println!(&quot;{}&quot;, v); //  0.123_456_789_9
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: f32 = 0.123_456_789_9;
println!(&quot;{}&quot;, v); //  0.123_456_789
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gtypfloat02----当从任何数字类型转换为-f64类型时需要注意是否会损失精度" id="gtypfloat02----当从任何数字类型转换为-f64类型时需要注意是否会损失精度">G.TYP.Float.02    当从任何数字类型转换为 <code>f64</code>类型时需要注意是否会损失精度</a></h2>
<h3><a class="header" href="#级别建议-51" id="级别建议-51">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-43" id="lint-检测-43">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cast_precision_loss">cast_precision_loss</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-73" id="描述-73">【描述】</a></h3>
<p>这种转换可能会有值的舍入错误发生。在某些对于精度要求比较高的场景需要注意。</p>
<p>【示例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = u64::MAX;
x as f64; // 18446744073709551615
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gtypfloat03-----不要对浮点数进行运算和比较" id="gtypfloat03-----不要对浮点数进行运算和比较">G.TYP.Float.03     不要对浮点数进行运算和比较</a></h2>
<h3><a class="header" href="#级别建议-52" id="级别建议-52">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-44" id="lint-检测-44">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#float_arithmetic">float_arithmetic</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#float_cmp">float_cmp</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#float_cmp_const">float_cmp_const</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#float_equality_without_abs">float_equality_without_abs</a></td><td>yes</td><td>no</td><td>suspicious</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-74" id="描述-74">【描述】</a></h3>
<p>浮点数计算通常都是不精确的，直接对浮点数进行运算和比较都是自找麻烦。 如何更好地处理浮点数，可以参阅 <a href="https://floating-point-gui.de/">浮点数指南</a> 。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1.2331f64;
let y = 1.2332f64;

let error_margin = f64::EPSILON; // Use an epsilon for comparison
// Or, if Rust &lt;= 1.42, use `std::f64::EPSILON` constant instead.
// let error_margin = std::f64::EPSILON;
if (y - 1.23f64).abs() &lt; error_margin { }
if (y - x).abs() &gt; error_margin { }

// or
pub fn is_roughly_equal(a: f32, b: f32) -&gt; bool {
    (a - b).abs() &lt; f32::EPSILON
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1.2331f64;
let y = 1.2332f64;

if y == 1.23f64 { }
if y != x {} // where both are floats

// or
pub fn is_roughly_equal(a: f32, b: f32) -&gt; bool {
    (a - b) &lt; f32::EPSILON
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gtypfloat04----尽量使用-rust-内置方法来处理浮点数计算" id="gtypfloat04----尽量使用-rust-内置方法来处理浮点数计算">G.TYP.Float.04    尽量使用 Rust 内置方法来处理浮点数计算</a></h2>
<h3><a class="header" href="#级别建议-53" id="级别建议-53">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-45" id="lint-检测-45">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#imprecise_flops">imprecise_flops</a></td><td>yes</td><td>no</td><td>nursery</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#suboptimal_flops">suboptimal_flops</a></td><td>yes</td><td>no</td><td>nursery</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-75" id="描述-75">【描述】</a></h3>
<p>内置方法会牺牲一定性能，但它可以提升准确性。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 3f32;
let _ = a.cbrt();
let _ = a.ln_1p();
let _ = a.exp_m1();

use std::f32::consts::E;

let a = 3f32;
let _ = a.exp2();
let _ = a.exp();
let _ = a.sqrt();
let _ = a.log2();
let _ = a.log10();
let _ = a.ln();
let _ = a.powi(2);
let _ = a.mul_add(2.0, 4.0);
let _ = a.abs();
let _ = -a.abs();
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 3f32;
let _ = a.powf(1.0 / 3.0);
let _ = (1.0 + a).ln();
let _ = a.exp() - 1.0;

use std::f32::consts::E;

let a = 3f32;
let _ = (2f32).powf(a);
let _ = E.powf(a);
let _ = a.powf(1.0 / 2.0);
let _ = a.log(2.0);
let _ = a.log(10.0);
let _ = a.log(E);
let _ = a.powf(2.0);
let _ = a * 2.0 + 4.0;
let _ = if a &lt; 0.0 {
    -a
} else {
    a
};
let _ = if a &lt; 0.0 {
    a
} else {
    -a
};
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gtypfloat05----在定义f32浮点数字面量时要注意它会损失精度尽量使用-f64-类型" id="gtypfloat05----在定义f32浮点数字面量时要注意它会损失精度尽量使用-f64-类型">G.TYP.Float.05    在定义<code>f32</code>浮点数字面量时，要注意它会损失精度，尽量使用 <code>f64</code> 类型</a></h2>
<h3><a class="header" href="#级别建议-54" id="级别建议-54">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-46" id="lint-检测-46">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#imprecise_flops">imprecise_flops</a></td><td>yes</td><td>no</td><td>nursery</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-76" id="描述-76">【描述】</a></h3>
<p>在 <code>f32</code> 浮点数字面量在定义时，将会损失精度，应该尽量使用 <code>f64</code> 类型。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x : f64 = 16_777_217.0;
assert_eq!(16777217.0, x);
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x : f32 = 16_777_217.0;
assert_eq!(16777216.0, x);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gtypfloat06-----浮点数和整数之间转换时不要使用-transmute" id="gtypfloat06-----浮点数和整数之间转换时不要使用-transmute">G.TYP.Float.06     浮点数和整数之间转换时不要使用 <code>transmute</code></a></h2>
<h3><a class="header" href="#级别建议-55" id="级别建议-55">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-47" id="lint-检测-47">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#transmute_float_to_int">transmute_float_to_int</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#transmute_int_to_float">transmute_int_to_float</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-77" id="描述-77">【描述】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _: f32 = f32::from_bits(1_u32);
let _: u32 = 1f32.to_bits();
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
    let _: u32 = std::mem::transmute(1f32);
    let _: f32 = std::mem::transmute(1_u32); // where x: u32
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#引用" id="引用">引用</a></h1>
<p>在 Rust 中，引用就是有借用检查的指针，就像穿着“安全的外衣”。指针，没有借用检查，所以也叫裸指针。</p>
<p>Rust 编译器总是希望引用是非空且对齐的。</p>
<hr />
<h2><a class="header" href="#pref01--使用引用的时候要注意其生命周期不要重合" id="pref01--使用引用的时候要注意其生命周期不要重合">P.REF.01  使用引用的时候要注意其生命周期不要重合</a></h2>
<p>【描述】</p>
<p>在使用 引用的时候，要注意分析其生命周期，不可变借用和可变借用之间，以及可变借用之间不要有重叠。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">fn main(){
    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // no problem
    let r2 = &amp;mut s; // no problem
    let r3 = &amp;mut s; // no PROBLEM

    // println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
    
}
</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">fn main(){
    let mut s = String::from(&quot;hello&quot;);
    // r1 是不可变借用，其生命周期和 可变借用 r3 重叠，所以会出问题
    let r1 = &amp;s; // no problem    ---------------- lifetime r1 start
    let r2 = &amp;mut s; // no problem
    let r3 = &amp;mut s; // BIG PROBLEM -------------- lifetime r3 start 

    println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);  //  lifetime r1, r2, r3  end; 
    
}
</code></pre></pre>
<h1><a class="header" href="#切片" id="切片">切片</a></h1>
<p>切片（slice）允许开发者引用集合中连续的元素序列，类型签名用 <code>[T]</code>表示，但因为它是动态大小类型（DST），所以一般用 <code>&amp;[T]</code> 表示切片。</p>
<p><code>&amp;str</code> 就是一种字符串切片。</p>
<hr />
<h2><a class="header" href="#ptypslice01---利用切片迭代器来代替手工索引" id="ptypslice01---利用切片迭代器来代替手工索引">P.TYP.Slice.01   利用切片迭代器来代替手工索引</a></h2>
<p><strong>【描述】</strong></p>
<p>在 for 循环中使用索引是比较常见的编程习惯，但是这种方式是最有可能导致边界错误的。</p>
<p>利用 切片自带的方法，并利用迭代器，可以避免这种错误。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let points: Vec&lt;Coordinate&gt; = ...;
let mut differences = Vec::new();

// 切片提供 windows 或 array_windows 方法返回迭代器
for [previous, current] in points.array_windows().copied() {
    differences.push(current - previous);
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let points: Vec&lt;Coordinate&gt; = ...;
let differences = Vec::new();

// 人工计算长度选择范围很可能会出错
for i in 1..points.len() [
  let current = points[i];
  let previous = points[i-1];
  differences.push(current - previous);
]
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#ptypslice02----可以利用切片模式来提升代码的可读性" id="ptypslice02----可以利用切片模式来提升代码的可读性">P.TYP.Slice.02    可以利用切片模式来提升代码的可读性</a></h2>
<p>【描述】</p>
<p>切片也支持模式匹配，适当应用切片模式，可以有效提升代码可读性。</p>
<p>【正例】</p>
<p>利用切片模式编写判断回文字符串的函数。代码来自于：<a href="https://adventures.michaelfbryan.com/posts/daily/slice-patterns/#matching-the-start-of-a-slice">Daily Rust: Slice Patterns</a>  ，还有更多用例。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn word_is_palindrome(word: &amp;str) -&gt; bool {
    let letters: Vec&lt;_&gt; = word.chars().collect();

    is_palindrome(&amp;letters)
}
// 利用切片模式匹配来判断是否回文字符串
fn is_palindrome(items: &amp;[char]) -&gt; bool {
    match items {
        [first, middle @ .., last] =&gt; first == last &amp;&amp; is_palindrome(middle),
        [] | [_] =&gt; true,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn known_palindromes() {
        assert!(word_is_palindrome(&quot;&quot;));
        assert!(word_is_palindrome(&quot;a&quot;));
        assert!(word_is_palindrome(&quot;aba&quot;));
        assert!(word_is_palindrome(&quot;abba&quot;));
    }

    #[test]
    fn not_palindromes() {
        assert!(!word_is_palindrome(&quot;abc&quot;));
        assert!(!word_is_palindrome(&quot;abab&quot;));
    }
}

<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#元组" id="元组">元组</a></h1>
<p>元组是异构复合类型，可以存储多个不同的值。</p>
<hr />
<h2><a class="header" href="#ptyptuple01--可以使用元组解构来同时定义多个变量" id="ptyptuple01--可以使用元组解构来同时定义多个变量">P.TYP.Tuple.01  可以使用元组解构来同时定义多个变量</a></h2>
<p>【描述】</p>
<p>可以利用元组解构的特性，来更好地精简代码。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">struct A(i32, i32);

fn hello( A(a, b): A){
    println!(&quot;{}, {}&quot;, a, b);
}

fn main(){
    let a = A(1, 2) ;
    hello(a);
}
</code></pre></pre>
<h2><a class="header" href="#gtyptuple01--使用元组时其元素最多不要超过3个" id="gtyptuple01--使用元组时其元素最多不要超过3个">G.TYP.Tuple.01  使用元组时，其元素最多不要超过3个</a></h2>
<h3><a class="header" href="#级别建议-56" id="级别建议-56">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint检测-1" id="lint检测-1">【Lint检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制化参考】</p>
<p>可以检测元组中元素个数，如果超过 3 个，发出警告或建议。并且可以支持配置允许个数。</p>
<p><strong>【描述】</strong></p>
<p>元组是异构复合类型，元素过多，其表达力会下降，影响代码可读性和可维护性。</p>
<p>尤其是利用元组作为函数返回值时，不宜过多。</p>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">fn convert(x: i8) -&gt; (i8, i16, i32, i64, f32, f64) {
    (x as i8, x as i16, x as i32, 
     x as i64, x as f32, x as f64)
}

fn main(){
    let _ = convert(3);
}
</code></pre></pre>
<h1><a class="header" href="#数组-1" id="数组-1">数组</a></h1>
<p>这里指固定长度数组。注意，不同长度的数组，类型是不一样的。比如 <code>[T;1]</code>和 <code>[T;3]</code> 就是不同类型。</p>
<p>从  Rust 1.51 版本开始，稳定了 常量泛型（const generics）功能，形如  <code>[T;1]</code>和 <code>[T;3]</code> 这种不同的类型可以统一为 <code>[T; N]</code>。</p>
<hr />
<h2><a class="header" href="#ptyparray01-当数组长度在编译期就已经确定应该优先使用固定长度数组而非动态数组-vect" id="ptyparray01-当数组长度在编译期就已经确定应该优先使用固定长度数组而非动态数组-vect">P.TYP.Array.01 当数组长度在编译期就已经确定，应该优先使用固定长度数组，而非动态数组（ <code>Vec&lt;T&gt;</code>）</a></h2>
<p>【描述】</p>
<p>固定长度数组会根据元素类型，优先选择存储在栈上，可以优化内存分配。</p>
<p>当编译期长度可以确定，但长度并不是唯一确定的，那么可以考虑使用常量泛型。注意：常量泛型特性从 Rust 1.51版稳定。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Grid {
    array: [u32; 5],
    width: usize,
    height: usize,
}
<span class="boring">}
</span></code></pre></pre>
<p>常量泛型：</p>
<pre><pre class="playground"><code class="language-rust">pub struct Grid&lt;T, const W: usize, const H: usize&gt;
where
{
    array: [[T; W]; H],
}

impl&lt;T, const W: usize, const H: usize&gt; Default for Grid&lt;T, W, H&gt;
where
    T: Default + Copy,
{
    fn default() -&gt; Self {
        Self {
            array: [[T::default(); W ]; H],
        }
    }
}

const WIDTH: usize = 300;
const HEIGHT: usize = 200;

fn main(){
    let _g = Grid::&lt;usize, 3, 4&gt;::default();  
    let _h = Grid::&lt;usize, WIDTH, HEIGHT&gt;::default();
}
</code></pre></pre>
<p>注意，常量泛型目前还有一些特性并未完善，比如下面示例中的 <code>#![feature(generic_const_exprs)]</code> 特性，需要在 Nightly Rust 下使用。</p>
<pre><pre class="playground"><code class="language-rust">#![feature(generic_const_exprs)]
pub struct Grid&lt;T, const W: usize, const H: usize&gt;
where
    [(); W * H]: Sized,
{
    array: [T; W * H],
}

impl&lt;T, const W: usize, const H: usize&gt; Default for Grid&lt;T, W, H&gt;
where
    [(); W * H]: Sized,
    T: Default + Copy,
{
    fn default() -&gt; Self {
        Self {
            array: [T::default(); W * H],
        }
    }
}

const WIDTH: usize = 300;
const HEIGHT: usize = 200;

fn main(){
    let _g = Grid::&lt;usize, 3, 4&gt;::default();  
    let _h = Grid::&lt;usize, WIDTH, HEIGHT&gt;::default();
}

</code></pre></pre>
<hr />
<h2><a class="header" href="#gtyparray01-当创建大的全局数组时应该使用静态变量而非常量" id="gtyparray01-当创建大的全局数组时应该使用静态变量而非常量">G.TYP.Array.01 当创建大的全局数组时应该使用静态变量而非常量</a></h2>
<h3><a class="header" href="#级别建议-57" id="级别建议-57">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-48" id="lint-检测-48">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#large_const_arrays">large_const_arrays</a></td><td>yes</td><td>no</td><td>perf</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#large_stack_arrays">large_stack_arrays</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<p>注意： <code>large_stack_arrays</code> 会检查在栈上分配的大数组，但clippy默认是 allow，根据实际使用场景决定是否针对这种情况发出警告。</p>
<h3><a class="header" href="#描述-78" id="描述-78">【描述】</a></h3>
<p>因为常量会内联，对于大的数组，使用静态变量定义更好。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub static A: [u32;1_000_000] = [0u32; 1_000_000];
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const A: [u32;1_000_000] = [0u32; 1_000_000];
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gtyparray02--使用数组索引时不要越界访问" id="gtyparray02--使用数组索引时不要越界访问">G.TYP.Array.02  使用数组索引时不要越界访问</a></h2>
<h3><a class="header" href="#级别建议-58" id="级别建议-58">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-49" id="lint-检测-49">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#out_of_bounds_indexing">out_of_bounds_indexing</a></td><td>yes</td><td>no</td><td><strong>correctness</strong></td><td>deny</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-79" id="描述-79">【描述】</a></h3>
<p>越界访问在运行时会 Panic！</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = [1, 2, 3, 4];
x[0];
x[3];
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = [1, 2, 3, 4];
x[9];
&amp;x[2..9];
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gtyparray03--当数组元素为原生数据类型primitive的值时对其排序应该优先考虑非稳定排序" id="gtyparray03--当数组元素为原生数据类型primitive的值时对其排序应该优先考虑非稳定排序">G.TYP.Array.03  当数组元素为原生数据类型（Primitive）的值时，对其排序应该优先考虑非稳定排序</a></h2>
<h3><a class="header" href="#级别建议-59" id="级别建议-59">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-50" id="lint-检测-50">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#stable_sort_primitive">stable_sort_primitive</a></td><td>yes</td><td>no</td><td><strong>perf</strong></td><td>warn</td></tr>
</tbody></table>
<p>当确实需要稳定排序时，需要修改该 lint 的设置为 <code>allow</code>。</p>
<h3><a class="header" href="#描述-80" id="描述-80">【描述】</a></h3>
<p>因为稳定排序会消耗更多的内存和 CPU 周期，相对而言，非稳定排序性能更佳。</p>
<p>当然，在必须要稳定排序的场合，不应该使用非稳定排序。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut vec = vec![2, 1, 3];
vec.sort_unstable(); // unstable sort
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut vec = vec![2, 1, 3];
vec.sort();  // stable sort
<span class="boring">}
</span></code></pre></pre>
<p>【例外】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// https://docs.rs/crate/solana-runtime/1.7.11/source/src/accounts_db.rs#:~:text=clippy%3a%3astable_sort_primitive
 pub fn generate_index(&amp;self, limit_load_slot_count_from_snapshot: Option&lt;usize&gt;) {
        let mut slots = self.storage.all_slots();
        #[allow(clippy::stable_sort_primitive)]
        slots.sort(); // The business requirement here is to use stable sort 
        // ...
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#动态数组" id="动态数组">动态数组</a></h1>
<p>这里指可以动态增长的数组<code>Vec&lt;T&gt;</code>。</p>
<p>在数组一节中有<a href="safe-guides/coding_practice/data-type/./array.html">部分原则和规则</a>也适用于这里。</p>
<hr />
<h2><a class="header" href="#ptypvec01-非必要不要使用动态数组" id="ptypvec01-非必要不要使用动态数组">P.TYP.Vec.01 非必要不要使用动态数组</a></h2>
<p>【描述】</p>
<p>相关原则参见数组一节中有<a href="safe-guides/coding_practice/data-type/./array.html">对应原则</a>，非必须不要使用 <code>Vec&lt;T&gt;</code>，应该优先尝试使用固定长度数组或常量泛型。</p>
<h2><a class="header" href="#ptypvec02---创建动态数组时可以预先分配大约足够的容量来避免后续操作中产生多次分配" id="ptypvec02---创建动态数组时可以预先分配大约足够的容量来避免后续操作中产生多次分配">P.TYP.Vec.02   创建动态数组时，可以预先分配大约足够的容量来避免后续操作中产生多次分配</a></h2>
<p><strong>【描述】</strong></p>
<p>预分配足够的容量，避免后续内存分配，可以提升代码性能。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut output = Vec::with_capacity(input.len());
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut output = Vec::new();
<span class="boring">}
</span></code></pre></pre>
<hr />
<h2><a class="header" href="#gtypvec01--禁止访问还未初始化的数组" id="gtypvec01--禁止访问还未初始化的数组">G.TYP.Vec.01  禁止访问还未初始化的数组</a></h2>
<h3><a class="header" href="#级别建议-60" id="级别建议-60">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-51" id="lint-检测-51">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#uninit_vec">uninit_vec</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-81" id="描述-81">【描述】</a></h3>
<p>访问未初始化数组的内存会导致 未定义行为。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut vec: Vec&lt;u8&gt; = vec![0; 1000];
reader.read(&amp;mut vec);

// or
let mut vec: Vec&lt;MaybeUninit&lt;T&gt;&gt; = Vec::with_capacity(1000);
vec.set_len(1000);  // `MaybeUninit` can be uninitialized

// or
let mut vec: Vec&lt;u8&gt; = Vec::with_capacity(1000);
let remaining = vec.spare_capacity_mut();  // `&amp;mut [MaybeUninit&lt;u8&gt;]`
// perform initialization with `remaining`
vec.set_len(...);  // Safe to call `set_len()` on initialized part
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut vec: Vec&lt;u8&gt; = Vec::with_capacity(1000);
unsafe { vec.set_len(1000); }
reader.read(&amp;mut vec); // error: Undefined Behavior: using uninitialized data, but this operation requires initialized memory
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#结构体-1" id="结构体-1">结构体</a></h1>
<p>Rust 包含了三种结构体： 命名结构体、元组结构体、单元结构体。</p>
<hr />
<h2><a class="header" href="#ptypstruct01-为结构体实现构造性方法时应该避免构造后再初始化的情况" id="ptypstruct01-为结构体实现构造性方法时应该避免构造后再初始化的情况">P.TYP.Struct.01 为结构体实现构造性方法时，应该避免构造后再初始化的情况</a></h2>
<p><strong>【描述】</strong></p>
<p>跟其他OOP 或 FP 语言不一样， Rust 的惯用方式是构建即初始化。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 构建即初始化
let dict = Dictionary::from_file(&quot;./words.txt&quot;)?;

impl Dictionary {
  fn from_file(filename: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Self, Error&gt; {
    let text = std::fs::read_to_string(filename)?;
    // 不会去存储空状态
    let mut words = Vec::new();
    for line in text.lines() {
      words.push(line);
    }
    Ok(Dictionary { words })
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 先构建
let mut dict = Dictionary::new();
// 后初始化
dict.load_from_file(&quot;./words.txt&quot;)?;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#ptypstruct02--当你需要很多构造函数或者构造时有很多可选配置项时建议使用-构建者模式" id="ptypstruct02--当你需要很多构造函数或者构造时有很多可选配置项时建议使用-构建者模式">P.TYP.Struct.02  当你需要很多构造函数，或者构造时有很多可选配置项时，建议使用 构建者模式</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 中没有默认的构造函数，都是自定义构造函数。</p>
<p>如果需要多个构造函数，或者构造时需要很多可选配置的复杂场景，那么构建者模式是适合你的选择。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, PartialEq)]
pub struct Foo {
    // Lots of complicated fields.
    bar: String,
}

impl Foo {
    // This method will help users to discover the builder
    pub fn builder() -&gt; FooBuilder {
        FooBuilder::default()
    }
}

#[derive(Default)]
pub struct FooBuilder {
    // Probably lots of optional fields.
    bar: String,
}

impl FooBuilder {
    pub fn new(/* ... */) -&gt; FooBuilder {
        // Set the minimally required fields of Foo.
        FooBuilder {
            bar: String::from(&quot;X&quot;),
        }
    }

    pub fn name(mut self, bar: String) -&gt; FooBuilder {
        // Set the name on the builder itself, and return the builder by value.
        self.bar = bar;
        self
    }

    // If we can get away with not consuming the Builder here, that is an
    // advantage. It means we can use the FooBuilder as a template for constructing
    // many Foos.
    pub fn build(self) -&gt; Foo {
        // Create a Foo from the FooBuilder, applying all settings in FooBuilder
        // to Foo.
        Foo { bar: self.bar }
    }
}

#[test]
fn builder_test() {
    let foo = Foo {
        bar: String::from(&quot;Y&quot;),
    };
    let foo_from_builder: Foo = FooBuilder::new().name(String::from(&quot;Y&quot;)).build();
    assert_eq!(foo, foo_from_builder);
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#ptypstruct03--结构体实例需要默认实现时建议为其实现-default" id="ptypstruct03--结构体实例需要默认实现时建议为其实现-default">P.TYP.Struct.03  结构体实例需要默认实现时，建议为其实现 <code>Default</code></a></h2>
<p><strong>【描述】</strong></p>
<p>为结构体实现 <code>Default</code> 对于简化代码提高可读性很有帮助。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">use std::{path::PathBuf, time::Duration};

// note that we can simply auto-derive Default here.
#[derive(Default, Debug, PartialEq)]
struct MyConfiguration {
    // Option defaults to None
    output: Option&lt;PathBuf&gt;,
    // Vecs default to empty vector
    search_path: Vec&lt;PathBuf&gt;,
    // Duration defaults to zero time
    timeout: Duration,
    // bool defaults to false
    check: bool,
}

impl MyConfiguration {
    // add setters here
}

fn main() {
    // construct a new instance with default values
    let mut conf = MyConfiguration::default();
    // do something with conf here
    conf.check = true;
    println!(&quot;conf = {:#?}&quot;, conf);
        
    // partial initialization with default values, creates the same instance
    let conf1 = MyConfiguration {
        check: true,
        ..Default::default()
    };
    assert_eq!(conf, conf1);
}
</code></pre></pre>
<hr />
<h2><a class="header" href="#gtypstruct01----对外导出的公开的-struct建议增加-non_exhaustive属性" id="gtypstruct01----对外导出的公开的-struct建议增加-non_exhaustive属性">G.TYP.Struct.01    对外导出的公开的 Struct，建议增加 <code>#[non_exhaustive]</code>属性</a></h2>
<h3><a class="header" href="#级别建议-61" id="级别建议-61">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-52" id="lint-检测-52">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#exhaustive_structs">exhaustive_structs</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#manual_non_exhaustive">manual_non_exhaustive</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-82" id="描述-82">【描述】</a></h3>
<p>作为对外公开的 结构体，为了保持稳定性，应该使用 <code>#[non_exhaustive]</code>属性，避免因为将来结构体字段发生变化而影响到下游的使用。主要涉及命名结构体和元组结构体。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[non_exhaustive]
struct Foo {
    bar: u8,
    baz: String,
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<p>在 <code>#[non_exhaustive]</code> 属性稳定之前，社区内还有一种约定俗成的写法来达到防止下游自定义枚举方法。通过 <code>manual_non_exhaustive</code> 可以监控这类写法。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S {
    pub a: i32,
    pub b: i32,
    _priv: (),  // 这里用 下划线作为前缀定义的字段，作为私有字段，不对外公开
}

// 用户无法自定义实现该结构体的方法。
<span class="boring">}
</span></code></pre></pre>
<p>【例外】</p>
<p>也有例外情况！</p>
<p>从语义角度看，<code>#[non_exhaustive]</code> 只是代表未穷尽的字段或枚举变体，是为了表达“未来可能有变化”这种语义。</p>
<p>但是当要表达 “这个结构体不允许对方实例化” 的语义时，通过自定义的 <code>_priv</code>字段就可以更好地表达这个语义。</p>
<p>而使用 <code>#[non_exhaustive]</code> 虽然也能达到 “不允许对方实例化的目的”，但是在代码可读性层面，却无法表达出这个语义。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From: https://github.com/tokio-rs/tokio/blob/master/tokio-util/src/codec/framed.rs

#[allow(clippy::manual_non_exhaustive)]
pub struct FramedParts&lt;T, U&gt; {
    pub io: T,
    pub codec: U,
    pub read_buf: BytesMut,
    pub write_buf: BytesMut,
    
    /// This private field allows us to add additional fields in the future in a
    /// backwards compatible way.
    _priv: (),
}

impl&lt;T, U&gt; FramedParts&lt;T, U&gt; {
    /// Create a new, default, `FramedParts`
    pub fn new&lt;I&gt;(io: T, codec: U) -&gt; FramedParts&lt;T, U&gt;
    where
        U: Encoder&lt;I&gt;,
    {
        FramedParts {
            io,
            codec,
            read_buf: BytesMut::new(),
            write_buf: BytesMut::new(),
            _priv: (),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gtypstruct02--结构体中有超过三个布尔类型的字段建议将其独立为一个枚举" id="gtypstruct02--结构体中有超过三个布尔类型的字段建议将其独立为一个枚举">G.TYP.Struct.02  结构体中有超过三个布尔类型的字段，建议将其独立为一个枚举</a></h2>
<h3><a class="header" href="#级别建议-62" id="级别建议-62">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-53" id="lint-检测-53">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#struct_excessive_bools">struct_excessive_bools</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<p>该 lint 对应 <code>clippy.toml</code> 配置项：</p>
<pre><code class="language-toml"># 用于配置函数可以拥有的 bool 类型参数最大数量，默认为 3。
max-struct-bools=3 
</code></pre>
<h3><a class="header" href="#描述-83" id="描述-83">【描述】</a></h3>
<p>这样有助于提升 代码可读性和 API 。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum S {
    Pending,
    Processing,
    Finished,
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S {
    is_pending: bool,
    is_processing: bool,
    is_finished: bool,
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gtypstruct03----善用结构体功能更新语法来提升代码可读性" id="gtypstruct03----善用结构体功能更新语法来提升代码可读性">G.TYP.Struct.03    善用结构体功能更新语法来提升代码可读性</a></h2>
<h3><a class="header" href="#级别建议-63" id="级别建议-63">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-54" id="lint-检测-54">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#field_reassign_with_default">field_reassign_with_default</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-84" id="描述-84">【描述】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = A {
    i: 42,
    .. Default::default()
};
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut a: A = Default::default();
a.i = 42;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#枚举体" id="枚举体">枚举体</a></h1>
<p>Rust 的枚举是一种带 Tag 的联合体。 一般分为三类：空枚举、无字段（fieldless）枚举和数据承载（data carrying）枚举。</p>
<p>【示例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Empty {}

enum Fieldless {
    A,
    B,
    C = 42, // 可以自定义判别式
}

enum DataCarrying {
    Foo(i32, i32),
    Bar(String)
}
<span class="boring">}
</span></code></pre></pre>
<p>Rust 中枚举体用处很多，你甚至可以将其作为一种接口使用。</p>
<hr />
<h2><a class="header" href="#ptypenum01-修改-enum-中值的时候建议使用-stdmemtake" id="ptypenum01-修改-enum-中值的时候建议使用-stdmemtake">P.TYP.Enum.01 修改 Enum 中值的时候建议使用 <code>std::mem::take</code></a></h2>
<p><strong>【描述】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem;

enum MultiVariateEnum {
    A { name: String },
    B { name: String },
    C,
    D
}

fn swizzle(e: &amp;mut MultiVariateEnum) {
    use MultiVariateEnum::*;
    *e = match e {
        // Ownership rules do not allow taking `name` by value, but we cannot
        // take the value out of a mutable reference, unless we replace it:
        A { name } =&gt; B { name: mem::take(name) },
        B { name } =&gt; A { name: mem::take(name) },
        C =&gt; D,
        D =&gt; C
    }
}
<span class="boring">}
</span></code></pre></pre>
<hr />
<h2><a class="header" href="#gtypenum01-要避免使用and_then而使用map" id="gtypenum01-要避免使用and_then而使用map">G.TYP.Enum.01 要避免使用<code>and_then</code>而使用<code>map</code></a></h2>
<h3><a class="header" href="#级别建议-64" id="级别建议-64">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-55" id="lint-检测-55">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#bind_instead_of_map">bind_instead_of_map </a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-85" id="描述-85">【描述】</a></h3>
<p>为了让代码更加简单明了增强可读性，建议使用 <code>map</code>。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn opt() -&gt; Option&lt;&amp;'static str&gt; { Some(&quot;42&quot;) }
</span><span class="boring">fn res() -&gt; Result&lt;&amp;'static str, &amp;'static str&gt; { Ok(&quot;42&quot;) }
</span>let _ = opt().map(|s| s.len());
let _ = res().map(|s| if s.len() == 42 { 10 } else { 20 });
let _ = res().map_err(|s| if s.len() == 42 { 10 } else { 20 });
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn opt() -&gt; Option&lt;&amp;'static str&gt; { Some(&quot;42&quot;) }
</span><span class="boring">fn res() -&gt; Result&lt;&amp;'static str, &amp;'static str&gt; { Ok(&quot;42&quot;) }
</span>let _ = opt().and_then(|s| Some(s.len()));
let _ = res().and_then(|s| if s.len() == 42 { Ok(10) } else { Ok(20) });
let _ = res().or_else(|s| if s.len() == 42 { Err(10) } else { Err(20) });

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gtypenum02--除非必要不要自己创建空枚举" id="gtypenum02--除非必要不要自己创建空枚举">G.TYP.Enum.02  除非必要，不要自己创建空枚举</a></h2>
<h3><a class="header" href="#级别建议-65" id="级别建议-65">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-56" id="lint-检测-56">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#empty_enum">empty_enum</a></td><td>yes</td><td>no</td><td><strong>pedantic</strong></td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-86" id="描述-86">【描述】</a></h3>
<p>在 Rust 中 只有 <code>never</code> 类型（<code>!</code>）才是唯一合法表达 无法被实例化类型 的类型。但目前 <code>never</code> 类型还未稳定，只能在 Nightly 下使用。</p>
<p>【正例】</p>
<p>所以，如果想在 稳定版 Rust 中使用，建议使用<a href="https://doc.rust-lang.org/std/convert/enum.Infallible.html#"><code>std::convert::Infallible</code></a> 。 <code>Infallible</code> 枚举是一个合法的 空枚举，常用于错误处理中，表示永远不可能出现的错误。但是目前也可以用于在稳定版中替代  <code>never</code>   类型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 未来 never 类型稳定的话，将会把 Infallible 设置为 never 类型的别名
pub type Infallible = !;
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Test {}
<span class="boring">}
</span></code></pre></pre>
<p>【例外】</p>
<p>因为 <a href="https://doc.rust-lang.org/std/convert/enum.Infallible.html#"><code>std::convert::Infallible</code></a> 默认实现了很多 trait，如果不想依赖其他 trait ，那么可以用 空枚举。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum NoUserError {}

impl Display for NoUserError {
    fn fmt(&amp;self, _formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match *self {}
    }
}

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gtypenum03--在使用类似-c-语言的枚举写法且使用reprisizeusize-布局时要注意-32位架构上截断的问题" id="gtypenum03--在使用类似-c-语言的枚举写法且使用reprisizeusize-布局时要注意-32位架构上截断的问题">G.TYP.Enum.03  在使用类似 C 语言的枚举写法且使用<code>repr(isize/usize)</code> 布局时要注意 32位架构上截断的问题</a></h2>
<h3><a class="header" href="#级别建议-66" id="级别建议-66">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-57" id="lint-检测-57">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#enum_clike_unportable_variant">enum_clike_unportable_variant</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-87" id="描述-87">【描述】</a></h3>
<p>在使用类似 C 语言的枚举写法且使用<code>repr(isize/usize)</code> 布局时，在32位架构上会截断变体值，但在64位上工作正常。</p>
<p>但是没有这种风险的时候，可以正常使用。</p>
<p>【正例】</p>
<p>因为当前 lint 默认是<code> deny</code>，所以需要将其配置为 <code>allow</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![allow(clippy::enum_clike_unportable_variant)]

<span class="boring">fn main() {
</span>#[repr(isize)]
pub enum ZBarColor {
    ZBarSpace = 0,
    ZBarBar   = 1,
}

// 或者，没有指定 repr(isize/usize)

#[allow(clippy::enum_clike_unportable_variant)]
pub(crate) enum PropertyType {
    ActionItemSchemaVersion = 0x0C003473,
    ActionItemStatus = 0x10003470,
    ActionItemType = 0x10003463,
    Author = 0x1C001D75,
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(target_pointer_width = &quot;64&quot;)]
#[repr(usize)]
enum NonPortable {
    X = 0x1_0000_0000,
    Y = 0,
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gtypenum04----一般情况下不要使用--use-对-enum-的全部变体variants" id="gtypenum04----一般情况下不要使用--use-对-enum-的全部变体variants">G.TYP.Enum.04    一般情况下，不要使用  <code>use</code> 对 Enum 的全部变体（variants）</a></h2>
<h3><a class="header" href="#级别建议-67" id="级别建议-67">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-58" id="lint-检测-58">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#enum_glob_use">enum_glob_use</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-88" id="描述-88">【描述】</a></h3>
<p>因为使用 Enum 的类型前缀可以使代码更加可读。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cmp::Ordering;
foo(Ordering::Less)
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cmp::Ordering::*; // 这里导入了全部变体
foo(Less);
<span class="boring">}
</span></code></pre></pre>
<p>【例外】</p>
<p>当枚举体非常多的时候，比如 <a href="https://docs.rs/glutin/0.27.0/glutin/event/enum.VirtualKeyCode.html"> glutin::event::VirtualKeyCode</a> 这类对应键盘按键的枚举，并且上下文比较明确，都是在处理和 Key 相关的内容时，可以直接全部导入。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From:  https://github.com/alacritty/alacritty/blob/master/alacritty/src/config/bindings.rs#L368
#![allow(clippy::enum_glob_use)]

pub fn default_key_bindings() -&gt; Vec&lt;KeyBinding&gt; {
    let mut bindings = bindings!(
        KeyBinding;
        Copy;  Action::Copy;
        Copy,  +BindingMode::VI; Action::ClearSelection;
        Paste, ~BindingMode::VI; Action::Paste;
        L, ModifiersState::CTRL; Action::ClearLogNotice;
        L,    ModifiersState::CTRL,  ~BindingMode::VI, ~BindingMode::SEARCH;
            Action::Esc(&quot;\x0c&quot;.into());
        Tab,  ModifiersState::SHIFT, ~BindingMode::VI, ~BindingMode::SEARCH;
            Action::Esc(&quot;\x1b[Z&quot;.into());
        // ...
    }
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gtypenum05----对外导出的公开的-enum建议增加-non_exhaustive属性" id="gtypenum05----对外导出的公开的-enum建议增加-non_exhaustive属性">G.TYP.Enum.05    对外导出的公开的 Enum，建议增加 <code>#[non_exhaustive]</code>属性</a></h2>
<h3><a class="header" href="#级别建议-68" id="级别建议-68">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-59" id="lint-检测-59">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#exhaustive_enums">exhaustive_enums</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#manual_non_exhaustive">manual_non_exhaustive</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-89" id="描述-89">【描述】</a></h3>
<p>作为对外公开的 Enum，为了保持稳定性，应该使用 <code>#[non_exhaustive]</code>属性，避免因为将来Enum 枚举变体的变化而影响到下游的使用。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[non_exhaustive]
enum E {
    A,
    B,
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<p>在 <code>#[non_exhaustive]</code> 属性稳定之前，社区内还有一种约定俗成的写法来达到防止下游自定义枚举方法。通过 <code>manual_non_exhaustive</code> 可以监控这类写法。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum E {
    A,
    B,
    #[doc(hidden)]
    _C, // 这里用 下划线作为前缀定义的变体，作为隐藏的变体，不对外展示
}
// 用户无法自定义实现该 枚举的方法，达到一种稳定公开枚举的目的。
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gtypenum06----注意-enum-内变体的大小差异不要过大" id="gtypenum06----注意-enum-内变体的大小差异不要过大">G.TYP.Enum.06    注意 Enum 内变体的大小差异不要过大</a></h2>
<h3><a class="header" href="#级别建议-69" id="级别建议-69">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-60" id="lint-检测-60">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#large_enum_variant">large_enum_variant</a></td><td>yes</td><td>no</td><td>perf</td><td>warn</td></tr>
</tbody></table>
<p>该 lint 可以通过 clippy 配置项 <code>enum-variant-size-threshold = 200</code> 来配置，默认是 <code>200</code> 字节。</p>
<h3><a class="header" href="#描述-90" id="描述-90">【描述】</a></h3>
<p>要注意 Enum 内 变体 的大小差异不要过大，因为 Enum 内存布局是以最大的那个变体进行对齐。根据场景，如果该Enum 实例中小尺寸变体的实例使用很多的话，那内存就会有所浪费。但是如果小尺寸变体的实例使用很少，则无所谓。</p>
<p>解决办法就是把大尺寸变体包到 <code>Box&lt;T&gt;</code>中。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Test {
    A(i32),
    B(Box&lt;[i32; 1000]&gt;),
    C(Box&lt;[i32; 8000]&gt;),
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Test {
    A(i32),
    B([i32; 1000]),
    C([i32; 8000]),
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#表达式" id="表达式">表达式</a></h1>
<p>Rust 中几乎一切皆表达式。</p>
<hr />
<h2><a class="header" href="#pexp01" id="pexp01">P.EXP.01</a></h2>
<p>【描述】</p>
<hr />
<h2><a class="header" href="#gexp01-当需要对表达式求值之后重新赋值时尽量使用复合赋值模式" id="gexp01-当需要对表达式求值之后重新赋值时尽量使用复合赋值模式">G.EXP.01 当需要对表达式求值之后重新赋值时尽量使用复合赋值模式</a></h2>
<h3><a class="header" href="#级别建议-70" id="级别建议-70">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-61" id="lint-检测-61">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#assign_op_pattern">assign_op_pattern</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-91" id="描述-91">【描述】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut a = 5;
let b = 0;
a += b;
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut a = 5;
let b = 0;
a = a + b;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gexp02--避免在比较中使用不兼容的位掩码" id="gexp02--避免在比较中使用不兼容的位掩码">G.EXP.02  避免在比较中使用不兼容的位掩码</a></h2>
<h3><a class="header" href="#级别建议-71" id="级别建议-71">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-62" id="lint-检测-62">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#bad_bit_mask">bad_bit_mask</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-92" id="描述-92">【描述】</a></h3>
<p>可以对照下面表格进行检查。</p>
<table><thead><tr><th>Comparison</th><th>Bit Op</th><th>Example</th><th>is always</th><th>Formula</th></tr></thead><tbody>
<tr><td>== or !=</td><td>&amp;</td><td>x &amp; 2 == 3</td><td>false</td><td>c &amp; m != c</td></tr>
<tr><td>&lt; or &gt;=</td><td>&amp;</td><td>x &amp; 2 &lt; 3</td><td>true</td><td>m &lt; c</td></tr>
<tr><td>&gt; or &lt;=</td><td>&amp;</td><td>x &amp; 1 &gt; 1</td><td>false</td><td>m &lt;= c</td></tr>
<tr><td>== or !=</td><td></td><td></td><td>x</td><td>1 == 0</td></tr>
<tr><td>&lt; or &gt;=</td><td></td><td></td><td>x</td><td>1 &lt; 1</td></tr>
<tr><td>&lt;= or &gt;</td><td></td><td></td><td>x</td><td>1 &gt; 0</td></tr>
</tbody></table>
<h2><a class="header" href="#gexp03---不要使用子表达式调用" id="gexp03---不要使用子表达式调用">G.EXP.03   不要使用子表达式调用</a></h2>
<h3><a class="header" href="#级别建议-72" id="级别建议-72">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-63" id="lint-检测-63">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#unnecessary_operation">unnecessary_operation</a></td><td>yes</td><td>no</td><td><strong>complexity</strong></td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-93" id="描述-93">【描述】</a></h3>
<p>这样会影响代码可读性。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arr = compute_array();
let first = arr[0];
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let first = compute_array()[0];
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gexp04----不要使用无效表达式语句" id="gexp04----不要使用无效表达式语句">G.EXP.04    不要使用无效表达式语句</a></h2>
<h3><a class="header" href="#级别建议-73" id="级别建议-73">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-64" id="lint-检测-64">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#no_effect">no_effect</a></td><td>yes</td><td>no</td><td><strong>complexity</strong></td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-94" id="描述-94">【描述】</a></h3>
<p>无效的表达式语句，虽然会执行，但实际并没有起到什么效果。</p>
<p>也有例外情况存在。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 41;
let a = a+1;
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a+1;
<span class="boring">}
</span></code></pre></pre>
<p>【例外】</p>
<p>像在下面代码中，为了确保常量函数 <code>new</code> 可以在输入参数超出 MAX 限制的情况下 panic，使用了一个数组的技巧：<code> [&quot;tag number out of range&quot;][(byte &gt; Self::MAX) as usize];</code> 。因为目前 在常量上下文中还无法直接使用 <code>panic!</code>，等 <code>const_panic</code> 功能稳定就可以了。</p>
<p>如果不加 <code>#[allow(clippy::no_effect)]</code> ，Clippy 会有警告。 </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From: https://docs.rs/crate/der/0.4.1/source/src/tag/number.rs

#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]
pub struct TagNumber(pub(super) u8);

impl TagNumber {
    /// Maximum tag number supported (inclusive).
    pub const MAX: u8 = 30;

    /// Create a new tag number (const-friendly).
    ///
    /// Panics if the tag number is greater than [`TagNumber::MAX`]. For a fallible
    /// conversion, use [`TryFrom`] instead.
    #[allow(clippy::no_effect)]
    pub const fn new(byte: u8) -&gt; Self {
        // TODO(tarcieri): hax! use const panic when available
        [&quot;tag number out of range&quot;][(byte &gt; Self::MAX) as usize];
        Self(byte)
    }
	// ...
    
}

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gexp05----使用---等操作来代替-i----i" id="gexp05----使用---等操作来代替-i----i">G.EXP.05    使用 <code>+=</code>/<code>-=</code> 等操作来代替 <code>++i</code> / <code>--i</code></a></h2>
<h3><a class="header" href="#级别建议-74" id="级别建议-74">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-65" id="lint-检测-65">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#double_neg">double_neg</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-95" id="描述-95">【描述】</a></h3>
<p><code>++i</code> 这种操作编译会失败，但是 <code>--i</code> 编译不会出错。有些C/Cpp等其他语言新手容易犯此错误。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 3;
x -= 1;
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 3;
--x;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gexp06----表达式操作最好使用括号来表达清楚优先级顺序" id="gexp06----表达式操作最好使用括号来表达清楚优先级顺序">G.EXP.06    表达式操作最好使用括号来表达清楚优先级顺序</a></h2>
<h3><a class="header" href="#级别建议-75" id="级别建议-75">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-66" id="lint-检测-66">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#precedence">precedence</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-96" id="描述-96">【描述】</a></h3>
<p>并不是每个人都能记得住优先级，所以最好使用括号把优先级顺序区分出来，增加可读性。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(1 &lt;&lt; 2) + 3
(-1i32).abs()
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>1 &lt;&lt; 2 + 3
-1i32.abs()
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gexp07----避免在比较中添加无用的掩码操作" id="gexp07----避免在比较中添加无用的掩码操作">G.EXP.07    避免在比较中添加无用的掩码操作</a></h2>
<h3><a class="header" href="#级别建议-76" id="级别建议-76">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-67" id="lint-检测-67">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#ineffective_bit_mask">ineffective_bit_mask</a></td><td>yes</td><td>no</td><td>correctness</td><td><strong>deny</strong></td></tr>
</tbody></table>
<h3><a class="header" href="#描述-97" id="描述-97">【描述】</a></h3>
<p>检查比较中的无用位掩码操作，可以在不改变结果的情况下删除该位掩码操作。</p>
<p>可以对照下面表格进行检查。</p>
<table><thead><tr><th>Comparison</th><th>Bit Op</th><th>Example</th><th>equals</th></tr></thead><tbody>
<tr><td>&gt; / &lt;=</td><td>| / ^</td><td>x | 2 &gt; 3</td><td>x &gt; 3</td></tr>
<tr><td>&lt; / &gt;=</td><td>| / ^</td><td>x ^ 1 &lt; 4</td><td>x &lt; 4</td></tr>
</tbody></table>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if (x &gt; 3) {  }
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if (x | 1 &gt; 3) {  }
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#控制流程" id="控制流程">控制流程</a></h1>
<p>Rust 中 流程控制 也是属于 表达式，但在本规范中将其独立出来。</p>
<hr />
<h2><a class="header" href="#pctl01-不要过度使用迭代器" id="pctl01-不要过度使用迭代器">P.CTL.01 不要过度使用迭代器</a></h2>
<p><strong>【描述】</strong></p>
<p>迭代器虽然是 Rust 中比较推崇的方式，但也没必要过度使用它。总之，如果使用迭代器让代码太复杂，就考虑换个非迭代器的方式实现吧。</p>
<p>【正例】</p>
<p>创建一个 Matrix变换的函数，使用命令式风格，代码功能比较明确，更加直观。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From: https://adventures.michaelfbryan.com/posts/rust-best-practices/bad-habits/#overusing-iterators
pub fn imperative_blur(input: &amp;Matrix) -&gt; Matrix {
    assert!(input.width &gt;= 3);
    assert!(input.height &gt;= 3);

    // allocate our output matrix, copying from the input so
    // we don't need to worry about the edge cases.
    let mut output = input.clone();

    for y in 1..(input.height - 1) {
        for x in 1..(input.width - 1) {
            let mut pixel_value = 0.0;

            pixel_value += input[[x - 1, y - 1]];
            pixel_value += input[[x, y - 1]];
            pixel_value += input[[x + 1, y - 1]];

            pixel_value += input[[x - 1, y]];
            pixel_value += input[[x, y]];
            pixel_value += input[[x + 1, y]];

            pixel_value += input[[x - 1, y + 1]];
            pixel_value += input[[x, y + 1]];
            pixel_value += input[[x + 1, y + 1]];

            output[[x, y]] = pixel_value / 9.0;
        }
    }

    output
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<p>创建一个 Matrix变换的函数，但是这种迭代器的方式，代码可读性相比于命令式更困难。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From : https://adventures.michaelfbryan.com/posts/rust-best-practices/bad-habits/#overusing-iterators
pub fn functional_blur(input: &amp;Matrix) -&gt; Matrix {
    assert!(input.width &gt;= 3);
    assert!(input.height &gt;= 3);

    // Stash away the top and bottom rows so they can be
    // directly copied across later
    let mut rows = input.rows();
    let first_row = rows.next().unwrap();
    let last_row = rows.next_back().unwrap();

    let top_row = input.rows();
    let middle_row = input.rows().skip(1);
    let bottom_row = input.rows().skip(2);

    let blurred_elements = top_row
        .zip(middle_row)
        .zip(bottom_row)
        .flat_map(|((top, middle), bottom)| blur_rows(top, middle, bottom));

    let elements: Vec&lt;f32&gt; = first_row
        .iter()
        .copied()
        .chain(blurred_elements)
        .chain(last_row.iter().copied())
        .collect();

    Matrix::new_row_major(elements, input.width, input.height)
}

fn blur_rows&lt;'a&gt;(
    top_row: &amp;'a [f32],
    middle_row: &amp;'a [f32],
    bottom_row: &amp;'a [f32],
) -&gt; impl Iterator&lt;Item = f32&gt; + 'a {
    // stash away the left-most and right-most elements so they can be copied across directly.
    let &amp;first = middle_row.first().unwrap();
    let &amp;last = middle_row.last().unwrap();

    // Get the top, middle, and bottom row of our 3x3 sub-matrix so they can be
    // averaged.
    let top_window = top_row.windows(3);
    let middle_window = middle_row.windows(3);
    let bottom_window = bottom_row.windows(3);

    // slide the 3x3 window across our middle row so we can get the average
    // of everything except the left-most and right-most elements.
    let averages = top_window
        .zip(middle_window)
        .zip(bottom_window)
        .map(|((top, middle), bottom)| top.iter().chain(middle).chain(bottom).sum::&lt;f32&gt;() / 9.0);

    std::iter::once(first)
        .chain(averages)
        .chain(std::iter::once(last))
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#pctl02---优先使用模式匹配而不是-if-判断值是否相等" id="pctl02---优先使用模式匹配而不是-if-判断值是否相等">P.CTL.02   优先使用模式匹配而不是 <code>if</code> 判断值是否相等</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 中 模式匹配 是惯用法，而不是通过 <code>if</code> 判断值是否相等。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(value) = opt {
  ...
}
// or
if let [first, ..] = list {
  ...
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let opt: Option&lt;_&gt; = ...;

if opt.is_some() {
  let value = opt.unwrap();
  ...
}

// or
let list: &amp;[f32] = ...;

if !list.is_empty() {
  let first = list[0];
  ...
}

<span class="boring">}
</span></code></pre></pre>
<hr />
<h2><a class="header" href="#gctl01--避免在流程控制分支中使用重复代码" id="gctl01--避免在流程控制分支中使用重复代码">G.CTL.01  避免在流程控制分支中使用重复代码</a></h2>
<h3><a class="header" href="#级别建议-77" id="级别建议-77">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-68" id="lint-检测-68">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#branches_sharing_code">branches_sharing_code</a></td><td>yes</td><td>no</td><td>nursery</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-98" id="描述-98">【描述】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;Hello World&quot;);
let foo = if … {
    13
} else {
    42
};
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo = if … {
    println!(&quot;Hello World&quot;);
    13
} else {
    println!(&quot;Hello World&quot;);
    42
};
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gctl02---控制流程的分支逻辑要保持精炼" id="gctl02---控制流程的分支逻辑要保持精炼">G.CTL.02   控制流程的分支逻辑要保持精炼</a></h2>
<h3><a class="header" href="#级别建议-78" id="级别建议-78">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-69" id="lint-检测-69">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#collapsible_else_if">collapsible_else_if</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#collapsible_if">collapsible_if</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#collapsible_match">collapsible_match</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#double_comparisons">double_comparisons</a></td><td>yes</td><td>no</td><td><strong>complexity</strong></td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#wildcard_in_or_patterns">wildcard_in_or_patterns</a></td><td>yes</td><td>no</td><td><strong>complexity</strong></td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-99" id="描述-99">【描述】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// else if
if x {
    …
} else if y {
    …
}

// Merge multiple conditions
if x &amp;&amp; y {
    …
}

// match 
fn func(opt: Option&lt;Result&lt;u64, String&gt;&gt;) {
    let n = match opt {
        Some(Ok(n)) =&gt; n,
        _ =&gt; return,
    };
}

// comparisons
<span class="boring">let x = 1;
</span><span class="boring">let y = 2;
</span>if x &lt;= y {}

// wildcard_in_or_patterns    
match &quot;foo&quot; {
    &quot;a&quot; =&gt; {},
    _ =&gt; {},
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>if x {
    …
} else {     // collapsible_else_if
    if y {
        …
    }
}

if x {  // collapsible_if
    if y {
        …
    }
}

// collapsible_match
fn func(opt: Option&lt;Result&lt;u64, String&gt;&gt;) {
    let n = match opt {
        Some(n) =&gt; match n {
            Ok(n) =&gt; n,
            _ =&gt; return,
        }
        None =&gt; return,
    };
}

// double_comparisons
<span class="boring">let x = 1;
</span><span class="boring">let y = 2;
</span>if x == y || x &lt; y {}

// wildcard_in_or_patterns    
match &quot;foo&quot; {
    &quot;a&quot; =&gt; {},
    &quot;bar&quot; | _ =&gt; {},
}

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gctl03---当需要通过比较大小来区分不同情况时优先使用match-和-cmp-来代替-if-表达式" id="gctl03---当需要通过比较大小来区分不同情况时优先使用match-和-cmp-来代替-if-表达式">G.CTL.03   当需要通过比较大小来区分不同情况时，优先使用<code>match</code> 和 <code>cmp</code> 来代替 if 表达式</a></h2>
<h3><a class="header" href="#级别建议-79" id="级别建议-79">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-70" id="lint-检测-70">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#comparison_chain">comparison_chain</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-100" id="描述-100">【描述】</a></h3>
<p>这种情况下，使用 <code>match</code> 和 <code>cmp</code> 代替 <code>if</code> 的好处是语义更加明确，而且也能帮助开发者穷尽所有可能性。
但是这里需要注意这里使用 <code>match</code> 和 <code>cmp</code> 的性能要低于 <code>if</code>表达式，因为 一般的 <code>&gt;</code> 或 <code>&lt;</code> 等比较操作是内联的，而 <code>cmp</code>方法没有内联。</p>
<p>根据实际情况来选择是否设置 <code>comparison_chain</code> 为 <code>allow</code>。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cmp::Ordering;
<span class="boring">fn a() {}
</span><span class="boring">fn b() {}
</span><span class="boring">fn c() {}
</span>fn f(x: u8, y: u8) {
     match x.cmp(&amp;y) {
         Ordering::Greater =&gt; a(),
         Ordering::Less =&gt; b(),
         Ordering::Equal =&gt; c()
     }
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn a() {}
</span><span class="boring">fn b() {}
</span><span class="boring">fn c() {}
</span>fn f(x: u8, y: u8) {
    if x &gt; y {
        a()
    } else if x &lt; y {
        b()
    } else {
        c()
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gctl04----if-条件表达式分支中如果包含了-else-if--分支也应该包含-else-分支" id="gctl04----if-条件表达式分支中如果包含了-else-if--分支也应该包含-else-分支">G.CTL.04    <code>if</code> 条件表达式分支中如果包含了 <code>else if</code>  分支也应该包含 <code>else</code> 分支</a></h2>
<h3><a class="header" href="#级别建议-80" id="级别建议-80">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-71" id="lint-检测-71">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#else_if_without_else">else_if_without_else</a></td><td>yes</td><td>no</td><td><strong>restriction</strong></td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-101" id="描述-101">【描述】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn a() {}
</span><span class="boring">fn b() {}
</span><span class="boring">let x: i32 = 1;
</span>if x.is_positive() {
    a();
} else if x.is_negative() {
    b();
} else {
    // We don't care about zero.
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn a() {}
</span><span class="boring">fn b() {}
</span><span class="boring">let x: i32 = 1;
</span>if x.is_positive() {
    a();
} else if x.is_negative() {
    b();
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gctl05----如果要通过-if-条件表达式来判断是否panic请优先使用断言" id="gctl05----如果要通过-if-条件表达式来判断是否panic请优先使用断言">G.CTL.05    如果要通过 <code>if</code> 条件表达式来判断是否panic，请优先使用断言</a></h2>
<h3><a class="header" href="#级别建议-81" id="级别建议-81">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-72" id="lint-检测-72">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#if_then_panic">if_then_panic</a></td><td>yes</td><td>no</td><td>Style</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-102" id="描述-102">【描述】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sad_people: Vec&lt;&amp;str&gt; = vec![];
assert!(sad_people.is_empty(), &quot;there are sad people: {:?}&quot;, sad_people);
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sad_people: Vec&lt;&amp;str&gt; = vec![];
if !sad_people.is_empty() {
    panic!(&quot;there are sad people: {:?}&quot;, sad_people);
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gctl06---善用标准库中提供的迭代器适配器方法来满足自己的需求" id="gctl06---善用标准库中提供的迭代器适配器方法来满足自己的需求">G.CTL.06   善用标准库中提供的迭代器适配器方法来满足自己的需求</a></h2>
<h3><a class="header" href="#级别建议-82" id="级别建议-82">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-73" id="lint-检测-73">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#explicit_counter_loop">explicit_counter_loop</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#filter_map_identity">filter_map_identity</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#filter_next">filter_next</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#flat_map_identity">flat_map_identity</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#flat_map_option">flat_map_option</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-103" id="描述-103">【描述】</a></h3>
<p>Rust 标准库中提供了很多迭代器方法，要学会使用它们，选择合适的方法来满足自己的需求。</p>
<p>下面示例中，反例中的迭代器适配器方法，都可以用对应的正例中的方法代替。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// explicit_counter_loop
let v = vec![1];
fn bar(bar: usize, baz: usize) {}
for (i, item) in v.iter().enumerate() { bar(i, *item); }

// filter_map_identity
let iter = vec![Some(1)].into_iter();
iter.flatten();

// filter_next
let vec = vec![1];
vec.iter().find(|x| **x == 0);

// flat_map_identity
let iter = vec![vec![0]].into_iter();
iter.flatten();

// flat_map_option
let nums: Vec&lt;i32&gt; = [&quot;1&quot;, &quot;2&quot;, &quot;whee!&quot;].iter().filter_map(|x| x.parse().ok()).collect();

<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// explicit_counter_loop
let v = vec![1];
fn bar(bar: usize, baz: usize) {}
let mut i = 0;
for item in &amp;v {
    bar(i, *item);
    i += 1;
}

// filter_map_identity
let iter = vec![Some(1)].into_iter();
iter.filter_map(|x| x);

// filter_next
let vec = vec![1];
vec.iter().filter(|x| **x == 0).next();

// flat_map_identity
let iter = vec![vec![0]].into_iter();
iter.flat_map(|x| x);

// flat_map_option
let nums: Vec&lt;i32&gt; = [&quot;1&quot;, &quot;2&quot;, &quot;whee!&quot;].iter().flat_map(|x| x.parse().ok()).collect();
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gctl07---在-match-分支的-guard-语句中不要使用带有副作用的条件表达式" id="gctl07---在-match-分支的-guard-语句中不要使用带有副作用的条件表达式">G.CTL.07   在 Match 分支的 Guard 语句中不要使用带有副作用的条件表达式</a></h2>
<h3><a class="header" href="#级别建议-83" id="级别建议-83">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-74" id="lint-检测-74">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制化参考】</p>
<p>可以检测 match分支中 Guard 的 if 表达式是否使用 <code>{}</code> ，如果是的话，发出警告，不要带有副作用。</p>
<h3><a class="header" href="#描述-104" id="描述-104">【描述】</a></h3>
<p>因为在 mactch 分支中， 匹配几次就会执行 Guard 几次。如果携带副作用，会产生意料之外的情况。</p>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">// 下面代码会输出两次 &quot;ha&quot;
fn main() {
    use std::cell::Cell;
    let i: Cell&lt;i32&gt; = Cell::new(0);
    match 1 {
        1 | _  // 这里匹配两次
            if { // 这个 Guard 条件表达式带有副作用：打印，因为匹配两次，所以会执行两次
                println!(&quot;ha&quot;);
                i.set(i.get() + 1);
                false
            } =&gt; {}
        _ =&gt; {}
    }
    assert_eq!(i.get(), 2);
}
</code></pre></pre>
<h1><a class="header" href="#字符串" id="字符串">字符串</a></h1>
<p>Rust 中字符串是有效的 UTF-8 编码的字节数组。</p>
<p>Rust 字符串类型众多，但本节内容主要围绕 ：<code>String</code> / <code>&amp;str</code></p>
<hr />
<h2><a class="header" href="#pstr01---处理字符串非必要不要按字符来处理应该按字节处理" id="pstr01---处理字符串非必要不要按字符来处理应该按字节处理">P.STR.01   处理字符串非必要不要按字符来处理，应该按字节处理</a></h2>
<p><strong>【描述】</strong></p>
<p>处理字符串有两种方式，一种是按字符处理，即把字符串转为字符数组<code>[char]</code>，另一种是直接按字节处理<code>[u8]</code>。</p>
<p>两者之间的一些区别：</p>
<ul>
<li><code>[char]</code>  保证是有效的 Unicode，但不一定是有效的 UTF-8，一般将其看作是 UTF-32 。将字符数组转换为字符串需要注意。</li>
<li><code>[u8]</code> 不一定是有效的字符串，它比 <code>[char]</code> 节省内存。将其转换为字符串需要检查 <code>UTF-8</code>编码。</li>
</ul>
<h2><a class="header" href="#pstr02---创建字符串时可以预先分配大约足够的容量来避免后续操作中产生多次分配" id="pstr02---创建字符串时可以预先分配大约足够的容量来避免后续操作中产生多次分配">P.STR.02   创建字符串时，可以预先分配大约足够的容量来避免后续操作中产生多次分配</a></h2>
<p><strong>【描述】</strong></p>
<p>预分配足够的容量，避免后续内存分配，可以提升代码性能。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut output = String::with_capacity(input.len());
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut output = String::new();
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#pstr03----可以使用-cowstr-来代替直接使用字符串它可以减少-copy" id="pstr03----可以使用-cowstr-来代替直接使用字符串它可以减少-copy">P.STR.03    可以使用 <code>Cow&lt;str&gt;</code> 来代替直接使用字符串，它可以减少 Copy</a></h2>
<p><strong>【描述】</strong></p>
<p>使用 <code>Cow&lt;str&gt;</code> 作为字符串处理函数参数和返回值，可以尽可能地减少数据Copy 和 内存分配。当字符串没有修改的时候，实际使用的是 <code>&amp;'a str</code>，只有当数据修改的时候才会使用<code>String</code>。对于读操作大于写操作的场景，使用 <code>Cow&lt;str&gt;</code> 比较合适。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 对输入的字符串进行转义
pub fn naive&lt;'a, S: Into&lt;Cow&lt;'a, str&gt;&gt;&gt;(input: S) -&gt; Cow&lt;'a, str&gt; {
    let input = input.into();
    fn is_trouble(c: char) -&gt; bool {
        c == '&lt;' || c == '&gt;' || c == '&amp;'
    }

    if input.contains(is_trouble) {
        let mut output = String::with_capacity(input.len());
        for c in input.chars() {
            match c {
                '&lt;' =&gt; output.push_str(&quot;&amp;lt;&quot;),
                '&gt;' =&gt; output.push_str(&quot;&amp;gt;&quot;),
                '&amp;' =&gt; output.push_str(&quot;&amp;amp;&quot;),
                _ =&gt; output.push(c)
            }
        }
        // 只有在字符串修改的时候才使用 String
        Cow::Owned(output)
    } else {
        //其他情况使用 &amp;str
        input
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#pstr04-----在使用内建字符串处理函数或方法的时候应该注意避免隐藏的嵌套迭代-或-多次迭代" id="pstr04-----在使用内建字符串处理函数或方法的时候应该注意避免隐藏的嵌套迭代-或-多次迭代">P.STR.04     在使用内建字符串处理函数或方法的时候，应该注意避免隐藏的嵌套迭代 或 多次迭代</a></h2>
<p><strong>【描述】</strong></p>
<p>比如 <code>contains</code> 函数的实现就是按字符遍历字符串，但是如果你将它用于一个字符串的迭代处理中，就会产生嵌套迭代，时间复杂度从你以为的 <code>O(n)</code> 变成了 <code>O(n^2)</code>。没有将其用于迭代中，也有可能产生多次迭代，<code>O(n)</code> 变为 <code>O(n+m)</code> 。 为了避免这个问题，我们可以用 <code>find</code>  来代替 <code>contains</code>。</p>
<p>所以，在使用内建函数的时候要注意它的实现，选择合适的函数或方法，来避免这类问题。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 对输入的字符串进行转义
pub fn find&lt;'a, S: Into&lt;Cow&lt;'a, str&gt;&gt;&gt;(input: S) -&gt; Cow&lt;'a, str&gt; {
    let input = input.into();
    fn is_trouble(c: char) -&gt; bool {
        c == '&lt;' || c == '&gt;' || c == '&amp;'
    }
    
    // 使用 find 而非 contains
    // find 使用模式查找，可以返回匹配字符的位置信息
    let first = input.find(is_trouble);
    
    // 利用 find 的位置信息，避免第二次遍历
    if let Some(first) = first {
        let mut output = String::from(&amp;input[0..first]);
        output.reserve(input.len() - first);
        let rest = input[first..].chars();
        for c in rest {
            match c {
                '&lt;' =&gt; output.push_str(&quot;&amp;lt;&quot;),
                '&gt;' =&gt; output.push_str(&quot;&amp;gt;&quot;),
                '&amp;' =&gt; output.push_str(&quot;&amp;amp;&quot;),
                _ =&gt; output.push(c),
            }
        }

        Cow::Owned(output)
    } else {
        input.into()
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#pstr05-----只有在合适的场景下才使用第三方库正则表达式regex" id="pstr05-----只有在合适的场景下才使用第三方库正则表达式regex">P.STR.05     只有在合适的场景下，才使用第三方库正则表达式<code>regex</code></a></h2>
<p><strong>【描述】</strong></p>
<p>合适的场景包括：</p>
<ol>
<li>不在乎编译文件大小。<code>regex</code> 正则引擎是第三方库，引入它的时候意味着还会引入其他依赖，对编译文件大小有要求可以考虑，是否使用 <code>Cow</code> 和 内建函数方法来替代。</li>
<li>对字符串查找性能有极致需求。<code>regex</code> 的  <code>find</code> 实现性能很好，但是 <code>replace</code> 替换就不一定了。对于替换需求，在适合 <code>Cow&lt;str&gt;</code> 的场景下，使用 <code>Cow</code> 和 内建函数方法来替代 regex 可能更好。</li>
</ol>
<h2><a class="header" href="#pstr06----在拼接字符串时建议使用-format" id="pstr06----在拼接字符串时建议使用-format">P.STR.06    在拼接字符串时，建议使用 <code>format!</code></a></h2>
<p><strong>【描述】</strong></p>
<p>使用 <code>format!</code> 组合字符串是最简单和直观的方法，尤其是在字符串和非字符串混合的情况下。但追加字符串还是建议使用 <code>push</code>。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> let hw = format!(&quot;Hello {}!&quot;, name)
<span class="boring">}
</span></code></pre></pre>
<hr />
<h2><a class="header" href="#gstr01---在实现--display-trait-时不要调用-to_string-方法" id="gstr01---在实现--display-trait-时不要调用-to_string-方法">G.STR.01   在实现  <code>Display</code> trait 时不要调用 <code>to_string()</code> 方法</a></h2>
<h3><a class="header" href="#级别建议-84" id="级别建议-84">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-75" id="lint-检测-75">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#to_string_in_display">to_string_in_display</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-105" id="描述-105">【描述】</a></h3>
<p>因为 <code>to_string</code> 是间接通过 <code>Display</code> 来实现的，如果实现 <code>Display</code> 的时候再使用 <code>to_tring</code> 的话，将会无限递归。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

struct Structure(i32);
impl fmt::Display for Structure {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;{}&quot;, self.0)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

struct Structure(i32);
impl fmt::Display for Structure {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;{}&quot;, self.to_string())
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gstr02---在追加字符串时使用-push_str方法可读性更强" id="gstr02---在追加字符串时使用-push_str方法可读性更强">G.STR.02   在追加字符串时使用 <code>push_str</code>方法可读性更强</a></h2>
<h3><a class="header" href="#级别建议-85" id="级别建议-85">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-76" id="lint-检测-76">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#string_add_assign">string_add_assign</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#string_add">string_add</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-106" id="描述-106">【描述】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = &quot;Hello&quot;.to_owned();

// More readable
x += &quot;, World&quot;;
x.push_str(&quot;, World&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = &quot;Hello&quot;.to_owned();
x = x + &quot;, World&quot;;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gstr03----将只包含-ascii字符的字符串字面量转为字节序列可以直接使用bstr-语法代替调用as_bytes方法" id="gstr03----将只包含-ascii字符的字符串字面量转为字节序列可以直接使用bstr-语法代替调用as_bytes方法">G.STR.03    将只包含 <code>ASCII</code>字符的字符串字面量转为字节序列可以直接使用<code>b&quot;str&quot;</code> 语法代替调用<code>as_bytes</code>方法</a></h2>
<h3><a class="header" href="#级别建议-86" id="级别建议-86">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-77" id="lint-检测-77">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#string_lit_as_bytes">string_lit_as_bytes</a></td><td>yes</td><td>no</td><td>nursery</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-107" id="描述-107">【描述】</a></h3>
<p>这是为了增强可读性，让代码更简洁。</p>
<p>注意，<code>&quot;str&quot;.as_bytes()</code> 并不等价于  <code>b&quot;str&quot;</code>，而是等价于 <code>&amp;b&quot;str&quot;[..]</code>  。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bs = b&quot;a byte string&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bs = &quot;a byte string&quot;.as_bytes();
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gstr04---需要判断字符串以哪个字符开头或结尾时不要按字符迭代比较" id="gstr04---需要判断字符串以哪个字符开头或结尾时不要按字符迭代比较">G.STR.04   需要判断字符串以哪个字符开头或结尾时，不要按字符迭代比较</a></h2>
<h3><a class="header" href="#级别建议-87" id="级别建议-87">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-78" id="lint-检测-78">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#chars_last_cmp">chars_last_cmp</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#chars_next_cmp">chars_next_cmp</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-108" id="描述-108">【描述】</a></h3>
<p>Rust 语言 核心库 和 标准库都对字符串内置了一些方便的方法来处理这类需求。</p>
<p>迭代字符的性能虽然也很快（对500多个字符迭代转义处理大概需要4.5微秒左右），但这种场景用迭代的话，代码可读性更差一些。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let name = &quot;_&quot;;
name.ends_with('_') || name.ends_with('-');

let name = &quot;foo&quot;;
if name.starts_with('_') {};
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let name = &quot;_&quot;;
name.chars().last() == Some('_') || name.chars().next_back() == Some('-');

let name = &quot;foo&quot;;
if name.chars().next() == Some('_') {};
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gstr05---对字符串按指定位置进行切片的时候需要小心破坏其-utf-8-编码" id="gstr05---对字符串按指定位置进行切片的时候需要小心破坏其-utf-8-编码">G.STR.05   对字符串按指定位置进行切片的时候需要小心破坏其 UTF-8 编码</a></h2>
<h3><a class="header" href="#级别建议-88" id="级别建议-88">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-79" id="lint-检测-79">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#string_slice">string_slice</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-109" id="描述-109">【描述】</a></h3>
<p>字符串默认是合法的 <code>UTF-8</code>字节序列，如果通过指定索引位置来对字符串进行切片，有可能破坏其合法 <code>UTF-8</code> 编码，除非这个位置是确定的，比如按 <code>char_indices</code> 方法来定位是合法的。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;Ölkanne&quot;;
let mut char_indices = s.char_indices();
assert_eq!(Some((0, 'Ö')), char_indices.next());
// assert_eq!(Some((2, 'l')), char_indices.next()); 
let pos = if let Some((pos, _)) = char_indices.next(){ pos } else {0};
let sub_s = &amp;s[pos..];
assert_eq!(&quot;lkanne&quot;, sub_s);
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;Ölkanne&quot;;
// thread 'main' panicked at 'byte index 1 is not a char boundary; 
// it is inside 'Ö' (bytes 0..2) of `Ölkanne`'
let sub_s = &amp;s[1..];
// println!(&quot;{:?}&quot;, sub_s);
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#集合类型" id="集合类型">集合类型</a></h1>
<p>Rust 中的集合类型包括四大类：</p>
<ul>
<li>线性序列： <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code>Vec</code></a>, <a href="https://doc.rust-lang.org/stable/std/collections/struct.VecDeque.html"><code>VecDeque</code></a>, <a href="https://doc.rust-lang.org/stable/std/collections/struct.LinkedList.html"><code>LinkedList</code></a></li>
<li>映射集：<a href="https://doc.rust-lang.org/stable/std/collections/hash_map/struct.HashMap.html"><code>HashMap</code></a>, <a href="https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html"><code>BTreeMap</code></a></li>
<li>集合： <a href="https://doc.rust-lang.org/stable/std/collections/hash_set/struct.HashSet.html"><code>HashSet</code></a>, <a href="https://doc.rust-lang.org/stable/std/collections/struct.BTreeSet.html"><code>BTreeSet</code></a></li>
<li>其他： <a href="https://doc.rust-lang.org/stable/std/collections/struct.BinaryHeap.html"><code>BinaryHeap</code></a></li>
</ul>
<hr />
<h2><a class="header" href="#pclt01--根据集合各自的特点选择合适的集合类型" id="pclt01--根据集合各自的特点选择合适的集合类型">P.CLT.01  根据集合各自的特点选择合适的集合类型</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 标准库内置的集合类型，在安全和性能方面还是比较靠谱的。需要仔细阅读标准库中各类集合类型的优缺点来选择合适的类型。</p>
<p><strong>下列场景考虑 <code>Vec</code></strong></p>
<ul>
<li>你想要一个可动态增长大小（堆分配）的数组</li>
<li>你想要一个栈结构</li>
<li>你想要集合元素按特定顺序排序，并且仅需要在结尾追加新元素</li>
<li>你可能只是想临时收集一些元素，并且不关心它们的实际存储</li>
</ul>
<p><strong>下列场景考虑 <code>VecDeque</code></strong></p>
<ul>
<li>你想要一个可以在头尾两端插入元素的 <code>Vec</code></li>
<li>你想要一个队列，或双端队列</li>
</ul>
<p><strong>下列场景考虑<code>LinkedList</code></strong></p>
<ul>
<li>你非常确定你真的需要一个双向链表</li>
</ul>
<p><strong>下列场景考虑 <code>Hashmap</code></strong></p>
<ul>
<li>你需要一个 KV  集合</li>
<li>你想要一个缓存</li>
</ul>
<p><strong>下列场景考虑 <code>BTreeMap</code></strong></p>
<ul>
<li>你需要一个可以排序的 <code>HashMap</code></li>
<li>你希望可以按需获取一系列元素</li>
<li>你对最小或最大的 KV 感兴趣</li>
<li>你想要找到比某物小或大的最大或最小键</li>
</ul>
<p><strong>下列场景考虑使用 <code>Set</code> 系列</strong></p>
<ul>
<li>你只是需要一个 集合</li>
</ul>
<p><strong>下列场景考虑使用 <code>BinaryHeap</code></strong></p>
<ul>
<li>你想存储一堆元素，但只想在任何给定时间内处理 最大 或 最重要的元素</li>
<li>你想要一个优先队列</li>
</ul>
<h2><a class="header" href="#gclt01---非必要情况下不要使用-linkedlist而用-vec或vecdeque-代替" id="gclt01---非必要情况下不要使用-linkedlist而用-vec或vecdeque-代替">G.CLT.01   非必要情况下，不要使用 <code>LinkedList</code>，而用 <code>Vec</code>或<code>VecDeque</code> 代替</a></h2>
<h3><a class="header" href="#级别建议-89" id="级别建议-89">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-80" id="lint-检测-80">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#linkedlist">linkedlist</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<p>该 lint 对应 <code>clippy.toml</code> 配置项：</p>
<pre><code class="language-toml"># 如果函数是被导出的 API，则该 lint 不会被触发，是防止 lint 建议对 API 有破坏性的改变。默认为 true
avoid-breaking-exported-api=true 
</code></pre>
<h3><a class="header" href="#描述-110" id="描述-110">【描述】</a></h3>
<p>一般情况下，有 <code>Vec</code>和<code>VecDeque</code> 性能更好。<code>LinkedList</code> 存在内存浪费，缓存局部性（Cache Locality）比较差，无法更好地利用CPU 缓存机制，性能很差。</p>
<p>只有在有大量的 列表 拆分 和 合并 操作时，才真正需要链表，因为链表允许你只需操作指针而非复制数据来完成这些操作。 </p>
<h1><a class="header" href="#函数与闭包" id="函数与闭包">函数与闭包</a></h1>
<hr />
<h2><a class="header" href="#pfud01--函数参数建议使用借用类型" id="pfud01--函数参数建议使用借用类型">P.FUD.01  函数参数建议使用借用类型</a></h2>
<p><strong>【描述】</strong></p>
<p>这里是指 借用类型，而非 借用有所有权的类型。比如：<code>&amp;str</code> 优于 <code>&amp;String</code>，<code>&amp;[T]</code> 优于<code>&amp;Vec&lt;T&gt;</code>，<code>&amp;T</code> 优于 <code>&amp;Box&lt;T&gt;</code> 等。</p>
<p>使用 借用类型 可以利用 <code>Deref</code> 隐式转换让函数参数更加灵活。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">// 这里的参数可以接受 &amp;String / &amp;'str/ &amp;'static str 三种类型参数
fn three_vowels(word: &amp;str) -&gt; bool {
    let mut vowel_count = 0;
    for c in word.chars() {
        match c {
            'a' | 'e' | 'i' | 'o' | 'u' =&gt; {
                vowel_count += 1;
                if vowel_count &gt;= 3 {
                    return true
                }
            }
            _ =&gt; vowel_count = 0
        }
    }
    false
}

fn main() {
    let sentence_string =
        &quot;Once upon a time, there was a friendly curious crab named Ferris&quot;.to_string();
    for word in sentence_string.split(' ') {
        if three_vowels(word) {
            println!(&quot;{} has three consecutive vowels!&quot;, word);
        }
    }
}
</code></pre></pre>
<h2><a class="header" href="#pfud02---传递到闭包的变量建议单独重新绑定" id="pfud02---传递到闭包的变量建议单独重新绑定">P.FUD.02   传递到闭包的变量建议单独重新绑定</a></h2>
<p><strong>【描述】</strong></p>
<p>默认情况下，闭包通过借用来捕获环境变量。或者，可以使用 <code>move</code> 关键字来移动环境变量到闭包中。</p>
<p>将这些要在闭包内用的变量，重新进行分组绑定，可读性更好。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

let num1 = Rc::new(1);
let num2 = Rc::new(2);
let num3 = Rc::new(3);
// 单独对要传递到闭包的变量重新绑定
let num2_cloned = num2.clone();
let num3_borrowed = num3.as_ref();
let closure = move || {
    *num1 + *num2_cloned + *num3_borrowed;
};
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

let num1 = Rc::new(1);
let num2 = Rc::new(2);
let num3 = Rc::new(3);
let closure = {
    // `num1` is moved
    let num2 = num2.clone();  // `num2` is cloned
    let num3 = num3.as_ref();  // `num3` is borrowed
    move || {
        *num1 + *num2 + *num3;
    }
};
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#pfud03---函数返回值不要使用-return" id="pfud03---函数返回值不要使用-return">P.FUD.03   函数返回值不要使用 <code>return</code></a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 中函数块会自动返回最后一个表达式的值，不需要显式地指定 Return。</p>
<p>只有在函数过程中需要提前返回的时候再加 Return。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x: usize) -&gt; usize {
    if x &lt; 42{
        return x;
    }
    x + 1
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x: usize) -&gt; usize {
    if x &lt; 42{
        return x;
    }
    return x + 1;
}
<span class="boring">}
</span></code></pre></pre>
<hr />
<h2><a class="header" href="#gfud01--函数参数最长不要超过-五-个" id="gfud01--函数参数最长不要超过-五-个">G.FUD.01  函数参数最长不要超过 五 个</a></h2>
<h3><a class="header" href="#级别建议-90" id="级别建议-90">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-81" id="lint-检测-81">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#too_many_arguments">too_many_arguments</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
</tbody></table>
<p>该 lint 对应 <code>clippy.toml</code> 配置项：</p>
<pre><code class="language-toml"># 函数参数最长不要超过5个
too-many-arguments-threshold=5
</code></pre>
<h3><a class="header" href="#描述-111" id="描述-111">【描述】</a></h3>
<p>为了提升代码可读性，函数的参数最长不宜超过五个。</p>
<p>【正例】</p>
<p>想办法把过长的参数缩短。</p>
<pre><pre class="playground"><code class="language-rust">struct Color;
// 此处使用 常量泛型（const generic） 来接收后面多个 u32 类型的参数
// 使用元组 缩短 2~3 个参数为一个参数
fn foo&lt;T, const N: usize&gt;(x: (f32, f32), name: &amp;str, c: Color, last: [T; N]) {
    ;
}

fn main(){
    let arr = [1u32, 2u32];
    foo((1.0f32, 2.0f32), &quot;hello&quot;, Color, arr);
    let arr = [1.0f32, 2.0f32, 3.0f32];
    foo((1.0f32, 2.0f32), &quot;hello&quot;, Color, arr);
}
</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Color;
fn foo(x: f32, y: f32, name: &amp;str, c: Color, w: u32, h: u32, a: u32, b: u32) {
    // ..
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gfud02---当函数参数实现了-copy并且是按值传入如果值可能会太大则应该考虑按引用传递" id="gfud02---当函数参数实现了-copy并且是按值传入如果值可能会太大则应该考虑按引用传递">G.FUD.02   当函数参数实现了 Copy，并且是按值传入，如果值可能会太大，则应该考虑按引用传递</a></h2>
<h3><a class="header" href="#级别建议-91" id="级别建议-91">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-82" id="lint-检测-82">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#large_types_passed_by_value">large_types_passed_by_value</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<p>该 lint 对应 <code>clippy.toml</code> 配置项：</p>
<pre><code class="language-toml"># 如果函数是被导出的 API，则该 lint 不会被触发，是防止 lint 建议对 API 有破坏性的改变。默认为 true
avoid-breaking-exported-api=true 
</code></pre>
<h3><a class="header" href="#描述-112" id="描述-112">【描述】</a></h3>
<p>通过值传递的参数可能会导致不必要的 <code>memcpy</code> 拷贝，这可能会造成性能损失。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy)]
struct TooLarge([u8; 2048]);

// Good
fn foo(v: &amp;TooLarge) {}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy)]
struct TooLarge([u8; 2048]);

// Bad
fn foo(v: TooLarge) {}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gfud03---当函数参数出现太多-bool-类型的参数时应该考虑将其封装为自定义的结构体或枚举" id="gfud03---当函数参数出现太多-bool-类型的参数时应该考虑将其封装为自定义的结构体或枚举">G.FUD.03   当函数参数出现太多 bool 类型的参数时，应该考虑将其封装为自定义的结构体或枚举</a></h2>
<h3><a class="header" href="#级别建议-92" id="级别建议-92">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-83" id="lint-检测-83">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#fn_params_excessive_bools">fn_params_excessive_bools</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<p>该 lint 对应 <code>clippy.toml</code> 配置项：</p>
<pre><code class="language-toml"># 用于配置函数可以拥有的 bool 类型参数最大数量，默认为 3。
max-fn-params-bools=3 
</code></pre>
<h3><a class="header" href="#描述-113" id="描述-113">【描述】</a></h3>
<p>布尔类型的参数过多，很难让人记住，容易出错。将其封装为枚举或结构体，可以更好地利用类型系统的检查而避免出错。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Shape {
    Round,
    Spiky,
}

enum Temperature {
    Hot,
    IceCold,
}

fn f(shape: Shape, temperature: Temperature) { ... }
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f(is_round: bool, is_hot: bool) { ... }
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gfud04---当copy-类型的足够小的值作为函数参数时应该按值by-value传入而不是引用by-ref" id="gfud04---当copy-类型的足够小的值作为函数参数时应该按值by-value传入而不是引用by-ref">G.FUD.04   当Copy 类型的足够小的值作为函数参数时，应该按值（by-value）传入，而不是引用(by-ref)</a></h2>
<h3><a class="header" href="#级别建议-93" id="级别建议-93">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-84" id="lint-检测-84">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#trivially_copy_pass_by_ref">trivially_copy_pass_by_ref</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<p>该 lint 对应 <code>clippy.toml</code> 配置项：</p>
<pre><code class="language-toml"># 如果函数是被导出的 API，则该 lint 不会被触发，是防止 lint 建议对 API 有破坏性的改变。默认为 true
avoid-breaking-exported-api=true
# 考虑Copy按值而不是按引用传递的类型的最大大小（以字节为单位）。默认是None
trivial-copy-size-limit=None
</code></pre>
<p><strong>注意</strong>，该 lint 没有考虑指针相关的情况，见例外示例。需要酌情考虑使用。例外示例来自  <a href="https://github.com/rust-lang/rust-clippy/issues/5953">rust-clippy/issues/5953</a> 。</p>
<h3><a class="header" href="#描述-114" id="描述-114">【描述】</a></h3>
<p>在函数参数为 Copy 类型 且 其值足够小的时候，一般情况下，会避免传引用。因为对于这种小的值，性能上和按引用传递是一样快的，并且在代码更容易编写和可读。包括一些小的 结构体，也推荐按值传递，但要注意【例外】示例所示的情况。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(v: u32) {}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(v: &amp;u32) {}
<span class="boring">}
</span></code></pre></pre>
<p>【例外】</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone, Copy)]
struct RawPoint {
    pub x: u8,
}

#[derive(Clone, Copy)]
struct Point {
    pub raw: RawPoint,
}

impl Point {
    pub fn raw(&amp;self) -&gt; *const RawPoint {
        &amp;self.raw
    }
    // 如果听信 lint 的建议，将上面的 raw 函数参数 self 的引用去掉就是 raw_linted 函数
    pub fn raw_linted(self) -&gt; *const RawPoint {
        &amp;self.raw
    }
}

fn main() {
    let p = Point { raw: RawPoint { x: 10 } };

    // This passes
    assert_eq!(p.raw(), p.raw());
    // This fails 事实上，如果去掉那个 self 的引用，该函数的行为就变了
    // 因为 结构体 Point 是 Copy 的，每次调用 raw_linted 方法，结构体实例就会被复制一次，得到的结果就不一样了
    assert_eq!(p.raw_linted(), p.raw_linted());
}
</code></pre></pre>
<h2><a class="header" href="#gfud05---函数参数是不可变借用的时候返回值不应该是可变借用" id="gfud05---函数参数是不可变借用的时候返回值不应该是可变借用">G.FUD.05   函数参数是不可变借用的时候，返回值不应该是可变借用</a></h2>
<h3><a class="header" href="#级别建议-94" id="级别建议-94">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-85" id="lint-检测-85">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#mut_from_ref">mut_from_ref</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-115" id="描述-115">【描述】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(&amp;Foo) -&gt; &amp;Bar { .. }
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(&amp;Foo) -&gt; &amp;mut Bar { .. }
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gfud06---不要为函数指定--inlinealways" id="gfud06---不要为函数指定--inlinealways">G.FUD.06   不要为函数指定  <code>inline(always)</code></a></h2>
<h3><a class="header" href="#级别建议-95" id="级别建议-95">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-86" id="lint-检测-86">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#inline_always">inline_always</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-116" id="描述-116">【描述】</a></h3>
<p><code>inline</code> 虽然可以提升性能，但也会增加编译时间和编译大小。</p>
<p>Rust 中性能、编译时间和编译大小之间需要权衡。根据需要再 <code>inline</code> 即可。</p>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline(always)]
fn not_quite_hot_code(..) { ... }
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#泛型-1" id="泛型-1">泛型</a></h1>
<p>Rust 中的泛型允许开发人员编写更加简洁、更少重复的代码。但泛型可能会引起编译文件大小膨胀，酌情使用。</p>
<hr />
<h2><a class="header" href="#pgen01----用泛型来抽象公共语义" id="pgen01----用泛型来抽象公共语义">P.GEN.01    用泛型来抽象公共语义</a></h2>
<p><strong>【描述】</strong></p>
<p>应该巧用泛型来抽象公共语义，消除重复代码。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Add;
use std::marker::PhantomData;

#[derive(Debug, Clone, Copy)]
struct Unit&lt;T&gt; {
    value: f64,
    unit_type: PhantomData&lt;T&gt;,
}

impl&lt;T&gt; Unit&lt;T&gt; {
    fn new(value: f64) -&gt; Self {
        Self {
            value,
            unit_type: PhantomData,
        }
    }
}

impl&lt;T&gt; Add for Unit&lt;T&gt; {
    type Output = Unit&lt;T&gt;;

    fn add(self, another: Unit&lt;T&gt;) -&gt; Self::Output {
        let new_value = self.value + another.value;
        Unit::new(new_value)
    }
}

#[derive(Debug, Clone, Copy)]
struct MeterType;

#[derive(Debug, Clone, Copy)]
struct KilogramType;

type Meter = Unit&lt;MeterType&gt;;
type Kilogram = Unit&lt;KilogramType&gt;;
fn main() {
    let one_meter = Meter::new(1.0);
    let two_kilograms = Kilogram::new(2.0);
    
    let two_meters = one_meter + one_meter;
}
</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Add;

#[derive(Debug, Clone, Copy)]
struct Meter {
    value: f64
}

impl Meter {
    fn new(value: f64) -&gt; Self {
        Self { value }
    }
}

impl Add for Meter {
    type Output = Meter;

    fn add(self, another: Meter) -&gt; Self::Output {
        let value = self.value + another.value;
        Meter { value }
    }
}

#[derive(Debug, Clone, Copy)]
struct Kilogram {
    value: f64
}

impl Kilogram {
    fn new(value: f64) -&gt; Self {
        Self { value }
    }
}

impl Add for Kilogram {
    type Output = Kilogram;

    fn add(self, another: Kilogram) -&gt; Self::Output {
        let value = self.value + another.value;
        Kilogram { value }
    }
}
fn main() {
    let one_meter = Meter::new(1.0);
    let two_kilograms = Kilogram::new(2.0);
    
    let two_meters = one_meter + one_meter;
}

</code></pre></pre>
<h2><a class="header" href="#pgen02--不要随便使用-impl-trait-语法替代泛型限定" id="pgen02--不要随便使用-impl-trait-语法替代泛型限定">P.GEN.02  不要随便使用 <code>impl Trait</code> 语法替代泛型限定</a></h2>
<p><strong>【描述】</strong></p>
<p><code>impl Trait</code> 语法 和 泛型限定，虽然都是静态分发，且效果类似，但是它们的语义是不同的。</p>
<p><strong>在类型系统层面上的语义：</strong></p>
<ol>
<li><code>impl Trait</code> 是 存在量化类型。意指，存在某一个被限定的类型。</li>
<li>泛型限定 是 通用量化类型。意指，所有被限定的类型。</li>
</ol>
<p>要根据它们的语义来选择不同的写法。</p>
<p>另外，<code>impl Trait</code> 可以用在函数参数位置和返回值位置，但是不同位置意义不同。</p>
<p><strong>函数参数位置</strong></p>
<p>等价于 泛型参数。</p>
<p>但要注意：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f(b1: impl Bar, b2: impl Bar) -&gt; usize
<span class="boring">}
</span></code></pre></pre>
<p>等价于：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;B1: Bar, B2: Bar&gt;(b1: B1, b2: B2) -&gt; usize
<span class="boring">}
</span></code></pre></pre>
<p>而不是</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;B: Bar&gt;(b1: B, b2: B) -&gt; usize
<span class="boring">}
</span></code></pre></pre>
<p>证明示例：</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

// 函数参数可以传入 整数，但是函数返回值是 String
fn func(arg: impl Display) -&gt; impl Display {
    format!(&quot;Hay! I am not the same as \&quot;{}\&quot;&quot;, arg)
}

// 很明显不等价于下面这类
// fn somefunc2&lt;T: Display&gt;(arg: T) -&gt; T {
//     // 需要指定同一个类型 T 的行为
// }

fn main(){
    let a  = 42;
    let a = func(42);
}
</code></pre></pre>
<p><strong>函数返回值</strong></p>
<p>在返回值位置上，如果是泛型参数，则是由调用者来选择具体类型，比如 <code>parse::&lt;i32&gt;(&quot;32&quot;)</code> ； 如果是 <code>impl Trait</code>，则是由被调用者来决定具体类型，但只能有一种类型。</p>
<p>在返回值位置上的 <code>impl Trait</code> 会根据函数体的返回值自动推断实现了哪些  auto trait。这意味着你不必在 <code>impl Trait</code> 后面再 加 <code>Sync + Send </code> 这种auto trait。</p>
<p>注意下面代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Error： 这里只允许有同一种具体类型，Foo 和 Baz 都实现了 Bar 也是错的。
fn f(a: bool) -&gt; impl Bar {
    if a {
        Foo { ... }
    } else {
        Baz { ... }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#pgen03---不要使用太多泛型参数和-trait-限定否则会增长编译时间" id="pgen03---不要使用太多泛型参数和-trait-限定否则会增长编译时间">P.GEN.03   不要使用太多泛型参数和 trait 限定，否则会增长编译时间</a></h2>
<p><strong>【描述】</strong></p>
<p>为泛型函数添加详细的trait 限定，可以在一定程度上增强用户使用体验，但使用过多的泛型参数和 trait 限定会显著地增长编译时间。</p>
<p>【正例】</p>
<p>来自于 Web 框架 Axum 的代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // From: https://github.com/tokio-rs/axum/pull/198
    fn handle_error&lt;ReqBody, F&gt;(
        self,
        f: F,
    ) -&gt; HandleError&lt;Self, F, ReqBody, HandleErrorFromRouter&gt; {
        HandleError::new(self, f)
    }   
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<p>以下写法比上面的写法编译时间要多十倍。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // From: https://github.com/tokio-rs/axum/pull/198
    fn handle_error&lt;ReqBody, ResBody, F, Res, E&gt;(
        self,
        f: F,
    ) -&gt; HandleError&lt;Self, F, ReqBody, HandleErrorFromRouter&gt;
    where
        Self: Service&lt;Request&lt;ReqBody&gt;, Response = Response&lt;ResBody&gt;&gt;,
        F: FnOnce(Self::Error) -&gt; Result&lt;Res, E&gt;,
        Res: IntoResponse,
        ResBody: http_body::Body&lt;Data = Bytes&gt; + Send + Sync + 'static,
        ResBody::Error: Into&lt;BoxError&gt; + Send + Sync + 'static,
    {
        HandleError::new(self, f)
    }
<span class="boring">}
</span></code></pre></pre>
<hr />
<h2><a class="header" href="#ggen01-----泛型参数必须先声明再使用" id="ggen01-----泛型参数必须先声明再使用">G.GEN.01     泛型参数必须先声明再使用</a></h2>
<h3><a class="header" href="#级别规则" id="级别规则">【级别：规则】</a></h3>
<p>按此规范执行。</p>
<h3><a class="header" href="#lint-检测-87" id="lint-检测-87">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>yes</td><td>_</td><td>_</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-117" id="描述-117"><strong>【描述】</strong></a></h3>
<p>泛型参数必须先被声明，才能被使用。如果一个类型中包含泛型类型，也必须为其声明泛型参数。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;T&gt; { x: T }

struct Bar&lt;T&gt; { x: Foo&lt;T&gt; }
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;T&gt; { x: T }

struct Bar { x: Foo } // error[E0107]: missing generics for struct `Foo`
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#ggen02---不要在泛型位置上使用内建类型" id="ggen02---不要在泛型位置上使用内建类型">G.GEN.02   不要在泛型位置上使用内建类型</a></h2>
<h3><a class="header" href="#级别建议-96" id="级别建议-96">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-88" id="lint-检测-88">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#builtin_type_shadow">builtin_type_shadow</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-118" id="描述-118">【描述】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Foo&lt;T&gt; {
    fn impl_func(&amp;self) -&gt; T {
        42
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<p>这里 <code>u32</code> 会被认为是一个类型参数。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;u32&gt; Foo&lt;u32&gt; {
    fn impl_func(&amp;self) -&gt; u32 {
        42
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#ggen03---使用-rust-标准库中某些方法要注意避免使用其泛型默认实现而应该使用具体类型的实现" id="ggen03---使用-rust-标准库中某些方法要注意避免使用其泛型默认实现而应该使用具体类型的实现">G.GEN.03   使用 Rust 标准库中某些方法，要注意避免使用其泛型默认实现，而应该使用具体类型的实现</a></h2>
<h3><a class="header" href="#级别建议-97" id="级别建议-97">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-89" id="lint-检测-89">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#inefficient_to_string">inefficient_to_string</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-119" id="描述-119">【描述】</a></h3>
<p>Rust 标准库内部某些类型使用了 泛型特化（未稳定特性），比如 <code>ToString</code> trait。</p>
<p>该 trait 有一个<a href="https://doc.rust-lang.org/stable/src/alloc/string.rs.html#2369">泛型默认实现</a>， 并且一些具体类型也实现了它，比如 <code>char</code>/ <code>str</code> /  <code>u8</code>/ <code>i8</code> 等。</p>
<p>在实际代码中，应该选择去调用具体类型实现的 <code>to_string()</code> 方法，而非调用泛型的默认实现。 </p>
<p><strong>这一规则要求开发者对 Rust 标准库的一些方法实现有一定了解。</strong> </p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 闭包参数中， s 为 `&amp;&amp;str` 类型，使用 `|&amp;s|` 对参数模式匹配后，闭包体内 `s` 就变成了 `&amp;str` 类型
// 经过这样的转换，直接调用 `&amp;str`的 `to_string()` 方法，而如果是 `&amp;&amp;str` 就会去调用泛型的默认实现。 
[&quot;foo&quot;, &quot;bar&quot;].iter().map(|&amp;s| s.to_string() );
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 闭包参数中， s 为 `&amp;&amp;str` 类型
//  `&amp;&amp;str` 就会去调用泛型的默认实现
[&quot;foo&quot;, &quot;bar&quot;].iter().map(|&amp;s| s.to_string() );
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#ggen04--为泛型类型实现方法时impl-中声明的泛型类型参数一定要被用到" id="ggen04--为泛型类型实现方法时impl-中声明的泛型类型参数一定要被用到">G.GEN.04  为泛型类型实现方法时，<code>impl</code> 中声明的泛型类型参数一定要被用到</a></h2>
<h3><a class="header" href="#级别规则-1" id="级别规则-1">【级别：规则】</a></h3>
<p>按此规范执行。</p>
<h3><a class="header" href="#lint-检测-90" id="lint-检测-90">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>yes</td><td>_</td><td>_</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-120" id="描述-120"><strong>【描述】</strong></a></h3>
<p>在 <code>impl</code> 中被声明的类型参数，至少要满足下面三种形式：</p>
<ol>
<li><code>impl&lt;T&gt; Foo&lt;T&gt;</code>，  <code>T</code>  出现在实现的<code>Self</code> 类型<code>Foo&lt;T&gt;</code> 中 。</li>
<li><code>impl&lt;T&gt; SomeTrait&lt;T&gt; for Foo</code> ， <code>T</code>出现在要实现的 trait 中 。</li>
<li><code>impl&lt;T, U&gt; SomeTrait for T where T: AnotherTrait&lt;AssocType=U&gt;</code> ， 出现在 <code>T</code> 的 trait 限定的关联类型中。</li>
</ol>
<p>除此之外，都不算 <code>T</code> 被用到（出现在 Self 类型中）。</p>
<p>有这种限制，主要有两个原因：</p>
<ol>
<li>方便 Rust 类型推断。有这些限制才能明确能推断这些泛型参数的行为，避免产生错误。参考 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0447-no-unused-impl-parameters.md">RFC 0447 </a> 。</li>
<li>避免语义定义不明确的情况。如果 <code>impl</code> 上存在自由的 泛型参数，则无法保证这一点。</li>
</ol>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// case 1
struct Foo;

// Move the type parameter from the impl to the method
impl Foo {
    fn get&lt;T: Default&gt;(&amp;self) -&gt; T {
        &lt;T as Default&gt;::default()
    }
}

// case 2
use std::marker::PhantomData;

trait Maker {
    type Item;
    fn make(&amp;mut self) -&gt; Self::Item;
}

struct Foo&lt;T&gt; {
    foo: T
}

// Add a type parameter to `FooMaker`
struct FooMaker&lt;T&gt; {
    phantom: PhantomData&lt;T&gt;,
}

impl&lt;T: Default&gt; Maker for FooMaker&lt;T&gt; {
    type Item = Foo&lt;T&gt;;

    fn make(&amp;mut self) -&gt; Foo&lt;T&gt; {
        Foo {
            foo: &lt;T as Default&gt;::default(),
        }
    }
}

// closue : 相关 issue:  https://github.com/rust-lang/rust/issues/25041 
trait Foo {}
impl&lt;F, A&gt; Foo for F where F: Fn() -&gt; A {} // 此处 A 是 闭包trait内的一个关联类型
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// case 1

struct Foo;

impl&lt;T: Default&gt; Foo {
    // error: the type parameter `T` is not constrained by the impl trait, self
    // type, or predicates [E0207]
    fn get(&amp;self) -&gt; T {
        &lt;T as Default&gt;::default()
    }
}

// case 2
trait Maker {
    type Item;
    fn make(&amp;mut self) -&gt; Self::Item;
}
struct Foo&lt;T&gt; {
    foo: T
}
struct FooMaker;
impl&lt;T: Default&gt; Maker for FooMaker {
// error: the type parameter `T` is not constrained by the impl trait, self
// type, or predicates [E0207]
    type Item = Foo&lt;T&gt;;

    fn make(&amp;mut self) -&gt; Foo&lt;T&gt; {
        Foo { foo: &lt;T as Default&gt;::default() }
    }
}

// error: the type parameter `A` is not constrained by the impl trait, self type, or predicates
trait Foo {}
impl&lt;F, A&gt; Foo for F where F: Fn(A) {} // error
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#ggen05---定义泛型函数时如果该函数实现用到来自-trait-定义的相关行为需要为泛型指定相关-trait-的限定" id="ggen05---定义泛型函数时如果该函数实现用到来自-trait-定义的相关行为需要为泛型指定相关-trait-的限定">G.GEN.05   定义泛型函数时，如果该函数实现用到来自 trait 定义的相关行为，需要为泛型指定相关 trait 的限定</a></h2>
<h3><a class="header" href="#级别规则-2" id="级别规则-2">【级别：规则】</a></h3>
<p>按此规范执行。</p>
<h3><a class="header" href="#lint-检测-91" id="lint-检测-91">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>yes</td><td>_</td><td>_</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-121" id="描述-121"><strong>【描述】</strong></a></h3>
<p>泛型，在 Rust 类型系统中的语义是一种 通用量化l类型（Universally-quantified type），即，泛型类型<code> T</code> 的所有可能 的单态类型。</p>
<p>在泛型函数内部，如果使用了来自某个 trait 定义的行为，则需要为泛型指定相关的 trait 限定，来排除其他没有实现该trait 的类型。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

// 为泛型类型 T 指派 Debug triat 限定
fn some_func&lt;T: fmt::Debug&gt;(foo: T) {
    println!(&quot;{:?}&quot;, foo); 
}

struct A;

fn main() {
   some_func(5i32);
   
   // A 没有实现 Debug trait，会被排除掉
   some_func(A); // error[E0277]: `A` doesn't implement `Debug`
}
</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

// println! 中 `{:?}` 为 Debug triat 定义行为
fn some_func&lt;T&gt;(foo: T) {
    println!(&quot;{:?}&quot;, foo); // error[E0277]: `T` doesn't implement `Debug`
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#特质" id="特质">特质</a></h1>
<p>特质就是指 trait。在 Rust 中， trait 不是具体类型，而是一种抽象接口。但是通过 <code>impl Trait</code> 和 <code>dyn Trait</code> 也可以将 trait 作为类型使用。</p>
<ul>
<li><a href="safe-guides/coding_practice/./trait/std-buildin.html">内置trait</a></li>
<li><a href="safe-guides/coding_practice/./traits/trait-object.html">trait 对象</a></li>
</ul>
<hr />
<h2><a class="header" href="#gtra01--使用-trait-时要注意-trait-一致性规则" id="gtra01--使用-trait-时要注意-trait-一致性规则">G.TRA.01  使用 trait 时要注意 trait 一致性规则</a></h2>
<h3><a class="header" href="#级别规则-3" id="级别规则-3">【级别：规则】</a></h3>
<p>按此规范执行。</p>
<h3><a class="header" href="#lint-检测-92" id="lint-检测-92">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>yes</td><td>_</td><td>_</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-122" id="描述-122"><strong>【描述】</strong></a></h3>
<p>使用 trait 的时候，必须要满足 trait 一致性规则，即，<strong>孤儿规则（orphans rule）</strong>：类型和trait，必须有一个是在本地crate内定义的。</p>
<h1><a class="header" href="#内置-trait" id="内置-trait">内置 trait</a></h1>
<p>Rust 标准库内置了很多 trait，在使用这些 trait 的时候也需要注意。</p>
<h2><a class="header" href="#ptrabuitin01--在实现-borrow-trait--的时候需要注意一致性" id="ptrabuitin01--在实现-borrow-trait--的时候需要注意一致性">P.TRA.Buitin.01  在实现 <code>Borrow</code> trait  的时候，需要注意一致性</a></h2>
<p><strong>【描述】</strong></p>
<p>当你想把不同类型的借用进行统一抽象，或者当你要建立一个数据结构，以同等方式处理自拥有值（ownered）和借用值（borrowed）时，例如散列（hash）和比较（compare）时，选择<code> Borrow</code>。当把某个类型直接转换为引用，选择 <code>AsRef</code> 。</p>
<p>但是使用 <code>Borrow</code> 的时候，需要注意一致性问题。具体请看示例。</p>
<p>【示例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 这个结构体能不能作为 HashMap 的 key？
pub struct CaseInsensitiveString(String);

// 它实现 Eq 没有问题
impl  PartialEq for CaseInsensitiveString {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
       // 但这里比较是要求忽略了 ascii 大小写
        self.0.eq_ignore_ascii_case(&amp;other.0)
    }
}

impl Eq for CaseInsensitiveString { }

// 实现 Hash 没有问题
// 但因为 eq 忽略大小写，那么 hash 计算也必须忽略大小写
impl Hash for CaseInsensitiveString {
    fn hash&lt;H: Hasher&gt;(&amp;self, state: &amp;mut H) {
        for c in self.0.as_bytes() {
            // 没有忽略大小写
            c.to_ascii_lowercase().hash(state)
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这种情况下，就不能为 <code>CaseInsensitiveString</code> 实现 <code>Borrow</code>，并非编译不通过，而是在逻辑上不应该为其实现 <code>Borrow</code>，因为  <code>CaseInsensitiveString</code>  实现 <code>Eq</code> 和 <code>Hash</code> 的行为不一致，而 <code>HashMap</code> 则要求 <code>Key</code> 必须 <code>Hash</code> 和 <code>Eq</code> 的实现一致。这种不一致，编译器无法检查，所以在逻辑上，就不应该为其实现 <code>Borrow</code>。如果强行实现，那可能会出现逻辑 Bug。</p>
<hr />
<h2><a class="header" href="#gtrabuitin01---应该具体类型的-default-方法代替--defaultdefault-调用" id="gtrabuitin01---应该具体类型的-default-方法代替--defaultdefault-调用">G.TRA.Buitin.01   应该具体类型的 <code>default()</code> 方法代替 <code> Default::default()</code> 调用</a></h2>
<h3><a class="header" href="#级别建议-98" id="级别建议-98">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-93" id="lint-检测-93">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#default_trait_access">default_trait_access</a></td><td>yes</td><td>no</td><td><strong>pedantic</strong></td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-123" id="描述-123">【描述】</a></h3>
<p>为了增强可读性。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::default();
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: String = Default::default();
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gtrabuitin02----不要为迭代器实现copy-trait" id="gtrabuitin02----不要为迭代器实现copy-trait">G.TRA.Buitin.02    不要为迭代器实现<code>Copy</code> trait</a></h2>
<h3><a class="header" href="#级别建议-99" id="级别建议-99">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-94" id="lint-检测-94">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#copy_iterator">copy_iterator</a></td><td>yes</td><td>no</td><td><strong>pedantic</strong></td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-124" id="描述-124">【描述】</a></h3>
<p>在 Rust 中，迭代器是不能实现 Copy 的。因为在需要迭代修改的场景，因为 Copy 的存在，而失去效果。</p>
<p>【反例】</p>
<p>比如，对于标准库里的 <code>Range&lt;T&gt;</code> 就不能实现 Copy，因为它也是一个迭代器。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut iter = 0..n;
for i in iter { if i &gt; 2 { break; } }
iter.collect();
<span class="boring">}
</span></code></pre></pre>
<p>如果它实现了 Copy，示例中 iter 的值将不会被改变，这样就不符合预期结果。</p>
<h2><a class="header" href="#gtrabuitin03---能使用derive-自动实现default--trait-就不要用手工实现" id="gtrabuitin03---能使用derive-自动实现default--trait-就不要用手工实现">G.TRA.Buitin.03   能使用<code>derive</code> 自动实现<code>Default</code>  trait 就不要用手工实现</a></h2>
<h3><a class="header" href="#级别规则-4" id="级别规则-4">【级别：规则】</a></h3>
<p>按此规范执行。</p>
<h3><a class="header" href="#lint-检测-95" id="lint-检测-95">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#derivable_impls">derivable_impls</a></td><td>yes</td><td>no</td><td><strong>complexity</strong></td><td>warn</td></tr>
</tbody></table>
<p>该lint不能用于检测泛型参数类型的 Default 手工实现。</p>
<h3><a class="header" href="#描述-125" id="描述-125">【描述】</a></h3>
<p>手工实现 Default，代码不精炼。 </p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct Foo {
    bar: bool
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    bar: bool
}

impl std::default::Default for Foo {
    fn default() -&gt; Self {
        Self {
            bar: false
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gtrabuitin04---在使用derivehash-的时候避免再手工实现-partialeq" id="gtrabuitin04---在使用derivehash-的时候避免再手工实现-partialeq">G.TRA.Buitin.04   在使用<code>#[derive(Hash)]</code> 的时候，避免再手工实现 <code>PartialEq</code></a></h2>
<h3><a class="header" href="#级别建议-100" id="级别建议-100">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-96" id="lint-检测-96">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#derive_hash_xor_eq">derive_hash_xor_eq</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-126" id="描述-126">【描述】</a></h3>
<p>实现 Hash 和 Eq 必须要满足下面一个等式：</p>
<pre><code class="language-text">k1 == k2  -&gt; hash(k1) == hash(k2)
</code></pre>
<p>即，当<code>k1</code> 和 <code>k2</code> 相等时，<code>hash(k1)</code>也应该和 <code>hash(k2)</code> 相等。  所以要求 <code>PartialEq</code> / <code>Eq</code> / <code>Hash</code>  的实现必须保持一致。 </p>
<p>如果用 <code>#[derive(Hash)]</code> 的时候，搭配了一个手工实现的 <code>PartialEq</code> 就很可能出现不一致的情况。</p>
<p>但也有例外。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq, Eq, Hash)]
struct Foo;
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Hash)]
struct Foo;

impl PartialEq for Foo {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>【例外】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From: https://docs.rs/crate/blsttc/3.3.0/source/src/lib.rs

// Clippy warns that it's dangerous to derive `PartialEq` and explicitly implement `Hash`, but the
// `pairing::bls12_381` types don't implement `Hash`, so we can't derive it.
#![allow(clippy::derive_hash_xor_eq)]
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gtrabuitin05---在使用deriveord-的时候避免再手工实现-partialord" id="gtrabuitin05---在使用deriveord-的时候避免再手工实现-partialord">G.TRA.Buitin.05   在使用<code>#[derive(Ord)]</code> 的时候，避免再手工实现 <code>PartialOrd</code></a></h2>
<h3><a class="header" href="#级别建议-101" id="级别建议-101">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-97" id="lint-检测-97">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#derive_ord_xor_partial_ord">derive_ord_xor_partial_ord</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-127" id="描述-127">【描述】</a></h3>
<p>跟实现 Hash 和 Eq 的要求类似，对于实现<code> Ord</code> 的类型来说，必须要满足下面一个等式：</p>
<pre><code class="language-text">k1.cmp(&amp;k2) == k1.partial_cmp(&amp;k2).unwrap()
</code></pre>
<p>所以要求与  <code>PartialOrd</code>   的实现必须保持一致，并确保<code>max</code>、<code>min</code>和<code>clamp</code>与<code>cmp</code>一致。</p>
<p>通过<code>#[derive(Ord)]</code> 并手动实现<code>PartialOrd</code>，很容易意外地使cmp和partial_cmp不一致。</p>
<p>但也有例外。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Ord, PartialOrd, PartialEq, Eq)]
struct Foo;

// or

#[derive(PartialEq, Eq)]
struct Foo;

impl PartialOrd for Foo {
    fn partial_cmp(&amp;self, other: &amp;Foo) -&gt; Option&lt;Ordering&gt; {
       Some(self.cmp(other))
    }
}

impl Ord for Foo {
    ...
}

<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Ord, PartialEq, Eq)]
struct Foo;

impl PartialOrd for Foo {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>【例外】</p>
<p>使用 <code>#[derive(PartialOrd)]</code> 自动实现 <code>PartialOrd</code>，然后再手工实现 <code>Ord</code>的时候在内部调用自动实现的<code>partial_cmp</code> ，应该是满足 <code>k1.cmp(&amp;k2) == k1.partial_cmp(&amp;k2).unwrap()</code> 了。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From: https://docs.rs/crate/adventjson/0.1.1/source/src/lib.rs
#[derive(Clone, Debug, PartialEq, PartialOrd)]
pub enum JsonObject
{
    /// An array of objects (e.g.: \[1,2,3\])
    Array(Vec&lt;Self&gt;),
    /// Key-value pairs (e.g.: {\&quot;first\&quot;: 10, \&quot;other\&quot;: 15})
    Obj(Vec&lt;(String, Self)&gt;),
    /// A number (e.g.: -0.08333)
    Number(f64),
    /// A string (e.g.: \&quot;Test: \\\&quot;\&quot;)
    JsonStr(String),
    /// A boolean (e.g. true)
    Bool(bool),
    /// The null-value
    Null,
}

/// Save because no not-number values are allowed in json
impl Eq for JsonObject {}

/// Save because no not-number values are allowed in json
#[allow(clippy::derive_ord_xor_partial_ord)]
impl Ord for JsonObject
{
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering
    {
        self.partial_cmp(other).unwrap()
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gtrabuitin06----不要对实现-copy--或引用类型调用--stdmemdrop-和-stdmemforgot" id="gtrabuitin06----不要对实现-copy--或引用类型调用--stdmemdrop-和-stdmemforgot">G.TRA.Buitin.06    不要对实现 <code>Copy</code>  或引用类型调用  <code>std::mem::drop</code> 和 <code>std::mem::forgot</code></a></h2>
<h3><a class="header" href="#级别建议-102" id="级别建议-102">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-98" id="lint-检测-98">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#drop_copy">drop_copy</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#drop_ref">drop_ref</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#forget_copy">forget_copy</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#forget_ref">forget_ref</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#undropped_manually_drops">undropped_manually_drops</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-128" id="描述-128">【描述】</a></h3>
<p><code>std::mem::drop</code> 函数只是利用 Rust 所有权的一个技巧，对于 实现了 Copy 的类型 或引用，是无效的。如果使用它，对导致代码可读方便产生误导作用。</p>
<p>另外<code>std::mem::drop</code> 也无法 Drop 掉 <code>ManuallyDrop</code> 类型。</p>
<p><code>std::mem::forgot</code>   同理。</p>
<p>但是也存在例外的情况。</p>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: i32 = 42; // i32 implements Copy
std::mem::drop(x) // A copy of x is passed to the function, leaving the
                  // original unaffected
<span class="boring">}
</span></code></pre></pre>
<p>【例外】</p>
<p>在某些情况下，虽然不会有实际效果，但是为了提升语义，也可以使用。</p>
<p>下面代码中，为了防止自引用的问题，使用 <code>drop(self)</code> ，提升了代码语义，但实际并不会 drop。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From: https://docs.rs/crate/dhall/0.10.1/source/src/error/builder.rs

#[allow(clippy::drop_ref)]
pub fn format(&amp;mut self) -&gt; String {
    if self.consumed {
        panic!(&quot;tried to format the same ErrorBuilder twice&quot;)
    }
    let this = std::mem::take(self);
    self.consumed = true;
    drop(self); // Get rid of the self reference so we don't use it by mistake.
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gtrabuitin07---对实现-copy-的可迭代类型来说要通过迭代器拷贝其所有元素时应该使用-copied方法而非cloned" id="gtrabuitin07---对实现-copy-的可迭代类型来说要通过迭代器拷贝其所有元素时应该使用-copied方法而非cloned">G.TRA.Buitin.07   对实现 <code>Copy</code> 的可迭代类型来说，要通过迭代器拷贝其所有元素时，应该使用 <code>copied</code>方法，而非<code>cloned</code></a></h2>
<h3><a class="header" href="#级别建议-103" id="级别建议-103">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-99" id="lint-检测-99">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cloned_instead_of_copied">cloned_instead_of_copied</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-129" id="描述-129">【描述】</a></h3>
<p><code>copied</code> 方法在语义层面，是针对实现 <code>Copy</code> 的类型，所以应该使用 <code>copied</code> 来增加代码可读性。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3];

let v_copied: Vec&lt;_&gt; = a.iter().copied().collect();
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3];

let v_copied: Vec&lt;_&gt; = a.iter().cloned().collect();
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gtrabuitin08-实现-from-而不是-into" id="gtrabuitin08-实现-from-而不是-into">G.TRA.Buitin.08 实现 <code>From</code> 而不是 <code>Into</code></a></h2>
<h3><a class="header" href="#级别建议-104" id="级别建议-104">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-100" id="lint-检测-100">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#from_over_into">from_over_into</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-130" id="描述-130">【描述】</a></h3>
<p>优先为类型实现 <code>From</code> 而非 <code>Into</code>。因为实现了 <code>From</code>，<code>Into</code> 也会被自动实现。并且在错误处理的时候，<code>?</code> 操作符会通过调用 <code>From</code> 实现自动进行错误类型转换。</p>
<p>但是在泛型限定上，优先 <code>Into</code> 。</p>
<p>当然，也存在例外。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct StringWrapper(String);

impl From&lt;String&gt; for StringWrapper {
    fn from(s: String) -&gt; StringWrapper {
        StringWrapper(s)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct StringWrapper(String);

impl Into&lt;StringWrapper&gt; for String {
    fn into(self) -&gt; StringWrapper {
        StringWrapper(self)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>【例外】</p>
<p>有两类情况，可以直接实现 <code>Into</code>。</p>
<ol>
<li><code>Into</code> 不提供 <code>From</code> 实现。在一些场景中，<code>From</code>  自动实现的 <code>Into</code> 并不符合转换需求。</li>
<li>使用 <code>Into</code> 来跳过孤儿规则。</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 第一种情况。 
// From： https://github.com/apache/arrow-datafusion/blob/master/ballista/rust/core/src/serde/scheduler/from_proto.rs
#[allow(clippy::from_over_into)]
impl Into&lt;PartitionStats&gt; for protobuf::PartitionStats {
    fn into(self) -&gt; PartitionStats {
        PartitionStats::new(
            foo(self.num_rows),
            foo(self.num_batches),
            foo(self.num_bytes),
        )
    }
}

// From： https://github.com/apache/arrow-datafusion/blob/master/ballista/rust/core/src/serde/scheduler/to_proto.rs
#[allow(clippy::from_over_into)]
impl Into&lt;protobuf::PartitionStats&gt; for PartitionStats {
    fn into(self) -&gt; protobuf::PartitionStats {
        let none_value = -1_i64;
        protobuf::PartitionStats {
            num_rows: self.num_rows.map(|n| n as i64).unwrap_or(none_value),
            num_batches: self.num_batches.map(|n| n as i64).unwrap_or(none_value),
            num_bytes: self.num_bytes.map(|n| n as i64).unwrap_or(none_value),
            column_stats: vec![],
        }
    }
}

// 第二种情况
// 根据孤儿规则，trait 和 类型必须有一个在本地定义，所以不能为 Vec&lt;T&gt; 实现 From trait
struct Wrapper&lt;T&gt;(Vec&lt;T&gt;);
impl&lt;T&gt; From&lt;Wrapper&lt;T&gt;&gt; for Vec&lt;T&gt; {
    fn from(w: Wrapper&lt;T&gt;) -&gt; Vec&lt;T&gt; {
        w.0
    }
}
// 但是通过 Into&lt;Vec&lt;T&gt;&gt; ，就可以绕过这个规则
struct Wrapper&lt;T&gt;(Vec&lt;T&gt;);
impl&lt;T&gt; Into&lt;Vec&lt;T&gt;&gt; for Wrapper&lt;T&gt; {
    fn into(self) -&gt; Vec&lt;T&gt; {
        self.0
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gtrabuitin09---一般情况下不要给-copy-类型手工实现-clone" id="gtrabuitin09---一般情况下不要给-copy-类型手工实现-clone">G.TRA.Buitin.09   一般情况下不要给 Copy 类型手工实现 Clone</a></h2>
<h3><a class="header" href="#级别建议-105" id="级别建议-105">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-101" id="lint-检测-101">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#expl_impl_clone_on_copy">expl_impl_clone_on_copy</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-131" id="描述-131">【描述】</a></h3>
<p>手工为 Copy 类型实现 Clone ，并不能改变 Copy 类型的行为。除非你显式地去调用 <code>clone()</code>方法。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy, Clone)]
struct Foo;
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy)]
struct Foo;

impl Clone for Foo {
    // ..
}
<span class="boring">}
</span></code></pre></pre>
<p>【例外】</p>
<p>在有些情况下，需要手动实现 Copy 和 Clone 。 相关 issues : <a href="https://github.com/rust-lang/rust/issues/26925">https://github.com/rust-lang/rust/issues/26925</a> </p>
<pre><pre class="playground"><code class="language-rust">use std::marker::PhantomData;

struct Marker&lt;A&gt;(PhantomData&lt;A&gt;);

// 如果使用 Derive 自动实现的话，会要求 Marker&lt;A&gt; 里的 A 也必须实现 Clone
// 这里通过手工给 Marker&lt;A&gt; 实现 Copy 和 Clone 可以避免这种限制
impl&lt;A&gt; Copy for Marker&lt;A&gt; {}
impl&lt;A&gt; Clone for Marker&lt;A&gt; {
    fn clone(&amp;self) -&gt; Self {
        *self
    }
}

// 不需要给 NoClone 实现 Clone
struct NoClone;
fn main() {
    let m: Marker&lt;NoClone&gt; = Marker(PhantomData);
    let m2 = m.clone();
}
</code></pre></pre>
<h2><a class="header" href="#ptrabuitin10-不要随便使用-deref-trait----来模拟继承" id="ptrabuitin10-不要随便使用-deref-trait----来模拟继承">P.TRA.Buitin.10 不要随便使用 <code>Deref</code> trait    来模拟继承</a></h2>
<h3><a class="header" href="#级别建议-106" id="级别建议-106">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-102" id="lint-检测-102">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-132" id="描述-132"><strong>【描述】</strong></a></h3>
<p><code>Deref</code> trait是专门用于实现自定义指针类型而存在的。虽然可以实现 <code>Deref</code> 来达到某种类似于继承的行为，但 Rust 中不推荐这样做。</p>
<p>这是因为 Rust 语言推崇显式的转换，而 <code>Deref</code> 则是 Rust 中为数不多的隐式行为。如果 <code>Deref</code> 被滥用，那么程序中隐式行为可能会增多，隐式的转换是 Bug 的温床。</p>
<h1><a class="header" href="#trait-对象" id="trait-对象">trait 对象</a></h1>
<p>trait 对象需要注意 动态安全 （dyn safe），也叫对象安全 （object safe），但官方现在倾向于 动态安全这个术语。</p>
<hr />
<h2><a class="header" href="#ptraobject01--除非必要避免使用-trait对象" id="ptraobject01--除非必要避免使用-trait对象">P.TRA.Object.01  除非必要，避免使用 trait对象</a></h2>
<p><strong>【描述】</strong></p>
<p>trait 对象存在一定运行时开销，除非必要，不要滥用，但 triat 对象也可以避免编译文件大小膨胀。</p>
<p>在性能有严格要求的情况下，可以考虑 <code>Enum</code> 或 泛型静态分发 代替。</p>
<p>【示例】</p>
<p>使用 Enum 代替 trait 对象。 示例来自于 <a href="https://docs.rs/enum_dispatch/0.3.7/enum_dispatch/">enum_dispatch</a></p>
<pre><pre class="playground"><code class="language-rust">trait KnobControl {
    fn set_position(&amp;mut self, value: f64);
    fn get_value(&amp;self) -&gt; f64;
}

struct LinearKnob {
    position: f64,
}

struct LogarithmicKnob {
    position: f64,
}

impl KnobControl for LinearKnob {
    fn set_position(&amp;mut self, value: f64) {
        self.position = value;
    }

    fn get_value(&amp;self) -&gt; f64 {
        self.position
    }
}

impl KnobControl for LogarithmicKnob {
    fn set_position(&amp;mut self, value: f64) {
        self.position = value;
    }

    fn get_value(&amp;self) -&gt; f64 {
        (self.position + 1.).log2()
    }
}

fn main() {
    // 这里使用 trait 对象
    let v: Vec&lt;Box&lt;dyn KnobControl&gt;&gt; = vec![
        //set the knobs
    ];

    //use the knobs
}
</code></pre></pre>
<p>用 Enum 代替：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Knob {
    Linear(LinearKnob),
    Logarithmic(LogarithmicKnob),
}

impl KnobControl for Knob {
    fn set_position(&amp;mut self, value: f64) {
        match self {
            Knob::Linear(inner_knob) =&gt; inner_knob.set_position(value),
            Knob::Logarithmic(inner_knob) =&gt; inner_knob.set_position(value),
        }
    }

    fn get_value(&amp;self) -&gt; f64 {
        match self {
            Knob::Linear(inner_knob) =&gt; inner_knob.get_value(),
            Knob::Logarithmic(inner_knob) =&gt; inner_knob.get_value(),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>性能有显著提高，但是牺牲了维护成本。可以借助于宏来自动生成相关代码，参见： <a href="https://docs.rs/enum_dispatch/0.3.7/enum_dispatch/">enum_dispatch</a></p>
<h2><a class="header" href="#ptraobject02--除非必要避免自定义虚表" id="ptraobject02--除非必要避免自定义虚表">P.TRA.Object.02  除非必要，避免自定义虚表</a></h2>
<p><strong>【描述】</strong></p>
<p>trait 对象 <code>dyn Trait</code> 隐藏了复杂而又为危险的虚表实现，为我们提供了简单而又安全的动态分发。手动实现虚表的代码中充斥着大量的 <code>unsafe</code>，稍有不慎，就会引入 bug 。如无必要，不要自定义虚表。</p>
<p>如果你的设计不能使用标准的 <code>dyn Trait</code> 结构来表达，那么你首先应该尝试重构你的程序，并参考以下理由来决定是否使用自定义的虚表。</p>
<ul>
<li>你想要为一类指针对象实现多态，并且无法忍受多级指针解引用造成的性能开销，参考 <a href="https://doc.rust-lang.org/std/task/struct.RawWaker.html">RawWaker</a> 与 <a href="https://docs.rs/bytes/1.1.0/bytes/struct.Bytes.html">Bytes</a>。</li>
<li>你想要自定义内存布局，比如像 C++ 中虚表一样紧凑的内存结构（虚表指针位于对象内），参考 <a href="https://github.com/tokio-rs/tokio/blob/master/tokio/src/runtime/task/raw.rs#L12">RawTask</a>。</li>
<li>你的 crate 需要在 <code>no_std</code> 环境中使用动态分发，参考 <a href="https://doc.rust-lang.org/std/task/struct.RawWaker.html">RawWaker</a>  。</li>
<li>或者，标准的 trait object 确实无法实现你的需求。</li>
</ul>
<h1><a class="header" href="#错误处理" id="错误处理">错误处理</a></h1>
<p>Rust 为了保证系统健壮性，将系统中出现的非正常情况划分为三大类：</p>
<ol>
<li>失败</li>
<li>错误</li>
<li>异常</li>
</ol>
<p>Rust 语言针对这三类非正常情况分别提供了专门的处理方式，让开发者可以分情况去选择。</p>
<ul>
<li>对于失败的情况，可以使用断言工具。</li>
<li>对于错误，Rust 提供了基于返回值的分层错误处理方式，比如 Option 可以用来处理可能存在空值的情况，而 Result 就专门用来处理可以被合理解决并需要传播的错误。</li>
<li>对于异常，Rust 将其看作无法被合理解决的问题，提供了线程恐慌机制，在发生异常的时候，线程可以安全地退出。</li>
</ul>
<hr />
<h2><a class="header" href="#perr01---当传入函数的参数值因为超出某种限制可能会导致函数调用失败应该使用断言" id="perr01---当传入函数的参数值因为超出某种限制可能会导致函数调用失败应该使用断言">P.ERR.01   当传入函数的参数值因为超出某种限制可能会导致函数调用失败，应该使用断言</a></h2>
<p><strong>【描述】</strong></p>
<p>当传入函数的某个参数值可能因为超出某种限制，比如超出数组长度的索引、字符串是否包含某个字符、数组是否为空等，应该使用断言。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From: std::vec::Vec::swap_remove
#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
pub fn swap_remove(&amp;mut self, index: usize) -&gt; T {
    #[cold]
    #[inline(never)]
    fn assert_failed(index: usize, len: usize) -&gt; ! {
        panic!(&quot;swap_remove index (is {}) should be &lt; len (is {})&quot;, index, len);
    }

    let len = self.len();
   
    if index &gt;= len {
        // 此处使用断言方法，虽然不是标准库内置断言宏，但也是一种断言
        assert_failed(index, len);
    }
    unsafe {
        // We replace self[index] with the last element. Note that if the
        // bounds check above succeeds there must be a last element (which
        // can be self[index] itself).
        let last = ptr::read(self.as_ptr().add(len - 1));
        let hole = self.as_mut_ptr().add(index);
        self.set_len(len - 1);
        ptr::replace(hole, last)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#perr02--当函数的返回值-或者-结构体字段的值-可能为空时请使用-optiont" id="perr02--当函数的返回值-或者-结构体字段的值-可能为空时请使用-optiont">P.ERR.02  当函数的返回值 或者 结构体字段的值 可能为空时，请使用 <code>Option&lt;T&gt;</code></a></h2>
<p><strong>【描述】</strong></p>
<p>在某些其他语言中，如果函数的返回值 或 结构体字段的值 可能为空时，通常会设置一个 “哨兵值（Sentinel Value）” 来应对这种问题，比如使用一个 <code>nil</code> 或 <code>-1</code> 等特殊值来判断这类情况。</p>
<p>但是，在 Rust 中不需要这样，Rust 提供了 <code>Option&lt;T&gt;</code> 类型就是专门用于应对这类情况。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">struct Config {
    must: String,
    opt: Option&lt;String&gt;,
}

// OR

fn main() {
    let sentence = &quot;The fox jumps over the dog&quot;;
    let index = sentence.find(&quot;fox&quot;);

    if let Some(fox) = index {
        let words_after_fox = &amp;sentence[fox..];
        println!(&quot;{}&quot;, words_after_fox);
    }
}
</code></pre></pre>
<h2><a class="header" href="#perr03---当程序中有不可恢复的错误时应该让其-panic" id="perr03---当程序中有不可恢复的错误时应该让其-panic">P.ERR.03   当程序中有不可恢复的错误时，应该让其 Panic</a></h2>
<p><strong>【描述】</strong></p>
<p>如果遇到无法恢复的错误，则需要让程序 Panic。</p>
<p>相关 Clippy Lint： <a href="https://rust-lang.github.io/rust-clippy/master/#if_then_panic">if_then_panic</a> </p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn boot(ptr: *const usize) {
	if ptr.is_null() {
        panic!(&quot;ptr is null! boot failed!&quot;)
    }
    // or
    assert!(ptr.is_null(), &quot;ptr is null! boot failed!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#perr04---当程序中需要处理错误时应该使用-resultt-e-和--操作符" id="perr04---当程序中需要处理错误时应该使用-resultt-e-和--操作符">P.ERR.04   当程序中需要处理错误时，应该使用 <code>Result&lt;T, E&gt;</code> 和 <code>?</code> 操作符</a></h2>
<p><strong>【描述】</strong></p>
<p>当需要处理错误时，为了保证 程序的健壮性，应该尽可能处理错误。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let res: Result&lt;usize, ()&gt; = Ok(1);
res?;   // Ok::&lt;(), ()&gt;(())
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<p>在实现原型类项目的时候，可以“快、糙、猛”地使用 <code>expect</code>  。但是要进生产环境，需要合理地处理错误。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let res: Result&lt;usize, ()&gt; = Ok(1);
res.expect(&quot;one&quot;); // 如果有 Err， expect会 Panic ！

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#perr05--在确定--optiont-和-resultt-e类型的值不可能是-none-或-err-时请用---expect-代替--unwrap" id="perr05--在确定--optiont-和-resultt-e类型的值不可能是-none-或-err-时请用---expect-代替--unwrap">P.ERR.05  在确定  <code>Option&lt;T&gt;</code> 和 <code>Result&lt;T, E&gt;</code>类型的值不可能是 <code>None</code> 或 <code>Err</code> 时，请用   <code>expect</code> 代替  <code>unwrap()</code></a></h2>
<p><strong>【描述】</strong></p>
<p>当需要处理的   <code>Option&lt;T&gt;</code> 和 <code>Result&lt;T, E&gt;</code> 类型的值，永远都不可能是 <code>None</code> 或 <code>Err</code> 时，虽然直接 <code>unwrap()</code> 也是可以的，但使用 <code>expect</code> 会有更加明确的语义。</p>
<blockquote>
<p><code>expect</code> 的语义： </p>
<p>我不打算处理 <code>None</code> 或 <code>Err</code> 这种可能性，因为我知道这种可能性永远不会发生，或者，它不应该发生。但是 类型系统并不知道它永远不会发生。所以，我需要像类型系统保证，如果它确实发生了，它可以认为是一种错误，并且程序应该崩溃，并带着可以用于跟踪和修复该错误的栈跟踪信息。</p>
</blockquote>
<p>所以在指定 <code>expect</code> 输出消息的时候，请使用肯定的描述，而非否定，用于提升可读性。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">// 这个配置文件默认会跟随源码出现，所以，必定可以读取到
// 这个配置文件不应该没有被提供，如果万一出现了没有提供的情况，需要 Panic 并提供错误信息方便调试，或者让使用者知道原因
// expect 里输出的描述信息，使用肯定的内容，整体代码可读性更高，更能突出 expect 的语义
let config = Config::read(&quot;some_config.toml&quot;).expect(&quot;Provide the correct configuration file&quot;); 

// or

fn main() {
    use std::net::IpAddr;
    let _home: IpAddr = &quot;127.0.0.1&quot;.parse().expect(&quot;Provide the correct Ip addr&quot;);
}
</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">// 这个配置文件默认会跟随源码出现，所以，必定可以读取到
// 这个配置文件不应该没有被提供，如果万一出现了没有提供的情况，需要 Panic ，但这里并没有提供错误信息，对于调试或使用都没有帮助
let config = Config::read(&quot;some_config.toml&quot;).unwrap();

// or
// expect 的输出描述使用否定式内容，可读性不好
let config = Config::read(&quot;some_config.toml&quot;).expect(&quot;No configuration file provided&quot;); 

// or

fn main() {
    use std::net::IpAddr;
    let _home: IpAddr = &quot;127.0.0.1&quot;.parse().unwrap();
}

// or
// expect 的输出描述使用否定式内容，可读性不好
fn main() {
    use std::net::IpAddr;
    let _home: IpAddr = &quot;127.0.0.1&quot;.parse().expect(&quot;IP addr parse failed!&quot;);
}
</code></pre></pre>
<h2><a class="header" href="#perr05---根据-应用-还是-库-来选择不同的错误处理方式" id="perr05---根据-应用-还是-库-来选择不同的错误处理方式">P.ERR.05   根据 应用 还是 库 来选择不同的错误处理方式</a></h2>
<p><strong>【描述】</strong></p>
<p>如果编写应用，建议使用<code> Error</code> trait对象；如果编写库，则建议返回自定义错误类型，方便下游处理</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 对于应用使用 Error trait 对象更加方便
pub fn print(&amp;self, languages: &amp;Languages) -&gt; Result&lt;String, Box&lt;dyn Error&gt;&gt; {
     // do something
}


// 对于库，暴露自定义错误类型更加方便下游处理错误
#[derive(Debug)]
pub struct SendError&lt;T&gt;(pub T);

impl&lt;T&gt; fmt::Display for SendError&lt;T&gt; {
    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(fmt, &quot;channel closed&quot;)
    }
}

impl&lt;T: fmt::Debug&gt; std::error::Error for SendError&lt;T&gt; {}
<span class="boring">}
</span></code></pre></pre>
<hr />
<h2><a class="header" href="#gerr01--在处理-optiont-和-resultt-e-类型时不要随便使用-unwrap" id="gerr01--在处理-optiont-和-resultt-e-类型时不要随便使用-unwrap">G.ERR.01  在处理 <code>Option&lt;T&gt;</code> 和 <code>Result&lt;T, E&gt;</code> 类型时，不要随便使用 <code>unwrap</code></a></h2>
<h3><a class="header" href="#级别建议-107" id="级别建议-107">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-103" id="lint-检测-103">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#unwrap_used">unwrap_used</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-133" id="描述-133">【描述】</a></h3>
<p>当 <code>Option&lt;T&gt;</code> 和 <code>Result&lt;T, E&gt;</code>类型的值分别是 <code>None</code> 或 <code>Err</code> 时，直接对其 <code>unwrap()</code> 会导致程序恐慌！</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn select(opt: Option&lt;String&gt;) {
    opt.expect(&quot;more helpful message&quot;);  // 可以用 expect 方法来处理 None 的情况
}
// OR
fn select(opt: Result&lt;String, ()&gt;) {
    res.expect(&quot;more helpful message&quot;);  // 可以用 expect 方法来处理 Err 的情况
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn select(opt: Option&lt;String&gt;) {
    opt.unwrap();  // 可以用 expect 方法来处理 None 的情况
}
// OR
fn select(opt: Result&lt;String, ()&gt;) {
    res.unwrap();  // 可以用 expect 方法来处理 Err 的情况
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gerr02----不要滥用-expect请考虑用-unwrap_or_-系列方法代替" id="gerr02----不要滥用-expect请考虑用-unwrap_or_-系列方法代替">G.ERR.02    不要滥用 <code>expect</code>，请考虑用 <code>unwrap_or_</code> 系列方法代替</a></h2>
<h3><a class="header" href="#级别建议-108" id="级别建议-108">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-104" id="lint-检测-104">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#expect_fun_call">expect_fun_call</a></td><td>yes</td><td>no</td><td>perf</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#expect_used">expect_used</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-134" id="描述-134">【描述】</a></h3>
<p>使用 <code>expect</code> 的时候请遵循 <code>expect</code> 的语义，不要滥用。参考 ： <strong>P.ERR.05</strong> 。</p>
<p>但是对于一些存在“副作用”的函数，在 遇到 <code>None</code> 或 <code>Err</code> 时，可能需要返回一些指定的值。这个时候用 <code>expect</code> 就不太符合语义。</p>
<p>如果你的用法完全符合 <code>expect</code> 语义，那么可以设置 <code>#![allow(clippy::expect_fun_call]</code></p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo = Some(String::new());
let err_code = &quot;418&quot;;
let err_msg = &quot;I'm a teapot&quot;;
foo.unwrap_or_else(|| panic!(&quot;Err {}: {}&quot;, err_code, err_msg));  // 你可以根据场景选择性使用 panic! 或者 不 panic!
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo = Some(String::new());
let err_code = &quot;418&quot;;
let err_msg = &quot;I'm a teapot&quot;;
foo.expect(&amp;format!(&quot;Err {}: {}&quot;, err_code, err_msg)); 
// or
foo.expect(format!(&quot;Err {}: {}&quot;, err_code, err_msg).as_str());  
<span class="boring">}
</span></code></pre></pre>
<p>【例外】</p>
<p>完全符合 <code>expect</code> 语义的使用。</p>
<pre><pre class="playground"><code class="language-rust">#![allow(clippy::expect_fun_call]

// 这个配置文件默认会跟随源码出现，所以，必定可以读取到
// 这个配置文件不应该没有被提供，如果万一出现了没有提供的情况，需要 Panic 并提供错误信息方便调试，或者让使用者知道原因
let config = Config::read(&quot;some_config.toml&quot;).expect(&quot;Provide the correct configuration file&quot;); 

// or

fn main() {
    use std::net::IpAddr;
    let _home: IpAddr = &quot;127.0.0.1&quot;.parse().expect(&quot;Provide the correct Ip addr&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#内存" id="内存">内存</a></h1>
<ul>
<li><a href="safe-guides/coding_practice/memory/box.html">Box</a></li>
<li><a href="safe-guides/coding_practice/./memory/drop.html">Drop</a></li>
<li><a href="safe-guides/coding_practice/./memory/lifetime.html">Lifetime</a></li>
</ul>
<h1><a class="header" href="#生存期" id="生存期">生存期</a></h1>
<p>生存期（lifetime），也被叫做 生命周期。</p>
<hr />
<h2><a class="header" href="#pmemlifetime01-生命周期参数命名尽量简单" id="pmemlifetime01-生命周期参数命名尽量简单">P.MEM.Lifetime.01 生命周期参数命名尽量简单</a></h2>
<p><strong>【描述】</strong></p>
<p>生命周期参数的命名应该尽量简单，可以使用表达一定语义的缩写。</p>
<p>因为生命周期参数的目的是给编译器使用，用于防止函数中出现悬垂引用。</p>
<p>适当简单的携带语义的缩写，可以最小化对业务代码的干扰。并且在生命周期参数较多的情况下，清晰地表达具体哪个引用属于哪个生命周期。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 'cg = the duration of the constraint generation process itself.
struct ConstraintGeneration&lt;'cg, 'cx, 'tcx&gt; {
    infcx: &amp;'cg InferCtxt&lt;'cx, 'tcx&gt;,
    all_facts: &amp;'cg mut Option&lt;AllFacts&gt;,
    location_table: &amp;'cg LocationTable,
    liveness_constraints: &amp;'cg mut LivenessValues&lt;RegionVid&gt;,
    borrow_set: &amp;'cg BorrowSet&lt;'tcx&gt;,
    body: &amp;'cg Body&lt;'tcx&gt;,
}

<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>struct ConstraintGeneration&lt;'a, 'b, 'c&gt; {
    infcx: &amp;'cg InferCtxt&lt;'b, 'c&gt;,
    all_facts: &amp;'a mut Option&lt;AllFacts&gt;,
    location_table: &amp;'a LocationTable,
    liveness_constraints: &amp;'a mut LivenessValues&lt;RegionVid&gt;,
    borrow_set: &amp;'a BorrowSet&lt;'c&gt;,
    body: &amp;'cg Body&lt;'c&gt;,
}

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#pmemlifetime02--在需要的时候最好显式地标注生命周期而非利用编译器推断" id="pmemlifetime02--在需要的时候最好显式地标注生命周期而非利用编译器推断">P.MEM.Lifetime.02  在需要的时候，最好显式地标注生命周期，而非利用编译器推断</a></h2>
<p><strong>【描述】</strong></p>
<p>编译器可以推断你的代码做了什么，但它不知道你的意图是什么。</p>
<p>编译器对生命周期参数有两种单态化方式（生命周期参数也是一种泛型）：</p>
<ul>
<li>Early bound。一般情况下，<code>'a: 'b</code> 以及 <code>impl&lt;'a'&gt;</code>  这种方式是 early bound，意味着这些生命周期参数会在当前作用域单态化生命周期实例。</li>
<li>Late bound。默认的 <code>'a</code>   或 <code>for&lt;'a&gt;</code> 是在实际调用它们的地方才单态化生命周期实例。</li>
</ul>
<p>在不同的场景下，需要指定合适的单态化方式，才能让编译器明白你的意图。</p>
<p>在使用匿名生命周期 <code>'_</code> 的时候需要注意，如果有多个匿名生命周期，比如 <code>('_ ，'_)</code> ，每个匿名生命周期都会有自己的单独实例。</p>
<h1><a class="header" href="#boxt" id="boxt"><code>Box&lt;T&gt;</code></a></h1>
<p>Rust 中分配堆内存必须要使用的类型。</p>
<hr />
<h2><a class="header" href="#pmembox01" id="pmembox01">P.MEM.Box.01</a></h2>
<p>【描述】</p>
<hr />
<h2><a class="header" href="#gmembox01--一般情况下不要直接对-boxt-进行借用" id="gmembox01--一般情况下不要直接对-boxt-进行借用">G.MEM.BOX.01  一般情况下，不要直接对 <code>Box&lt;T&gt;</code> 进行借用</a></h2>
<h3><a class="header" href="#级别建议-109" id="级别建议-109">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-105" id="lint-检测-105">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#borrowed_box">borrowed_box</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
</tbody></table>
<p>也有例外。</p>
<h3><a class="header" href="#描述-135" id="描述-135">【描述】</a></h3>
<p>通常 <code>&amp;T</code> 比 <code>&amp;Box&lt;T&gt;</code> 更常用。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(bar: &amp;T) { ... }
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(bar: &amp;Box&lt;T&gt;) { ... }
<span class="boring">}
</span></code></pre></pre>
<p>【例外】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// https://docs.rs/crate/actix-web-security/0.1.0/source/src/authentication/scheme/authentication_provider.rs

#[async_trait]
pub trait AuthenticationProvider: AuthenticationProviderClone {
    #[allow(clippy::borrowed_box)]
    async fn authenticate(
        &amp;self,
        authentication: &amp;Box&lt;dyn Authentication&gt;,
    ) -&gt; Result&lt;Box&lt;dyn UserDetails&gt;, AuthenticationError&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gmembox02--一般情况下不要直接对已经在堆上分配内存的类型进行-box-装箱" id="gmembox02--一般情况下不要直接对已经在堆上分配内存的类型进行-box-装箱">G.MEM.BOX.02  一般情况下，不要直接对已经在堆上分配内存的类型进行 Box 装箱</a></h2>
<h3><a class="header" href="#级别建议-110" id="级别建议-110">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-106" id="lint-检测-106">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#box_vec">box_vec</a></td><td>yes</td><td>no</td><td>perf</td><td>warn</td></tr>
</tbody></table>
<p>也有例外。</p>
<h3><a class="header" href="#描述-136" id="描述-136">【描述】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct X {
    values: Vec&lt;Foo&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct X {
    values: Box&lt;Vec&lt;Foo&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>【例外】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// https://docs.rs/crate/jex/0.2.0/source/src/jq/query.rs

#[derive(Debug)]
pub struct JQ {
    ptr: *mut jq_state,
    // We want to make sure the vec pointer doesn't move, so we can keep pushing to it.
    #[allow(clippy::box_vec)]
    errors: Box&lt;Vec&lt;JVRaw&gt;&gt;,
}

// https://docs.rs/crate/mmtk/0.6.0/source/src/plan/mutator_context.rs

// This struct is part of the Mutator struct.
// We are trying to make it fixed-sized so that VM bindings can easily define a Mutator type to have the exact same layout as our Mutator struct.
#[repr(C)]
pub struct MutatorConfig&lt;VM: VMBinding&gt; {
    // ...

    /// Mapping between allocator selector and spaces. Each pair represents a mapping.
    /// Put this behind a box, so it is a pointer-sized field.
    #[allow(clippy::box_vec)]
    pub space_mapping: Box&lt;SpaceMapping&lt;VM&gt;&gt;,
  
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gmembox03--一般情况下不要直接对不需要堆内存分配就可以正常工作的类型进行-box-装箱" id="gmembox03--一般情况下不要直接对不需要堆内存分配就可以正常工作的类型进行-box-装箱">G.MEM.BOX.03  一般情况下，不要直接对不需要堆内存分配就可以正常工作的类型进行 Box 装箱</a></h2>
<h3><a class="header" href="#级别建议-111" id="级别建议-111">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-107" id="lint-检测-107">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#boxed_local">boxed_local </a></td><td>yes</td><td>no</td><td>perf</td><td>warn</td></tr>
</tbody></table>
<p>也有例外。</p>
<h3><a class="header" href="#描述-137" id="描述-137">【描述】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn foo(bar: usize) {}
</span>let x = 1;
foo(x);
println!(&quot;{}&quot;, x);
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn foo(bar: usize) {}
</span>let x = Box::new(1);
foo(*x);
println!(&quot;{}&quot;, *x);
<span class="boring">}
</span></code></pre></pre>
<p>【例外】</p>
<p>当栈变量太大的情况下，需要使用堆分配。或者栈变量需要逃逸的时候。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>// https://docs.rs/crate/aitch/0.1.1/source/src/servers/hyper.rs#:~:text=clippy%3a%3aboxed_local

pub trait ServeFunc {
    fn call_box(self: Box&lt;Self&gt;) -&gt; Result&lt;()&gt;;
}

impl&lt;F&gt; ServeFunc for F
where
    F: FnOnce() -&gt; Result&lt;()&gt;,
{
    #[cfg_attr(feature = &quot;cargo-clippy&quot;, allow(boxed_local))]
    fn call_box(self: Box&lt;Self&gt;) -&gt; Result&lt;()&gt; {
        (*self)()
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#drop-析构" id="drop-析构">Drop 析构</a></h1>
<p>在 Safe Rust 中 ，Drop 比较安全。在 Unsafe Rust 中则需要注意更多关于 Drop 的问题。 </p>
<hr />
<h2><a class="header" href="#pmemdrop01-要注意防范内存泄漏" id="pmemdrop01-要注意防范内存泄漏">P.MEM.Drop.01 要注意防范内存泄漏</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 语言并不保证避免内存泄漏，内存泄漏不属于 Rust 安全职责范围。使用 Rust 的时候需要注意下面情况可能会发生内存泄漏：</p>
<ol>
<li>循环引用</li>
<li>使用 <code>forget</code>  / <code>leak</code> 等函数主动跳过析构</li>
<li>使用 <code>std::mem::ManuallyDrop</code> 构建数据结构而忘记析构</li>
<li>析构函数内部发生了 panic</li>
<li>程序中止（abort on panic）</li>
</ol>
<h1><a class="header" href="#模块" id="模块">模块</a></h1>
<p>Rust 中一个文件 即一个模块，也可以通过  <code>mod</code> 来创建模块。多个文件放到同一个目录下，也可以成为一个模块。</p>
<p>模块相关有三个概念：</p>
<ol>
<li><code>mod</code>是 Rust 代码的“骨架”。</li>
<li><code>use</code> 则是用来决定使用或导出哪个模块中的具体的类型或方法。</li>
<li><code>Path</code>，则是一个命名系统，类似于命名空间。</li>
</ol>
<hr />
<h2><a class="header" href="#pmod01----合理控制对外接口和模块之间的可见性" id="pmod01----合理控制对外接口和模块之间的可见性">P.MOD.01    合理控制对外接口和模块之间的可见性</a></h2>
<h3><a class="header" href="#描述-138" id="描述-138">【描述】</a></h3>
<p>Rust提供强大的模块（module）系统，并且可以管理这些模块之间的可见性（公有（public）或私有（private））。</p>
<p>1、对于提供给其他crate使用的对外函数、结构体、trait等类型需要严格控制对外pub的范围，避免将内部成员对外提供。</p>
<p>2、对于crate内部，mod之间可见的类型，需要添加上<code>pub(crate) </code>。</p>
<p>3、对于mod内部私有的类型，不要添加<code>pub(crate) </code>或者<code>pub</code>。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// lib.rs
pub mod sha512;
pub use sha512::Sha512;

// sha512.rs
pub struct Sha512 {
    inner: Sha512Inner, // inner作为内部结构体，不添加pub描述
}
<span class="boring">}
</span></code></pre></pre>
<hr />
<h2><a class="header" href="#gmod01---使用导入模块中的类型或函数在某些情况下需要带模块名前缀" id="gmod01---使用导入模块中的类型或函数在某些情况下需要带模块名前缀">G.MOD.01   使用导入模块中的类型或函数，在某些情况下需要带模块名前缀</a></h2>
<h3><a class="header" href="#级别建议-112" id="级别建议-112">【级别：建议】</a></h3>
<p>建议按此规范执行</p>
<h3><a class="header" href="#lint-检测-108" id="lint-检测-108">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-139" id="描述-139">【描述】</a></h3>
<p>对于标准库中，很多人都熟知的类型 ，比如 <code>Arc</code>/ <code>Rc</code>/ <code>Cell</code>/ <code>HashMap</code> 等 ， 可以导入它们直接使用。</p>
<p>但是对于可能引起困惑的函数，比如 <code>std::ptr::replace</code> 和 <code>std::mem::replace</code> ，在使用它们的时候，就必须得带上模块前缀。</p>
<p>使用一些第三方库中定义的类型或函数，也建议带上crate或模块前缀。如果太长的话，可以考虑使用 <code>as</code>  或  <code>type</code> 来定义别名。</p>
<p>以上考虑都是为了增强代码的可读性、可维护性。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;
let foo = Arc::new(vec![1.0, 2.0, 3.0]); // 直接使用 Arc
let a = foo.clone();

// 需要带上 ptr 前缀
use std::ptr;
let mut rust = vec!['b', 'u', 's', 't'];
// `mem::replace` would have the same effect without requiring the unsafe
// block.
let b = unsafe {
    ptr::replace(&amp;mut rust[0], 'r')
};
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gmod02---如果是作为库供别人使用在-librs中重新导出对外类型函数和-trait-等" id="gmod02---如果是作为库供别人使用在-librs中重新导出对外类型函数和-trait-等">G.MOD.02   如果是作为库供别人使用，在 <code>lib.rs</code>中重新导出对外类型、函数和 trait 等</a></h2>
<h3><a class="header" href="#级别规则-5" id="级别规则-5">【级别：规则】</a></h3>
<p>按此规范执行</p>
<h3><a class="header" href="#lint-检测-109" id="lint-检测-109">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-140" id="描述-140">【描述】</a></h3>
<p>这样使用方在使用的时候，就不需要<code>use crate::mod::mod::struct</code>，可以直接使用<code>use crate::struct</code>，好处是使用方<code>use</code>的时候会比较方便和直观。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From syn crate
pub use crate::data::{
    Field, Fields, FieldsNamed, FieldsUnnamed, Variant, VisCrate, VisPublic, VisRestricted,
    Visibility,
};
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gmod03---导入模块不要随便使用-通配符" id="gmod03---导入模块不要随便使用-通配符">G.MOD.03   导入模块不要随便使用 通配符<code>*</code></a></h2>
<h3><a class="header" href="#级别建议-113" id="级别建议-113">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-110" id="lint-检测-110">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#wildcard_imports">wildcard_imports</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<p>该 lint 可以通过 clippy 配置项 <code>warn-on-all-wildcard-imports = false</code> 来配置，用于是否禁用 <code>prelude</code>/ <code>super</code> (测试模块中) 使用通配符导入， 默认是 <code>false</code>。</p>
<h3><a class="header" href="#描述-141" id="描述-141">【描述】</a></h3>
<p>使用通配符导入会污染命名空间，比如导入相同命名的函数或类型。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate1::foo; // Imports a function named foo
foo(); // Calls crate1::foo
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate2::*; // Has a function named foo
foo(); // Calls crate1::foo
<span class="boring">}
</span></code></pre></pre>
<p>【例外】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use prelude::*;

#[test]
use super::*
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gmod04----一个项目中应该避免使用不同的模块布局风格" id="gmod04----一个项目中应该避免使用不同的模块布局风格">G.MOD.04    一个项目中应该避免使用不同的模块布局风格</a></h2>
<h3><a class="header" href="#级别建议-114" id="级别建议-114">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-111" id="lint-检测-111">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#self_named_module_files">self_named_module_files</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#mod_module_files">mod_module_files</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-142" id="描述-142">【描述】</a></h3>
<p>Rust 支持两种 模块布局，文件夹内使用 <code>mod.rs</code> 或者是使用跟文件夹同名的文件名，来组织模块。</p>
<p>但是项目里如果混合这两种模块布局，是比较让人困惑的，最好统一为同一种风格。</p>
<p>上面两种  lint ，选择其中一种用于检查是否存在不同的模块布局。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 使用 `self_named_module_files`，允许下面模块布局
src/
  stuff/
    stuff_files.rs
    mod.rs
  lib.rs

// 使用 `mod_module_files`，允许下面模块布局
src/
  stuff/
    stuff_files.rs
  stuff.rs
  lib.rs
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 使用 `self_named_module_files`，不允许下面模块布局
src/
  stuff/
    stuff_files.rs
  stuff.rs
  lib.rs

// 使用 `mod_module_files`，不允许下面模块布局

src/
  stuff/
    stuff_files.rs
    mod.rs
  lib.rs
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gmod05----不要在私有模块中-设置其内部类型或函数方法-为-pubcrate" id="gmod05----不要在私有模块中-设置其内部类型或函数方法-为-pubcrate">G.MOD.05    不要在私有模块中 设置其内部类型或函数方法 为 <code>pub(crate)</code></a></h2>
<h3><a class="header" href="#级别建议-115" id="级别建议-115">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-112" id="lint-检测-112">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#redundant_pub_crate">redundant_pub_crate</a></td><td>yes</td><td>no</td><td>nursery</td><td>allow</td></tr>
</tbody></table>
<p>注意：此 lint 为 nursery，意味着有 Bug。</p>
<h3><a class="header" href="#描述-143" id="描述-143">【描述】</a></h3>
<p>如果在私有模块中设置  <code>pub(crate)</code> 可能会让使用者产生误解。建议用 <code>pub</code> 代替。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod internal {
    pub fn internal_fn() { }
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod internal {
    pub(crate) fn internal_fn() { }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#包管理" id="包管理">包管理</a></h1>
<p>Cargo 不仅仅是包管理，它还是一个 Workflow 工具。这一节包含 Cargo 和 Crate 相关内容。</p>
<hr />
<h2><a class="header" href="#pcar01---应该尽量把项目划分为合理的-crate-组合" id="pcar01---应该尽量把项目划分为合理的-crate-组合">P.CAR.01   应该尽量把项目划分为合理的 crate 组合</a></h2>
<h3><a class="header" href="#描述-144" id="描述-144"><strong>【描述】</strong></a></h3>
<p>将整个项目按一定逻辑划分为合理的 crate，在工程方面，有利于组件化。并且 crate 是 Rust 的编译单元，也有助于提升编译时间。</p>
<p>但需要注意，crate 之间的依赖关系应该是单向的，避免相互依赖的情况。</p>
<p>但 Rust 中 编译时间、性能、编译大小之间，在考虑优化的时候，也是需要权衡的。 </p>
<p>内联是优化的关键，当编译单元越大，内联优化效果就越好。所以需要权衡 crate 划分的粒度。</p>
<h2><a class="header" href="#pcar02----不要滥用-features" id="pcar02----不要滥用-features">P.CAR.02    不要滥用 <code>features</code></a></h2>
<h3><a class="header" href="#描述-145" id="描述-145"><strong>【描述】</strong></a></h3>
<p>Rust 的 features ，提供了方便的条件编译功能。从软件工程来说，features 应该是为了避免让用户依赖没必要依赖的功能而使用的。</p>
<p>在使用 features 的时候，应该考虑到底是不是真的需要 features。</p>
<p>滥用features会带来额外的测试和静态检查的难度，需要保证不同features下的测试覆盖和静态检查情况。</p>
<hr />
<h2><a class="header" href="#gcar01----当项目是可执行程序而非库时建议使用-srcmainrs-和-srclibrs-模式" id="gcar01----当项目是可执行程序而非库时建议使用-srcmainrs-和-srclibrs-模式">G.CAR.01    当项目是可执行程序而非库时，建议使用 <code>src/main.rs</code> 和 <code>src/lib.rs</code> 模式</a></h2>
<h3><a class="header" href="#级别规则-6" id="级别规则-6">【级别：规则】</a></h3>
<p>按此规范执行。</p>
<h3><a class="header" href="#lint-检测-113" id="lint-检测-113">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-146" id="描述-146"><strong>【描述】</strong></a></h3>
<p><code>crate</code> 结构类似于：</p>
<pre><code class="language-text">src/
  -- lib.rs
  -- main.rs
</code></pre>
<p>或</p>
<pre><code class="language-text">src/
  -- lib.rs
bin/
  -- main.rs
</code></pre>
<p>这样的好处有：</p>
<ol>
<li>便于单元测试。</li>
<li>这样拆分有利于面向接口思考，让代码架构和逻辑更加清晰。</li>
</ol>
<p>如果你编写的可执行程序比较复杂时，在 <code>main.rs</code>里需要依赖太多东西，那就需要创建 Workspace， 把 <code>main.rs</code> 在独立为一个 crate 了，而在这个 crate 内也没有必要再拆分为 <code>main</code>和 <code>lib</code> 了。</p>
<h2><a class="header" href="#gcar02--crate-的-cargotoml--中应该包含必要的元信息" id="gcar02--crate-的-cargotoml--中应该包含必要的元信息">G.CAR.02  Crate 的 Cargo.toml  中应该包含必要的元信息</a></h2>
<h3><a class="header" href="#级别规则-7" id="级别规则-7">【级别：规则】</a></h3>
<p>按此规范执行。</p>
<h3><a class="header" href="#lint-检测-114" id="lint-检测-114">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cargo_common_metadata">cargo_common_metadata</a></td><td>yes</td><td>no</td><td>cargo</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-147" id="描述-147">【描述】</a></h3>
<p>在 Cargo.toml 中应该包含必要的元信息，以便使用者知道它的作用。并且后续上传到crates.io上，这些信息也是必须的。</p>
<p>【正例】</p>
<pre><code class="language-toml"># This `Cargo.toml` includes all common metadata
[package]
name = &quot;clippy&quot;
version = &quot;0.0.212&quot;
description = &quot;A bunch of helpful lints to avoid common pitfalls in Rust&quot;
repository = &quot;https://github.com/rust-lang/rust-clippy&quot;
readme = &quot;README.md&quot;
license = &quot;MIT OR Apache-2.0&quot;
keywords = [&quot;clippy&quot;, &quot;lint&quot;, &quot;plugin&quot;]
categories = [&quot;development-tools&quot;, &quot;development-tools::cargo-plugins&quot;]
</code></pre>
<p>【反例】</p>
<pre><code class="language-toml"># This `Cargo.toml` is missing a description field:
[package]
name = &quot;clippy&quot;
version = &quot;0.0.212&quot;
repository = &quot;https://github.com/rust-lang/rust-clippy&quot;
readme = &quot;README.md&quot;
license = &quot;MIT OR Apache-2.0&quot;
keywords = [&quot;clippy&quot;, &quot;lint&quot;, &quot;plugin&quot;]
categories = [&quot;development-tools&quot;, &quot;development-tools::cargo-plugins&quot;]
</code></pre>
<h2><a class="header" href="#gcar03---feature-命名应该避免否定式或多余的前后缀" id="gcar03---feature-命名应该避免否定式或多余的前后缀">G.CAR.03   Feature 命名应该避免否定式或多余的前后缀</a></h2>
<h3><a class="header" href="#级别建议-116" id="级别建议-116">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-115" id="lint-检测-115">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#negative_feature_names">negative_feature_names</a></td><td>yes</td><td>no</td><td>cargo</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#redundant_feature_names">redundant_feature_names</a></td><td>yes</td><td>no</td><td>cargo</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-148" id="描述-148">【描述】</a></h3>
<p>Feature 命名应该避免出现 <code>no-</code> 或 <code>not-</code> 之类的否定前缀，或诸如 <code>use-</code>，<code>with-</code> 前缀或 <code>-support</code>后缀。Feature 的目的是正向的，可选的特性，使用否定式命名和它的目的背道而驰。</p>
<p>【正例】</p>
<pre><code class="language-toml">[features]
default = [&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;]
abc = []
def = []
ghi = []
</code></pre>
<p>【反例】</p>
<pre><code class="language-toml"># The `Cargo.toml` with negative feature names
[features]
default = [&quot;with-def&quot;, &quot;ghi-support&quot;]
no-abc = []
with-def = []   // redundant
ghi-support = []   // redundant
</code></pre>
<h2><a class="header" href="#gcar04---cargotoml--中依赖包版本不要使用通配符" id="gcar04---cargotoml--中依赖包版本不要使用通配符">G.CAR.04   Cargo.toml  中依赖包版本不要使用通配符</a></h2>
<h3><a class="header" href="#级别建议-117" id="级别建议-117">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-116" id="lint-检测-116">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#wildcard_dependencies">wildcard_dependencies</a></td><td>yes</td><td>no</td><td>cargo</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-149" id="描述-149">【描述】</a></h3>
<p>【正例】</p>
<pre><code class="language-toml">[dependencies]
regex = &quot;1.5&quot;
</code></pre>
<p>【反例】</p>
<pre><code class="language-toml">[dependencies]
regex = &quot;*&quot;
</code></pre>
<h1><a class="header" href="#宏" id="宏">宏</a></h1>
<p>Rust  通过宏来支持元编程。其中宏有很多种，按实现方式可以分为两大类：声明宏（Declarative） 和 过程宏（Procedural）。</p>
<p>按功能效果，过程宏又可以分为三类：</p>
<ol>
<li>Bang 宏。类似于声明宏那样，像函数调用一样去使用的宏。</li>
<li>Derive 宏。用于为数据类型自动生成一些 语法项（item），比如 trait 、结构体、方法等。</li>
<li>Attrubutes 宏。用于更加通用的代码生成功能。</li>
</ol>
<p>Rust 语言核心库和标准库，都内置了一些声明宏和过程宏，以方便开发者使用。</p>
<p>内置的属性宏按功能大体又可以分为四类：</p>
<ol>
<li>测试属性。<code>#[test]</code> 属性宏用于将某个函数标记为单元测试函数。</li>
<li>诊断（<a href="https://doc.rust-lang.org/reference/attributes/diagnostics.html#diagnostic-attributes">Diagnostic</a>）属性。用于在编译过程中控制和生成诊断信息。包括：
<ol>
<li><code>allow(c)</code>/ <code>warn(c)</code>/ <code>deny(c)</code>/ <code>forbid(c)</code>  等。</li>
<li><code>#[must_use]</code> 。</li>
</ol>
</li>
<li><a href="https://doc.rust-lang.org/reference/attributes/codegen.html">代码生成属性</a>。包括：<code>inline</code> / <code>cold</code> / <code>\#[target_feature]</code> 等。</li>
<li><a href="https://doc.rust-lang.org/reference/attributes/limits.html">编译时限制属性</a>。包括：<code>recursion_limit </code> / <code>type_length_limit</code> 。</li>
<li><a href="https://doc.rust-lang.org/reference/attributes/type_system.html">类型系统属性</a>。包括：<code>non_exhaustive</code> 。</li>
</ol>
<p><strong>宏编程规范：</strong></p>
<p>使用宏时，需要从 <code>声明宏</code> 和 <code>过程宏</code> 各自的特性为出发点，来安全使用它。</p>
<ul>
<li><a href="safe-guides/coding_practice/./macros/decl.html">声明宏规范</a></li>
<li><a href="safe-guides/coding_practice/./macros/proc.html">过程宏规范</a></li>
</ul>
<p><strong>宏展开命令：</strong></p>
<pre><code class="language-text"># 对单个 rs 文件
rustc -Z unstable-options --pretty expanded hello.rs
# 对项目里的二进制 rs 文件
cargo rustc --bin hello -- -Z unstable-options --pretty=expanded
</code></pre>
<hr />
<h2><a class="header" href="#pmac01--不要轻易使用宏" id="pmac01--不要轻易使用宏">P.MAC.01  不要轻易使用宏</a></h2>
<p>【描述】</p>
<p>能使用宏写出强大和用户友好的宏API的人，重点不是因为他们对宏如何实现掌握的好，而是因为他们也掌握了宏之外关于 Rust 的一切。</p>
<p>宏设计的重点在于宏生成什么样的代码，而不是宏如何生成代码。</p>
<p>宏只是将 Rust 语言特性以一种有趣的方式组合在一起能自动生成代码的创造力。</p>
<p>尤其是过程宏，它有一定复杂性，且很难调试，不卫生，也容易出错，不适合新手使用它。</p>
<p>【参考】</p>
<p><a href="https://github.com/dtolnay/case-studies">Rust 社区顶级专家 Dtolnay 写的 宏学习案例 </a></p>
<h2><a class="header" href="#pmac02-实现宏语法的时候应该尽量贴近-rust-语法" id="pmac02-实现宏语法的时候应该尽量贴近-rust-语法">P.MAC.02 实现宏语法的时候，应该尽量贴近 Rust 语法</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 宏可以让开发者定义自己的DSL，但是，在使用宏的时候，要尽可能贴近Rust的语法。这样可以增强可读性，让其他开发者在使用宏的时候，可以猜测出它的生成的代码。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>bitflags! {
    struct S: u32 { /* ... */ }
}

// 也要注意结尾是正确的分号或逗号
bitflags! {
    struct S: u32 {
        const C = 0b000100;
        const D = 0b001000;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...over no keyword...
bitflags! {
    S: u32 { /* ... */ }
}

// ...or some ad-hoc word.
bitflags! {
    flags S: u32 { /* ... */ }
}

// or
bitflags! {
    struct S: u32 {
        const E = 0b010000, // 结尾应该是分号更符合 Rust 语法
        const F = 0b100000,
    }
}
<span class="boring">}
</span></code></pre></pre>
<hr />
<h2><a class="header" href="#gmac01---dbg-宏只应该在-debug-模式下使用" id="gmac01---dbg-宏只应该在-debug-模式下使用">G.MAC.01   <code>dbg!()</code> 宏只应该在 Debug 模式下使用</a></h2>
<h3><a class="header" href="#级别规则-8" id="级别规则-8">【级别：规则】</a></h3>
<p>按此规范执行。</p>
<h3><a class="header" href="#lint-检测-117" id="lint-检测-117">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#dbg_macro">dbg_macro</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-150" id="描述-150">【描述】</a></h3>
<p><code>dbg!()</code> 宏是 Rust 内置的宏，其目的是用于调试代码，仅用于 Debug 模式。 </p>
<p>将其用在 Release 模式下，调试信息也会被打印出来，不安全。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Debug 模式编译
let foo = false;
dbg!(foo); 

// Release 模式编译
let foo = false;
// dbg!(foo); 
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Release 模式编译
let foo = false;
dbg!(foo); 
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gmac02---在多个地方使用println-或-panic-之类的内置宏-时可以将其包装到函数内使用-cold-和-inlinenever-属性避免其内联从而避免编译文件膨胀" id="gmac02---在多个地方使用println-或-panic-之类的内置宏-时可以将其包装到函数内使用-cold-和-inlinenever-属性避免其内联从而避免编译文件膨胀">G.MAC.02   在多个地方使用<code>println!</code> 或 <code>panic!</code> 之类的内置宏 时，可以将其包装到函数内，使用 <code>#[cold]</code> 和 <code>#[inline(never)]</code> 属性避免其内联，从而避免编译文件膨胀</a></h2>
<h3><a class="header" href="#级别建议-118" id="级别建议-118">【级别：建议】</a></h3>
<p>建议按此规范执行</p>
<h3><a class="header" href="#lint-检测-118" id="lint-检测-118">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-151" id="描述-151"><strong>【描述】</strong></a></h3>
<p>因为像 <code>println!</code> 或 <code>panic!</code> 之类的宏，如果到处使用，就会到处展开代码，会导致编译文件大小膨胀。尤其在嵌入式领域需要注意。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline(never)]
#[cold]
#[track_caller] // 为了定位 panic 发生时的调用者的位置
fn unwrap_failed(msg: &amp;str, error: &amp;dyn fmt::Debug) -&gt; ! {
    panic!(&quot;{}: {:?}&quot;, msg, error)
}

pub fn expect(self, msg: &amp;str) -&gt; T {
    match self {
        Ok(t) =&gt; t,
        Err(e) =&gt; unwrap_failed(msg, &amp;e),
    }
}

pub fn unwrap_err(self) -&gt; E {
    match self {
        Ok(t) =&gt; unwrap_failed(&quot;called `Result::unwrap_err()` on an `Ok` value&quot;, &amp;t),
        Err(e) =&gt; e,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn expect(self, msg: &amp;str) -&gt; T {
    match self {
        Ok(t) =&gt; t,
        Err(e) =&gt; panic!(&quot;{}: {:?}&quot;, msg, &amp;e),
    }
}

pub fn unwrap_err(self) -&gt; E {
    match self {
        Ok(t) =&gt; panic!(&quot;{}: {:?}&quot;, &quot;called `Result::unwrap_err()` on an `Ok` value&quot;, &amp;t),
        Err(e) =&gt; e,
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#声明宏" id="声明宏">声明宏</a></h1>
<p><a href="https://doc.rust-lang.org/reference/macros-by-example.html">声明宏</a> 也被叫做 示例宏（macros by example），或者简单地叫做 宏。目前声明宏使用 <code>macro_rules!</code>来定义。</p>
<p>声明宏的特点是，它只用作 代码替换，而无法进行计算。</p>
<hr />
<h2><a class="header" href="#pmacdecl01-不要将声明宏内的变量作为外部变量使用" id="pmacdecl01-不要将声明宏内的变量作为外部变量使用">P.MAC.Decl.01 不要将声明宏内的变量作为外部变量使用</a></h2>
<p>【描述】</p>
<p>声明宏是半卫生（semi-hygienic）宏，其内部元变量（metavariables）不可作为外部变量去使用。</p>
<p>但是对于泛型参数（包括生命周期参数）是不卫生的，所以要小心使用。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! using_a {
    ($a:ident, $e:expr) =&gt; {{
        let $a = 42;
        $e
    }};
}
fn main() {
    let four = using_a!(a, a / 10);
}
</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! using_a {
    ($e:expr) =&gt; {
        {
            let a = 42;
            $e
        }
    }
}

let four = using_a!(a / 10); // build error:  cannot find value `a` in this scope
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#pmacdecl02--在编写多个宏规则时应该先从匹配粒度最小的开始写" id="pmacdecl02--在编写多个宏规则时应该先从匹配粒度最小的开始写">P.MAC.Decl.02  在编写多个宏规则时，应该先从匹配粒度最小的开始写</a></h2>
<p>【描述】</p>
<p>因为 声明宏 中，是按规则的编写顺序来匹配的。当第一个规则被匹配到，后面的规则将永远不会匹配到。所以，编写声明宏规则时，需要先写匹配粒度最小的，最具体的规则，然后逐步编写匹配范围更广泛的规则。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! foo {
    (@as_expr $e:expr) =&gt; {$e}; // expr 比 tt 匹配更加具体

    ($($tts:tt)*) =&gt; {
        foo!(@as_expr $($tts)*)
    };
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#pmacdecl03----不要在片段分类符a-hrefhttpsdocrust-langorgnightlyreferencemacros-by-examplehtmlmetavariablesfragment-specifiera跟随它不匹配的符号" id="pmacdecl03----不要在片段分类符a-hrefhttpsdocrust-langorgnightlyreferencemacros-by-examplehtmlmetavariablesfragment-specifiera跟随它不匹配的符号">P.MAC.Decl.03    不要在片段分类符（<a href="https://doc.rust-lang.org/nightly/reference/macros-by-example.html#metavariables">fragment-specifier</a>）跟随它不匹配的符号</a></h2>
<p>【描述】</p>
<p><code>macro_rules!</code> 定义声明宏时，非终止的元变量匹配必须紧随一个已被决定可以在这种匹配之后安全使用的标记。</p>
<p>具体的规则参见：  <a href="https://doc.rust-lang.org/reference/macros-by-example.html#follow-set-ambiguity-restrictions">Follow-set Ambiguity Restrictions</a></p>
<p>【正例】</p>
<p>该示例中，元变量<code>$e1</code>的 片段分类符<code>expr</code> 是非终止的，所以后面需要跟随一个用于分隔的标记。</p>
<p>Rust 规定在 <code>expr</code> 片段分类符 后面可以合法地跟随 <code>=&gt;</code> / <code>,</code> / <code>;</code> 。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! foo {
    ( $e1:expr, $e2:expr) =&gt; {$e1; $e2}; 
}

<span class="boring">}
</span></code></pre></pre>
<p>【  反例】</p>
<p>对于 <code>[,]</code> 这样的分隔标记就是非法的。这是为了防止未来 Rust 语法变动导致宏定义失效。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! foo {
    ( $e1:expr [,] $e2:expr) =&gt; {$e1; $e2}; 
}

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#pmacdecl04----匹配规则要精准不要模糊不清" id="pmacdecl04----匹配规则要精准不要模糊不清">P.MAC.Decl.04    匹配规则要精准，不要模糊不清</a></h2>
<p>【描述】</p>
<p>匹配规则必须精准，因为宏解析器并不会去执行代码，它无法匹配模糊不清的规则。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! ambiguity {
    ($i2:ident $($i:ident)* ) =&gt; { };
}

// ok
fn main() { ambiguity!(an_identifier  an_identifier2); }

</code></pre></pre>
<p>【  反例】</p>
<p>宏解析器无法确定第一次匹配的应该是多少个 ident。</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! ambiguity {
    ($($i:ident)* $i2:ident) =&gt; { };
}

// error:
//    local ambiguity: multiple parsing options: built-in NTs ident ('i') or ident ('i2').
fn main() { ambiguity!(an_identifier); }
</code></pre></pre>
<h2><a class="header" href="#pmacdecl05----使用宏替换substitution元变量的时候要注意选择合适的片段分类符a-hrefhttpsdocrust-langorgnightlyreferencemacros-by-examplehtmlmetavariablesfragment-specifiera" id="pmacdecl05----使用宏替换substitution元变量的时候要注意选择合适的片段分类符a-hrefhttpsdocrust-langorgnightlyreferencemacros-by-examplehtmlmetavariablesfragment-specifiera">P.MAC.Decl.05    使用宏替换（substitution）元变量的时候要注意选择合适的片段分类符（<a href="https://doc.rust-lang.org/nightly/reference/macros-by-example.html#metavariables">fragment-specifier</a>）</a></h2>
<p>【描述】</p>
<p>使用宏替换（substitution）元变量，就是指把已经进行过宏解析的 token 再次传给宏，需要注意，此时传入的 token，已经被看作是宏解析器解析后的 AST 节点了。</p>
<p>【正例】</p>
<p>满足示例这类正常匹配情况的目前只有 <code>tt</code>、<code>ident</code> 或者 <code>lifetime</code> 分类符。</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! capture_then_what_is {
    (#[$m:tt]) =&gt; {what_is!(#[$m])}; // 这里片段分类符用的是 tt
}

macro_rules! what_is {
    (#[no_mangle]) =&gt; {&quot;no_mangle attribute&quot;};
    (#[inline]) =&gt; {&quot;inline attribute&quot;};
    ($($tts:tt)*) =&gt; {concat!(&quot;something else (&quot;, stringify!($($tts)*), &quot;)&quot;)};
}

fn main() {
    println!(
        &quot;{}\n{}\n{}\n{}&quot;,
        what_is!(#[no_mangle]),
        what_is!(#[inline]),
        capture_then_what_is!(#[no_mangle]), // 被 capture_then_what_is 宏 解析过的token，还会被 what_is 二次处理
        capture_then_what_is!(#[inline]), // 被 capture_then_what_is 宏 解析过的token，还会被 what_is 二次处理
    );
}

// 输出：
// no_mangle attribute
// inline attribute
// no_mangle attribute
// inline attribute

</code></pre></pre>
<p>【  反例】</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! capture_then_what_is {
    (#[$m:meta]) =&gt; {what_is!(#[$m])};   // 这里片段分类符用的是 meta
}

macro_rules! what_is {
    (#[no_mangle]) =&gt; {&quot;no_mangle attribute&quot;};
    (#[inline]) =&gt; {&quot;inline attribute&quot;};
    ($($tts:tt)*) =&gt; {concat!(&quot;something else (&quot;, stringify!($($tts)*), &quot;)&quot;)};
}

fn main() {
    println!(
        &quot;{}\n{}\n{}\n{}&quot;,
        what_is!(#[no_mangle]),
        what_is!(#[inline]),
        capture_then_what_is!(#[no_mangle]), // 被 capture_then_what_is 宏 解析过的token，不会再二次被 what_is 宏解析，所以按 tt 规则处理
        capture_then_what_is!(#[inline]), // 被 capture_then_what_is 宏 解析过的token，不会再二次被 what_is 宏解析，所以按 tt 规则处理
    );
}
// 输出：
// no_mangle attribute
// inline attribute
// something else (#[no_mangle])
// something else (#[inline])
</code></pre></pre>
<h2><a class="header" href="#pmacdecl06---当宏需要接收-self时需要注意" id="pmacdecl06---当宏需要接收-self时需要注意">P.MAC.Decl.06   当宏需要接收 <code>self</code>时需要注意</a></h2>
<p>【描述】</p>
<p><code>self</code> 在 Rust 中属于关键字，它会在代码运行时被替换为具体类型的实例。当它传递给 宏 时，它会被看做一个变量，而宏对于变量而言，是具备卫生性的。而且，声明宏的作用只是替换，而非计算，它并不能计算出 self 的具体类型。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! double_method {
    ($self_:ident, $body:expr) =&gt; {
        fn double(mut $self_) -&gt; Dummy {
            $body
        }
    };
}

struct Dummy(i32);

impl Dummy {
    double_method! {self, {
        self.0 *= 2;
        self
    }}
}

fn main() {
    println!(&quot;{:?}&quot;, Dummy(4).double().0);
}
</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! make_mutable {
    ($i:ident) =&gt; {let mut $i = $i;};
}

struct Dummy(i32);

impl Dummy {
    fn double(self) -&gt; Dummy {
        make_mutable!(self);  // 这里传入的 self 和宏内部 let 定义的 self 不是一码事
        self.0 *= 2;
        self
    }
}

fn main() {
    println!(&quot;{:?}&quot;, Dummy(4).double().0);
}

</code></pre></pre>
<h2><a class="header" href="#pmacdecl07---确保在宏定义之后再去调用宏" id="pmacdecl07---确保在宏定义之后再去调用宏">P.MAC.Decl.07   确保在宏定义之后再去调用宏</a></h2>
<p>【描述】</p>
<p>Rust 中类型或函数，你可以在定义前后都可以调用它，但是宏不一样。 Rust  查找宏定义是按词法依赖顺序的，必须注意定义和调用的先后顺序。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! X { () =&gt; {}; }
mod a {
    X!(); // defined
}
mod b {
    X!(); // defined
}
mod c {
    X!(); // defined
}
fn main() {}
</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">mod a {
    // X!(); // undefined
}
mod b {
    // X!(); // undefined
    macro_rules! X { () =&gt; {}; }
    X!(); // defined
}
mod c {
    // X!(); // undefined
}
fn main() {}
</code></pre></pre>
<p>【例外】</p>
<p>宏与宏之间相互调用，不受词法顺序的限制。</p>
<pre><pre class="playground"><code class="language-rust">mod a {
    // X!(); // undefined
}

macro_rules! X { () =&gt; { Y!(); }; } // 注意：这里的 Y! 宏是在定义前被调用的，代码正常执行

mod b {
    // X!(); // defined, but Y! is undefined 
}

macro_rules! Y { () =&gt; {}; } // Y! 宏被定义在 X! 宏后面

mod c {
    X!(); // defined, and so is Y!
}
fn main() {}
</code></pre></pre>
<h2><a class="header" href="#pmacdecl08--同一个-crate-内定义的宏相互调用时需要注意卫生性" id="pmacdecl08--同一个-crate-内定义的宏相互调用时需要注意卫生性">P.MAC.Decl.08  同一个 crate 内定义的宏相互调用时，需要注意卫生性</a></h2>
<p>【描述】</p>
<p>当同一个 crate 内定义的宏相互调用时候，应该使用 <code>$crate</code> 元变量来指代当前被调用宏的路径。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! helped {
    () =&gt; { $crate::helper!() }
}

#[macro_export]
macro_rules! helper {
    () =&gt; { () }
}

//// 在另外的 crate 中使用这两个宏
// 注意：`helper_macro::helper` 并没有导入进来
use helper_macro::helped;

fn unit() {
   // OK! 这个宏能运行通过，因为 `$crate` 正确地展开成 `helper_macro` crate 的路径（而不是使用者的路径）
   helped!();
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! helped {
    () =&gt; { helper!() } // This might lead to an error due to 'helper' not being in scope.
}

#[macro_export]
macro_rules! helper {
    () =&gt; { () }
}

//// 在另外的 crate 中使用这两个宏
// 注意：`helper_macro::helper` 并没有导入进来
use helper_macro::helped;

fn unit() {
   // Error! 这个宏会出现问题，因为其内部调用的 helper 宏的路径会被编译器认为是当前调用crate 的路径
   helped!();
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#过程宏" id="过程宏">过程宏</a></h1>
<p><a href="https://doc.rust-lang.org/reference/procedural-macros.html">过程宏（<em>Procedural macros</em>）</a> 允许开发者来创建语法扩展。你可以通过过程宏创建类似函数的宏、派生宏以及属性宏。</p>
<p>广义上的&quot;过程宏&quot;指的是通过 syn/quote(毕竟几乎全部过程宏库都用 syn) 及 syn 生态(例如 darling) 进行代码生成等元编程操作。</p>
<p>syn/quote 不仅能用于过程宏，还广泛用于代码生成(<em>codegen</em>)、静态分析等用途，例如 tonic-build/prost 源码中也用到了 syn/quote 。</p>
<p>因此本过程宏规范不仅适用于过程宏，部分规范(例如 P.MAC.Proc.06 )还适用于 prost 这种代码生成库</p>
<p>过程宏必须被单独定义在一个类型为<code>proc-macro</code> 的 crate 中。</p>
<p>过程宏有两类报告错误的方式：<code>Panic</code> 或 通过 <code>compile_error</code>  宏调用发出错误。</p>
<p>过程宏不具有卫生性（hygiene），这意味着它会受到外部语法项（item）的影响，也会影响到外部导入。</p>
<p>过程宏可以在编译期执行任意代码。</p>
<hr />
<h2><a class="header" href="#pmacproc01--不要使用过程宏来规避静态分析检查" id="pmacproc01--不要使用过程宏来规避静态分析检查">P.MAC.Proc.01  不要使用过程宏来规避静态分析检查</a></h2>
<p>【描述】</p>
<p>不要利用过程宏来定义能规避 Rust 静态分析检查的宏。</p>
<p>【正例】</p>
<p>对于不安全的函数，应该显式地使用 <code>unsafe</code> 。这样做的好处是利用 Rust 编译器静态检查传播 unsafe 调用链条，以达到可以全局查找 unsafe 使用来消除一些代码隐患，方便定位 问题。</p>
<pre><pre class="playground"><code class="language-rust">unsafe fn super_safe(x: f32) -&gt; i32 {
    unsafe { std::mem::transmute::&lt;f32, i32&gt;(x) }
}

unsafe fn deref_null() {
    unsafe { *std::ptr::null::&lt;u8&gt;(); }
}

fn main(){
    println!(&quot;{:?}&quot;, unsafe{super_safe(1.0f32)}); // 1065353216
    // error[E0133]: call to unsafe function is unsafe and requires unsafe function or block
    // deref_null();  // 如果调用 unsafe 函数不加 unsafe 块，编译器就会报错。
    unsafe{ deref_null(); }
}
</code></pre></pre>
<p>【反例】</p>
<p>在 Rust 生态中有一个库 <a href="https://github.com/mxxo/plutonium"><code>plutonium</code></a> ，该库利用了过程宏来消除代码中直接的  <code>unsafe</code>  块的使用，从而规避了编译器对 Unsafe 关键字的静态检查。</p>
<p>该库会通过<code>#[safe]</code> 过程宏在自动生成代码的时候为函数体添加   <code>unsafe</code> 块，但这会影响到 <code>unsafe</code> 调用链依赖静态检查传播，从而进一步打断 unsafe 调用链路，影响后续通过 <code>unsafe</code> 关键字来定位问题。</p>
<pre><pre class="playground"><code class="language-rust">use plutonium::safe;

#[safe]
fn super_safe(x: f32) -&gt; i32 {
    std::mem::transmute::&lt;f32, i32&gt;(x)
}

#[safe]
unsafe fn deref_null() {
    *std::ptr::null::&lt;u8&gt;();
}

fn main(){
    println!(&quot;{:?}&quot;, super_safe(1.0));
    deref_null();
}
</code></pre></pre>
<p>【相关讨论】</p>
<ul>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2020-0011.html">RUSTSEC-2020-0011</a></li>
<li><a href="https://github.com/RustSec/advisory-db/issues/275">https://github.com/RustSec/advisory-db/issues/275</a></li>
<li><a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/278">https://github.com/rust-lang/unsafe-code-guidelines/issues/278</a></li>
</ul>
<h2><a class="header" href="#pmacproc02--实现过程宏时要对关键特性增加测试" id="pmacproc02--实现过程宏时要对关键特性增加测试">P.MAC.Proc.02  实现过程宏时要对关键特性增加测试</a></h2>
<p>【描述】</p>
<p>实现过程宏的时候，要对关键特性增加测试，这是为了避免出现关键特性遗漏的情况。 </p>
<p>【正例】</p>
<p>在第三方库 <a href="https://github.com/iqlusioninc/crates/tree/main/zeroize">zeroize</a> 中，曾经因为过程宏中对枚举类型没有实现 Drop 而引起问题。增加关键性测试可以避免这类问题。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn zeroize_on_struct() {
    parse_zeroize_test(stringify!(
        #[zeroize(drop)]
        struct Z {
            a: String,
            b: Vec&lt;u8&gt;,
            c: [u8; 3],
        }
    ));
}

#[test]
fn zeroize_on_enum() {
    parse_zeroize_test(stringify!(
        #[zeroize(drop)]
        enum Z {
            Variant1 { a: String, b: Vec&lt;u8&gt;, c: [u8; 3] },
        }
    ));
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<p>在第三方库 <a href="https://github.com/iqlusioninc/crates/tree/main/zeroize">zeroize</a> 中，曾经因为过程宏中对枚举类型没有实现 Drop 而引起问题。参见：<a href="https://rustsec.org/advisories/RUSTSEC-2021-0115.html">RUSTSEC-2021-0115</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Zeroize)]
#[zeroize(drop)]
pub enum Fails {
    Variant(Vec&lt;u8&gt;),
}

// This does compile with zeroize_derive version 1.1, meaning `#[zeroize(drop)]` didn't implement `Drop`.
impl Drop for Fails {
    fn drop(&amp;mut self) {
        todo!()
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#pmacproc03-保证过程宏的卫生性" id="pmacproc03-保证过程宏的卫生性">P.MAC.Proc.03 保证过程宏的卫生性</a></h2>
<p>【描述】</p>
<p>过程宏生成的代码尽量使用完全限定名，防止命名冲突产生意想不到的后果。 </p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>quote!(::std::ToString::to_string(a))
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>quote! {{
    use ::std::ToString;
    a.to_string()
}}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>quote!(a.to_string())
<span class="boring">}
</span></code></pre></pre>
<p>【测试】</p>
<p>使用<code>#![no_implicit_prelude]</code>属性来验证过程宏的卫生性。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![no_implicit_prelude]

<span class="boring">fn main() {
</span>#[derive(MyMacro)]
struct A;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#pmacproc04-给出正确的错误位置" id="pmacproc04-给出正确的错误位置">P.MAC.Proc.04 给出正确的错误位置</a></h2>
<p>【描述】</p>
<p>过程宏发生错误时，返回的错误应该有正确的位置信息。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[proc_macro_derive(MyMacro)]
pub fn derive_my_macro(input: TokenStream) -&gt; TokenStream {
    let derive_input: DeriveInput = syn::parse_macro_input!(input as DeriveInput);

    if let Data::Enum(e) = &amp;derive_input.data {
        for variant in &amp;e.variants {
            if !variant.fields.is_empty() {
                // 使用variant的span
                return syn::Error::new_spanned(&amp;variant, &quot;must be a unit variable.&quot;)
                    .to_compile_error()
                    .into();
            }
        }
    }

    todo!()
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 直接用Span::call_site()
Error::new(Span::call_site(), &quot;requires unit variant&quot;)
    .to_compile_error()
    .into()
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#pmacproc05-代码生成要按情况选择使用过程宏还是buildrs" id="pmacproc05-代码生成要按情况选择使用过程宏还是buildrs">P.MAC.Proc.05 代码生成要按情况选择使用过程宏还是<code>build.rs</code></a></h2>
<p>【描述】</p>
<p>用过程宏生进行代码生成，比如生成新类型或函数，有一个缺点就是：IDE无法识别它们，影响开发体验。</p>
<p>但是使用<code>build.rs</code>生成的代码，对 IDE 更友好。</p>
<p>不过随着 IDE 的增强，过程宏以后应该也能变得更加 IDE 友好。</p>
<p>建议按应用场景选择：</p>
<ul>
<li><code>build.rs</code> 一般用于根据外部文件生成代码的场景。比如根据 <code>C</code> 头文件生成 Rust 绑定，或者根据 <code>proto</code> 文件生成相应的 Rust 类型等，供开发者直接使用。</li>
<li>过程宏一般用于消除样例式代码，提升库使用者的开发体验。</li>
</ul>
<p>【正例】</p>
<p><code>build.rs</code> 把 <code>tonic</code> 生成的代码直接放在 <code>src</code> 目录(生成的代码文件应该在 .gitignore 中忽略版本管理)，这样 IDE 能够识别它们使自动完成能够工作，提高开发效率。</p>
<pre><pre class="playground"><code class="language-rust">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    tonic_build::configure()
        .out_dir(&quot;src&quot;)
        .compile(
            &amp;[&quot;proto/helloworld/helloworld.proto&quot;],
            &amp;[&quot;proto/helloworld&quot;],
        )?;
    println!(&quot;cargo:rerun-if-changed=proto&quot;);
}
</code></pre></pre>
<p><code>tarpc</code>的<code>service</code>宏会生成一个新的<code>WorldClient</code>类型，IDE完全无法识别。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tarpc::service]
trait World {
    async fn hello(name: String) -&gt; String;
}

let (client_transport, server_transport) = tarpc::transport::channel::unbounded();
let mut client = WorldClient::new(client::Config::default(), client_transport).spawn();
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#pmacproc06-buildrs-生成的代码要保证没有任何警告" id="pmacproc06-buildrs-生成的代码要保证没有任何警告">P.MAC.Proc.06 build.rs 生成的代码要保证没有任何警告</a></h2>
<p>【描述】</p>
<p>build.rs 生成的代码(codegen)，要通过或忽略 clippy 检查，不要让用户/库的使用者自行忽略</p>
<p>codegen 库要保证生成的代码应该非常干净没有任何警告，不应该让库的使用者去处理生成代码中的警告</p>
<p>【正例】</p>
<p>tonic-build 生成的 rs 会通过 allow 忽略掉 clippy 警告</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod peer_communication_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<p>lalrpop v0.19.6 生成的代码有几百个 clippy 警告，&quot;淹没&quot;了用户自己代码的 clippy 警告</p>
<pre><code>warning: using `clone` on type `usize` which implements the `Copy` trait
      --&gt; /home/w/temp/my_parser/target/debug/build/my_parser-dd96f436ee76c58d/out/my_parser.rs:182148:21
       |
182148 |         let __end = __start.clone();
       |                     ^^^^^^^^^^^^^^^ help: try removing the `clone` call: `__start`
</code></pre>
<p>使得 lalrpop 库的使用者必须手动给生成的模块代码加上 allow clippy ，给使用者带来不便</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>lalrpop_mod!(
    #[allow(clippy::all)]
    my_parser
);
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#多线程" id="多线程">多线程</a></h1>
<p>Rust 天生线程安全，可以有效消除数据竞争。</p>
<hr />
<p>多线程并发可以分为两类：</p>
<ul>
<li><a href="safe-guides/coding_practice/./threads/lock.html">锁同步</a></li>
<li><a href="safe-guides/coding_practice/./threads/lock-free.html">无锁并发</a></li>
</ul>
<h1><a class="header" href="#锁同步" id="锁同步">锁同步</a></h1>
<p>Rust 中多线程并发使用锁来进行线程同步。</p>
<hr />
<h2><a class="header" href="#pmthlock01--首选--a-hrefhttpscratesiocratesparking_lotparking_lota-中定义的-同步原语而非标准库-stdsync-模块" id="pmthlock01--首选--a-hrefhttpscratesiocratesparking_lotparking_lota-中定义的-同步原语而非标准库-stdsync-模块">P.MTH.lock.01  首选  <a href="https://crates.io/crates/parking_lot"><code>parking_lot</code></a> 中定义的 同步原语，而非标准库 <code>std::sync</code> 模块</a></h2>
<p><strong>【描述】</strong></p>
<p>标准库中 <code>std::sync</code> 模块中实现的锁同步原语，存在一些问题，比如需要使用 <code>Box&lt;T&gt;</code> 将操作系统锁原语维持在同一个内存位置，这点浪费内存。而   <a href="https://crates.io/crates/parking_lot"><code>parking_lot</code></a>  的实现则更加轻量和正确，性能也更好，比如 <code>parking_lot</code> 的 <code>Mutex</code> 和  <code>Rwlock</code> 都支持 最终公平性，在不失性能的基础上保证公平。 目前官方正在推动 parking_lot 进入标准库中。在使用 parking_lot 时注意和标准库的区别。</p>
<p>parking_lot 也提供了一些有用的 feature，比如 死锁检测（deadlock detection），在使用  Mutex 的时候，可以打开这个特性，可以在编译期发现死锁，没准可以节省你很多时间。</p>
<h2><a class="header" href="#pmthlock02---根据场景选择使用互斥锁还是-channel" id="pmthlock02---根据场景选择使用互斥锁还是-channel">P.MTH.lock.02   根据场景选择使用互斥锁还是 Channel</a></h2>
<p><strong>【描述】</strong></p>
<p>不要从哪种方式更快的角度来考虑，而应该从使用场景。性能取决于你如何使用它们。</p>
<p>一个简单的指南：</p>
<table><thead><tr><th><strong>Channel</strong> 适用于</th><th><strong>Mutex</strong> 适用于</th></tr></thead><tbody>
<tr><td>传递数据所有权 <br /> 分发工作单元 <br /> 传递异步结果</td><td>修改共享缓存<br /> 修改共享状态</td></tr>
</tbody></table>
<h2><a class="header" href="#pmthlock03---如果要使用-channel--建议使用-crossbeam-或-flume" id="pmthlock03---如果要使用-channel--建议使用-crossbeam-或-flume">P.MTH.lock.03   如果要使用 Channel  建议使用 <code>crossbeam</code> 或 <code>flume</code></a></h2>
<p><strong>【描述】</strong></p>
<p>标准库中的 channel 实现并不好，也许会被移使用 <code>crossbeam</code> 或 <code>flume</code>  目前是约定俗成。</p>
<h2><a class="header" href="#pmthlock04----多线程下要注意识别锁争用的情况避免死锁" id="pmthlock04----多线程下要注意识别锁争用的情况避免死锁">P.MTH.lock.04    多线程下要注意识别锁争用的情况，避免死锁</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 并不能保证没有死锁，要注意 <code> LockResult&lt;MutexGuard&lt;'_, T&gt;&gt;</code> 的生命周期，以防止出现锁争用的情况。</p>
<hr />
<h2><a class="header" href="#gmthlock01---对-布尔-或-引用-并发访问应该使用原子类型而非互斥锁" id="gmthlock01---对-布尔-或-引用-并发访问应该使用原子类型而非互斥锁">G.MTH.lock.01   对 布尔 或 引用 并发访问应该使用原子类型而非互斥锁</a></h2>
<h3><a class="header" href="#级别建议-119" id="级别建议-119">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-119" id="lint-检测-119">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#mutex_atomic">mutex_atomic</a></td><td>yes</td><td>no</td><td>perf</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-152" id="描述-152">【描述】</a></h3>
<p>使用原子类型性能更好。但要注意指定合理的内存顺序。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = AtomicBool::new(y);
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = Mutex::new(&amp;y);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gmthlock02---多线程环境下要使用-arc-代替-rc" id="gmthlock02---多线程环境下要使用-arc-代替-rc">G.MTH.lock.02   多线程环境下要使用 <code>Arc</code> 代替 <code>Rc</code></a></h2>
<h3><a class="header" href="#级别建议-120" id="级别建议-120">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-120" id="lint-检测-120">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#rc_mutex">rc_mutex</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-153" id="描述-153">【描述】</a></h3>
<p><code>Rc</code> 是专门用于单线程的，多线程下应该用  <code>Arc</code> 。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;
use std::sync::Arc;
use std::cell::RefCell
fn foo(interned: Rc&lt;RefCell&lt;i32&gt;&gt;) { ... }
// or
fn foo(interned: Arc&lt;Mutex&lt;i32&gt;&gt;) { ... }
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;
use std::sync::Mutex;
fn foo(interned: Rc&lt;Mutex&lt;i32&gt;&gt;) { ... }
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gmthlock03---建议使用-arcstr-arct-来代替--arcstring--arcvect" id="gmthlock03---建议使用-arcstr-arct-来代替--arcstring--arcvect">G.MTH.lock.03   建议使用 <code>Arc&lt;str&gt;/ Arc&lt;[T]&gt;</code> 来代替  <code>Arc&lt;String&gt; / Arc&lt;Vec&lt;T&gt;&gt;</code></a></h2>
<h3><a class="header" href="#级别建议-121" id="级别建议-121">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-121" id="lint-检测-121">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#rc_buffer">rc_buffer</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-154" id="描述-154">【描述】</a></h3>
<p><code>Arc&lt;str&gt;/ Arc&lt;[T]&gt;</code> 的性能比  <code>Arc&lt;String&gt; / Arc&lt;Vec&lt;T&gt;&gt;</code> 更好。</p>
<p>因为 ：</p>
<ul>
<li><code>Arc&lt;String&gt; / Arc&lt;Vec&lt;T&gt;&gt;</code> 有一层中间层： <code>arc -&gt; String len/Vec&lt;T&gt; len -&gt; text/data</code> ，它是一个 薄指针（thin pointer） 。</li>
<li><code>Arc&lt;str&gt;/ Arc&lt;[T]&gt;</code> 则没有中间层： <code>arc &amp; string len / [T] len -&gt; text/data</code>， 它是一个胖指针（fat pointer）。</li>
</ul>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;
use std::sync::Arc;

fn main() {
    let a: &amp;str = &quot;hello world&quot;;
    let b: Rc&lt;str&gt; = Rc::from(a);
    println!(&quot;{}&quot;, b);

    // or equivalently:
    let b: Rc&lt;str&gt; = a.into();
    println!(&quot;{}&quot;, b);

    // we can also do this for Arc,
    let a: &amp;str = &quot;hello world&quot;;
    let b: Arc&lt;str&gt; = Arc::from(a);
    println!(&quot;{}&quot;, b);
}
</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;
use std::sync::Arc;

fn main() {
    let a = &quot;hello world&quot;.to_string();
    let b: Rc&lt;String&gt; = Rc::from(a);
    println!(&quot;{}&quot;, b);

    // or equivalently:
    let a = &quot;hello world&quot;.to_string();
    let b: Rc&lt;String&gt; = a.into();
    println!(&quot;{}&quot;, b);

    // we can also do this for Arc,
    let a = &quot;hello world&quot;.to_string();
    let b: Arc&lt;String&gt; = Arc::from(a);
    println!(&quot;{}&quot;, b);
}
</code></pre></pre>
<h2><a class="header" href="#gmthlock04----尽量避免直接使用标准库-stdsync-模块中的同步原语替换为--a-hrefhttpscratesiocratesparking_lotparking_lota" id="gmthlock04----尽量避免直接使用标准库-stdsync-模块中的同步原语替换为--a-hrefhttpscratesiocratesparking_lotparking_lota">G.MTH.lock.04    尽量避免直接使用标准库 <code>std::sync</code> 模块中的同步原语，替换为  <a href="https://crates.io/crates/parking_lot"><code>parking_lot</code></a></a></h2>
<h3><a class="header" href="#级别建议-122" id="级别建议-122">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-122" id="lint-检测-122">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制化参考】
这条规则如果需要定制 Lint，则可以扫描 <code>std::sync</code> 锁同步原语的使用，推荐优先选择 crate <code>parking_lot</code> 中对应的同步原语。</p>
<p><strong>【描述】</strong></p>
<p>尽量避免对标准库 <code>std::sync</code> 模块中锁同步原语的使用，建议使用   <a href="https://crates.io/crates/parking_lot"><code>parking_lot</code></a>  的实现。</p>
<p>【正例】</p>
<p>例子来源于 <a href="https://docs.rs/parking_lot/0.11.2/parking_lot/type.Mutex.html">parking_lot 文档</a></p>
<p>相比<code>std::sync::Mutex</code>，使用 <code>parking_lot::Mutex</code> 能获得’无中毒’，锁在 panic 时正常释放，更少的空间占用等优势。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use parking_lot::Mutex;
use std::sync::{Arc, mpsc::channel};
use std::thread;

const N: usize = 10;

let data = Arc::new(Mutex::new(0));

let (tx, rx) = channel();
for _ in 0..10 {
    let (data, tx) = (Arc::clone(&amp;data), tx.clone());
    thread::spawn(move || {
        let mut data = data.lock();
        *data += 1;
        if *data == N {
            tx.send(()).unwrap();
        }
    });
}

rx.recv().unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<p>来源于 <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html">std标准库文档</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, Mutex};
use std::thread;
use std::sync::mpsc::channel;

const N: usize = 10;

let data = Arc::new(Mutex::new(0));

let (tx, rx) = channel();
for _ in 0..N {
    let (data, tx) = (Arc::clone(&amp;data), tx.clone());
    thread::spawn(move || {      
        let mut data = data.lock().unwrap();
        *data += 1;
        if *data == N {
            tx.send(()).unwrap();
        }
    });
}

rx.recv().unwrap();
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gmthlock05----尽量避免直接使用标准库-stdsyncmpsc-模块中的channel替换为--a-hrefhttpsgithubcomcrossbeam-rscrossbeamcrossbeama" id="gmthlock05----尽量避免直接使用标准库-stdsyncmpsc-模块中的channel替换为--a-hrefhttpsgithubcomcrossbeam-rscrossbeamcrossbeama">G.MTH.lock.05    尽量避免直接使用标准库 <code>std::sync::mpsc</code> 模块中的<code>channel</code>，替换为  <a href="https://github.com/crossbeam-rs/crossbeam"><code>crossbeam</code></a></a></h2>
<h3><a class="header" href="#级别建议-123" id="级别建议-123">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-123" id="lint-检测-123">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制化参考】
这条规则如果需要定制 Lint，则可以扫描对 <code>std::sync::mpsc::channel</code> 的使用，推荐优先选择 crate <code>crossbeam</code>。</p>
<p><strong>【描述】</strong></p>
<p>尽量避免使用 <code>std::sync::mpsc::channel</code> ，建议使用 <a href="https://github.com/crossbeam-rs/crossbeam"><code>crossbeam</code></a></p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crossbeam_channel::unbounded;

let (tx, rx) = unbounded();

for i in 0..10 {
    let tx = tx.clone();
    thread::spawn(move|| {
        tx.send(i).unwrap();
    });
}

for _ in 0..10 {
    let j = rx.recv().unwrap();
    assert!(0 &lt;= j &amp;&amp; j &lt; 10);
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<p>例子来源于 <a href="https://doc.rust-lang.org/std/sync/mpsc/"><code>std::sync::mpsc</code>文档</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;
use std::sync::mpsc::channel;

let (tx, rx) = channel();

for i in 0..10 {
    let tx = tx.clone();
    thread::spawn(move|| {
        tx.send(i).unwrap();
    });
}

for _ in 0..10 {
    let j = rx.recv().unwrap();
    assert!(0 &lt;= j &amp;&amp; j &lt; 10);
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#无锁并发" id="无锁并发">无锁并发</a></h1>
<p>Rust 也支持原子类型，其内存顺序模型与 C++ 20 相同。</p>
<hr />
<h2><a class="header" href="#pmthlockfree01--除非必要否则建议使用同步锁" id="pmthlockfree01--除非必要否则建议使用同步锁">P.MTH.lockfree.01  除非必要，否则建议使用同步锁</a></h2>
<p>【描述】</p>
<p>不要认为无锁编程性能就一定高，并且需要注意的地方比使用同步锁都多，比如 指令重排 、ABA 问题、 内存顺序是否指定正确等。</p>
<p>正确实现无锁编程比使用同步锁要困难很多。所以，除非有必要，否则直接使用同步锁就可以。</p>
<p>也有一些 <a href="https://github.com/magiclen/rust-performance-measurement/blob/master/benches/atomic_mutex.rs">性能测试</a> 作为参考，原子类型的性能比互斥锁的性能大概要好四倍左右。所以，当在同一个临界区内要有超过四次原子操作，也许使用互斥锁更加简单一些。</p>
<h2><a class="header" href="#pmthlockfree02---如有必要使用无锁编程那么内存顺序可以默认使用-orderingseqcst" id="pmthlockfree02---如有必要使用无锁编程那么内存顺序可以默认使用-orderingseqcst">P.MTH.lockfree.02   如有必要使用无锁编程，那么内存顺序可以默认使用 <code>Ordering::SeqCst</code></a></h2>
<p>【描述】</p>
<p>使用 <code>Ordering::SeqCst</code> 内存顺序更加安全一些，并且性能在一般情况下够用，除非性能不够用，想进一步压榨性能的时候，再去考虑合理使用其他内存顺序。</p>
<h1><a class="header" href="#异步编程" id="异步编程">异步编程</a></h1>
<hr />
<h2><a class="header" href="#pasy01--异步编程并不适合所有场景计算密集型场景应该考虑同步编程" id="pasy01--异步编程并不适合所有场景计算密集型场景应该考虑同步编程">P.ASY.01  异步编程并不适合所有场景，计算密集型场景应该考虑同步编程</a></h2>
<p>【描述】</p>
<p>异步编程适合 I/O 密集型应用，如果是计算密集型场景应该考虑使用同步编程。</p>
<h2><a class="header" href="#pasy02--异步编程中要避免阻塞操作" id="pasy02--异步编程中要避免阻塞操作">P.ASY.02  异步编程中要避免阻塞操作</a></h2>
<p>【描述】</p>
<p>异步编程中如果出现阻塞，则会阻止同一线程上其他异步任务的执行，从而导致很大的延迟，或者死锁。</p>
<hr />
<h2><a class="header" href="#gasy01-在-async-块函数中调用-async-函数闭包请不要忘记添加await" id="gasy01-在-async-块函数中调用-async-函数闭包请不要忘记添加await">G.ASY.01 在 <code>async</code> 块/函数中调用 <code>async</code> 函数/闭包请不要忘记添加<code>.await</code></a></h2>
<h3><a class="header" href="#级别建议-124" id="级别建议-124">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-124" id="lint-检测-124">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#async_yields_async">async_yields_async</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
</tbody></table>
<p>也有例外情况。</p>
<h3><a class="header" href="#描述-155" id="描述-155">【描述】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn foo() {}

fn bar() {
  let x = async {
    foo().await
  };
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn foo() {}

fn bar() {
  let x = async {
    foo()
  };
}
<span class="boring">}
</span></code></pre></pre>
<p>【例外】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// https://docs.rs/crate/fishrock_lambda_runtime/0.3.0-patched.1/source/src/lib.rs#:~:text=clippy%3a%3aasync_yields_async

#[allow(clippy::async_yields_async)]
let task = tokio::spawn(async move { handler.call(body, ctx) });

let req = match task.await {
    // ...
}

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gasy02-在-跨await-调用中持有同步互斥锁需要进行处理" id="gasy02-在-跨await-调用中持有同步互斥锁需要进行处理">G.ASY.02 在 跨<code>await</code> 调用中持有同步互斥锁需要进行处理</a></h2>
<h3><a class="header" href="#级别建议-125" id="级别建议-125">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-125" id="lint-检测-125">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#await_holding_lock">await_holding_lock</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-156" id="描述-156">【描述】</a></h3>
<p>同步互斥锁本来就不是为异步上下文跨 <code>await</code> 调用而设计的，在这种场景中使用同步互斥锁容易造成死锁。当同步互斥锁被跨 await 时，有可能很长时间都不会返回这个调用点，在其他任务中再次用到这个互斥锁的时候，容易造成死锁。</p>
<p>这里有三种解决方案：</p>
<ol>
<li>使用异步互斥锁。但是异步互斥锁的开销要大于同步互斥锁。</li>
<li>确保同步互斥锁在调用 <code>await</code> 之前已经释放。</li>
</ol>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;
// 使用同步互斥锁
async fn foo(x: &amp;Mutex&lt;u32&gt;) {
  {
    let guard = x.lock().unwrap();
    *guard += 1;
  }
  bar.await;
}

// 使用异步互斥锁
use tokio::sync::Mutex;
use std::sync::Arc;

#[tokio::main]
async fn main() {
    // 使用 Arc 允许跨线程共享 Mutex
    let count = Arc::new(Mutex::new(0));

    for i in 0..5 {
        let my_count = Arc::clone(&amp;count);
        tokio::spawn(async move {
            for j in 0..10 {
                // 这里的 lock 在每次迭代后都会被释放
                let mut lock = my_count.lock().await;
                *lock += 1;
                println!(&quot;{} {} {}&quot;, i, j, lock);
            }
        });
    }

    loop {
        // 这里的 lock 在每次迭代后都会被释放
        if *count.lock().await &gt;= 50 {
            break;
        }
    }
    println!(&quot;Count hit 50.&quot;);
}
</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Mutex;

async fn foo(x: &amp;Mutex&lt;u32&gt;) {
  let guard = x.lock().unwrap();
  *guard += 1;
  bar.await;
}
<span class="boring">}
</span></code></pre></pre>
<p>【例外】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // FROM: https://github.com/khonsulabs/kludgine/blob/main/app/src/runtime/smol.rs#L31
    // Launch a thread pool
    std::thread::spawn(|| {
        let (signal, shutdown) = flume::unbounded::&lt;()&gt;();

        easy_parallel::Parallel::new()
            // Run four executor threads.
            .each(0..4, |_| {
                #[allow(clippy::await_holding_lock)] // 这里是 读写锁，不是互斥锁
                futures::executor::block_on(async {
                    let guard = GLOBAL_THREAD_POOL.read(); // 获取读写锁的读锁，不会出现锁争用情况，所以是线程安全的
                    let executor = guard.as_ref().unwrap();
                    executor.run(shutdown.recv_async()).await
                })
            })
            // Run the main future on the current thread.
            .finish(|| {});

        drop(signal);
    });
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gasy03-在-跨await-调用持有refcell的引用需要进行处理" id="gasy03-在-跨await-调用持有refcell的引用需要进行处理">G.ASY.03 在 跨<code>await</code> 调用持有<code>RefCell</code>的引用需要进行处理</a></h2>
<h3><a class="header" href="#级别建议-126" id="级别建议-126">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-126" id="lint-检测-126">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#await_holding_refcell_ref">await_holding_refcell_ref</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-157" id="描述-157">【描述】</a></h3>
<p>跟不要在异步上下文中跨 <code>await</code> 使用  同步互斥锁类似，使用 <code>RefCell</code> 的独占（可变）借用会导致 Panic。因为 <code>RefCell</code> 是运行时检查独占的可变访问，如果 跨 <code>await</code> 持有一个可变引用则可能会因为共享的可变引用而引起 Panic。</p>
<p>这种共享可变在编译期是无法被检查出来的。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;

async fn foo(x: &amp;RefCell&lt;u32&gt;) {
  {
     let mut y = x.borrow_mut();
     *y += 1;
  }
  bar.await;
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;

async fn foo(x: &amp;RefCell&lt;u32&gt;) {
  let mut y = x.borrow_mut();
  *y += 1;
  bar.await;
}
<span class="boring">}
</span></code></pre></pre>
<p>【例外】</p>
<p>跨 <code>await</code> 持有 <code>RefCell</code> 的可变借用，但是当前场景确信永远不会 Panic，则可以使用。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From ： https://github.com/MattiasBuelens/wasm-streams/blob/master/src/readable/into_underlying_byte_source.rs#L65
let fut = async move {
    // This mutable borrow can never panic, since the ReadableStream always queues
    // each operation on the underlying source.
    //  这个可变借用永远不会恐慌，因为 ReadableStream 对底层源的每个操作总是有序的。
    let mut inner = inner.try_borrow_mut().unwrap_throw();
    inner.pull(controller).await
};
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gasy04-避免定义不必要的异步函数" id="gasy04-避免定义不必要的异步函数">G.ASY.04 避免定义不必要的异步函数</a></h2>
<h3><a class="header" href="#描述-158" id="描述-158">【描述】</a></h3>
<p>如果一个异步函数内部没有任何异步代码，相比一个同步函数，它会产生额外的调用成本。</p>
<h3><a class="header" href="#级别建议-127" id="级别建议-127">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-127" id="lint-检测-127">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#unused_async">unused_async</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(value: i32) -&gt; i32 {
    value + 1
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn add(value: i32) -&gt; i32 {
    value + 1
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gasy05--避免在异步处理过程中包含阻塞操作" id="gasy05--避免在异步处理过程中包含阻塞操作">G.ASY.05  避免在异步处理过程中包含阻塞操作</a></h2>
<h3><a class="header" href="#级别建议-128" id="级别建议-128">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-128" id="lint-检测-128">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制化参考】
这条规则如果需要定制Lint，则可以扫描异步过程，找到黑名单定义的阻塞操作调用，进行告警。</p>
<h3><a class="header" href="#描述-159" id="描述-159">【描述】</a></h3>
<p>避免在异步编程中使用阻塞操作。</p>
<p>【正例】</p>
<p>使用异步运行时，如tokio提供的非阻塞函数</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::fs;

async fn read_file() -&gt; std::io::Result&lt;()&gt; {
    let _ = fs::read_to_string(&quot;test.txt&quot;).await?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<p>不要在异步流程中使用阻塞操作函数</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::error::Error;
use std::{fs, io};
    
async fn read_file() -&gt; Result&lt;String, std::io::Error&gt; {
    fs::read_to_string(&quot;test.txt&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#unsafe-rust" id="unsafe-rust">Unsafe Rust</a></h1>
<p>Unsafe Rust 是 Safe Rust 的超集，意味着在 Unsafe Rust 中也会有 Safe Rust的安全检查。但是 Unsafe Rust 中下面五件事是Safe Rust 的检查鞭长莫及的地方：</p>
<ol>
<li>解引用裸指针</li>
<li>调用 <code>unsafe</code>函数（C函数，编译器内部函数或原始分配器）</li>
<li>实现 <code>unsafe</code> trait</li>
<li>可变静态变量</li>
<li>访问  <code>union</code> 的字段</li>
</ol>
<p>使用 Unsafe Rust 的时候，需要遵守一定的规范，这样可以避免未定义行为的发生。</p>
<p>关于 Unsafe Rust 下的一些专用术语可以查看 <a href="safe-guides/coding_practice/./unsafe_rust/glossary.html">Unsafe 代码术语指南</a> 。</p>
<p><strong>Unsafe Rust 的语义：这是编译器无法保证安全的地方，需要程序员来保证安全。</strong> </p>
<hr />
<h2><a class="header" href="#本节包含内容如下" id="本节包含内容如下">本节包含内容如下：</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/./unsafe_rust/mem.html">内存</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/raw_ptr.html">裸指针</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/safe_abstract.html">安全抽象</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/union.html">联合体</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/ffi.html">FFi</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/io.html">IO</a></li>
</ul>
<hr />
<h2><a class="header" href="#puns01--不要为了逃避-编译器安全检查而滥用-unsafe-rust" id="puns01--不要为了逃避-编译器安全检查而滥用-unsafe-rust">P.UNS.01  不要为了逃避 编译器安全检查而滥用 Unsafe Rust</a></h2>
<p><strong>【描述】</strong></p>
<p>Unsafe Rust 有其应用范围和目标，不要为了逃避 编译器安全检查而随便滥用 Unsafe Rust。</p>
<h2><a class="header" href="#puns02--不要为了提升性能而盲目使用-unsafe-rust" id="puns02--不要为了提升性能而盲目使用-unsafe-rust">P.UNS.02  不要为了提升性能而盲目使用 Unsafe Rust</a></h2>
<p><strong>【描述】</strong></p>
<p>对比 Safe 代码的性能看是否够用，就可以减少不必要的 Unsafe。</p>
<hr />
<h2><a class="header" href="#guns01--不要随便为-带有-unsafe命名的-类型或方法创建别名" id="guns01--不要随便为-带有-unsafe命名的-类型或方法创建别名">G.UNS.01  不要随便为 带有 <code>unsafe</code>命名的 类型或方法创建别名</a></h2>
<h3><a class="header" href="#级别建议-129" id="级别建议-129">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-129" id="lint-检测-129">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#unsafe_removed_from_name">unsafe_removed_from_name</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-160" id="描述-160">【描述】</a></h3>
<p>Rust 里  <code>unsafe</code> 字样用于提醒开发者在编写代码的时候注意保证安全。如果修改别名，隐藏了这种提醒，不利于展示这种信息。</p>
<p>不利于开发者去保证安全。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::{UnsafeCell  };

extern crate crossbeam;
use crossbeam::{spawn_unsafe  };
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::{UnsafeCell as TotallySafeCell};

extern crate crossbeam;
use crossbeam::{spawn_unsafe as spawn};
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#安全抽象规范" id="安全抽象规范">安全抽象规范</a></h1>
<p>使用 Unsafe Rust 的一种方式是将 Unsafe 的方法或函数进行安全抽象，将其变成安全的方法或函数。</p>
<p>Unsafe Rust 中 API 的安全性设计通常有两种方式：</p>
<ol>
<li>将内部的 unsafe API 直接暴露给 API 的使用者，并且使用 <code>unsafe</code> 关键字来声明该 API 是非安全的，同时也需要对安全边界条件添加注释。</li>
<li>对 API 进行安全封装，即，安全抽象。在内部使用断言来保证当越过安全边界时可以 Panic，从而避免 UB 产生。</li>
</ol>
<p>第二种方式，对 Unsafe 代码进行安全抽象，是 Rust 生态的一种约定俗成。</p>
<hr />
<h2><a class="header" href="#punssafeabstract01---代码中要注意是否会因为-panic-发生而导致内存安全问题" id="punssafeabstract01---代码中要注意是否会因为-panic-发生而导致内存安全问题">P.UNS.SafeAbstract.01   代码中要注意是否会因为 Panic 发生而导致内存安全问题</a></h2>
<p><strong>【描述】</strong></p>
<p>Panic 一般在程序达到不可恢复的状态才用，当然在 Rust 中也可以对一些实现了 <code>UnwindSafe</code> trait 的类型捕获恐慌。</p>
<p>当 Panic 发生时，会引发栈回退（stack unwind），调用栈分配对象的析构函数，并将控制流转移给恐慌处理程序中。所以，当恐慌发生的时候，当前存活变量的析构函数将会被调用，从而导致一些内存安全问题，比如释放已经释放过的内存。</p>
<p>通常， 封装的Unsafe 代码可能会暂时绕过所有权检查，而且，安全封装的 API 在内部unsafe 代码的值返回之前，会根据安全边界条件确保它不会违反安全规则。但是，假如封装的Unsafe 代码发生了恐慌，则其外部安全检查可能不会执行。这很可能导致类似 C/C++ 中 未初始化（Uninitialized ）或双重释放（Double Free）的内存不安全问题。</p>
<p>想要正确的推理在 Unsafe 代码中的恐慌安全，是非常困难且易于出错的。即便如此，在编写代码的时候也要刻意注意此类问题发生的可能性。</p>
<p>【示例】</p>
<pre><pre class="playground"><code class="language-rust">// 标准库 `String::retain()` 曝出的 CVE-2020-36317 Panic safety bug

pub fn retain&lt;F&gt;(&amp;mut self, mut f: F)
where 
    F: FnMut(char) -&gt; bool
{
    let len = self.len();
    let mut del_bytes = 0;
 	let mut idx = 0;
 
    unsafe { self.vec.set_len(0); }    // + 修复bug 的代码
 	while idx &lt; len {
 		let ch = unsafe {
  			self.get_unchecked(idx..len).chars().next().unwrap()
 		};
 		let ch_len = ch.len_utf8();
 
 		// self is left in an inconsistent state if f() panics
        // 此处如果 f() 发生了恐慌，self 的长度就会不一致
 		if !f(ch) {
 			del_bytes += ch_len;
 		} else if del_bytes &gt; 0 {
 			unsafe {
 				ptr::copy(self.vec.as_ptr().add(idx),
 				self.vec.as_mut_ptr().add(idx - del_bytes),
 				ch_len);
 			}
 		}
 		idx += ch_len; // point idx to the next char
 	}
 	unsafe { self.vec.set_len(len - del_bytes); } // + 修复bug 的代码 ，如果 while 里发生panic，则将返回长度设置为 0 
}

fn main(){
    // PoC: creates a non-utf-8 string in the unwinding path
    // 此处传入一个 非 UTF-8 编码字符串引发恐慌
    &quot;0è0&quot;.to_string().retain(|_| {
        match the_number_of_invocation() {
            1 =&gt; false,
            2 =&gt; true,
            _ =&gt; panic!(),
        }
    });
}
</code></pre></pre>
<h2><a class="header" href="#punssafeabstract02----unsafe-代码编写者有义务检查代码是否满足安全不变式" id="punssafeabstract02----unsafe-代码编写者有义务检查代码是否满足安全不变式">P.UNS.SafeAbstract.02    Unsafe 代码编写者有义务检查代码是否满足安全不变式</a></h2>
<p><strong>【描述】</strong></p>
<p>安全不变式（见 <a href="safe-guides/coding_practice/unsafe_rust/./glossary.html">Unsafe 代码术语指南</a> ）是 Rust 里的安全函数，在任何有效输入的情况下，都不应该发生任何未定义行为。</p>
<p>可以从以下三个方面来检查：</p>
<ol>
<li>逻辑一致性。</li>
<li>纯洁性。相同的输入总是要返回相同的输出。</li>
<li>语义约束。传入的参数要合法，满足数据类型。</li>
</ol>
<p>【示例】</p>
<p>该代码是为 <code>Borrow&lt;str&gt;</code>实现 join 方法内部调用的一个函数 <code>join_generic_copy</code>的展示。 在 <code>join_generic_copy</code> 内部，会对 <code>slice</code> 进行两次转换，而在 <code>spezialize_for_lengths!</code> 宏内部，调用了<code>.borrow()</code>方法，如果第二次转换和第一次不一样，而会返回一个未初始化字节的字符串。</p>
<p>这里， <code>Borrow&lt;B&gt;</code> 是高阶类型，它内部 <code>borrow</code> 的一致性其实并没有保证，可能会返回不同的slice，如果不做处理，很可能会暴露出未初始化的字节给调用者。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// CVE-2020-36323: a higher-order invariant bug in join()
fn join_generic_copy&lt;B, T, S&gt;(slice: &amp;[S], sep: &amp;[T]) -&gt; Vec&lt;T&gt; 
where T: Copy, B: AsRef&lt;[T]&gt; + ?Sized, S: Borrow&lt;B&gt;
{
    let mut iter = slice.iter();

    // `slice`is converted for the first time
    // during the buffer size calculation.
    let len = ...;  // `slice` 在这里第一次被转换	
    let mut result = Vec::with_capacity(len);
    // ...
    unsafe {
        let pos = result.len();
        let target = result.get_unchecked_mut(pos..len);
 
        // `slice`is converted for the second time in macro
        // while copying the rest of the components.
        spezialize_for_lengths!(sep, target, iter; // `slice` 第二次被转换
        0, 1, 2, 3, 4);
 
        // Indicate that the vector is initialized
        result.set_len(len);
    }
    result
}

// PoC: a benign join() can trigger a memory safety issue
impl Borrow&lt;str&gt; for InconsistentBorrow {
    fn borrow(&amp;self) -&gt; &amp;str {
        if self.is_first_time() {
            &quot;123456&quot;
        } else {
            &quot;0&quot;
        }
    }
}

let arr: [InconsistentBorrow; 3] = Default::default();
arr.join(&quot;-&quot;);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#punssafeabstract03----不要随便在公开的-api-中暴露未初始化内存" id="punssafeabstract03----不要随便在公开的-api-中暴露未初始化内存">P.UNS.SafeAbstract.03    不要随便在公开的 API 中暴露未初始化内存</a></h2>
<p><strong>【描述】</strong></p>
<p>在公开的API中暴露未初始化内存可能导致 UB。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 修正以后的代码示例，去掉了未初始化的buf：
impl&lt;R&gt; BufRead for GreedyAccessReader&lt;R&gt;
    where
        R: Read,
{
    fn fill_buf(&amp;mut self) -&gt; IoResult&lt;&amp;[u8]&gt; {
        if self.buf.capacity() == self.consumed {
            self.reserve_up_to(self.buf.capacity() + 16);
        }

        let b = self.buf.len();
        self.buf.resize(self.buf.capacity(), 0);
        let buf = &amp;mut self.buf[b..];
        let o = self.inner.read(buf)?;

        // truncate to exclude non-written portion
        self.buf.truncate(b + o);

        Ok(&amp;self.buf[self.consumed..])
    }

    fn consume(&amp;mut self, amt: usize) {
        self.consumed += amt;
    }
}

// 另外一个已修正漏洞的代码
fn read_vec(&amp;mut self) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
    let len: u32 = de::Deserialize::deserialize(&amp;mut *self)?;
    // 创建了未初始化buf
    let mut buf = Vec::with_capacity(len as usize);
    // 初始化为 0；
    buf.resize(len as usize, 0);
    self.read_size(u64::from(len))?;
    // 将其传递给了用户提供的`Read`实现
    self.reader.read_exact(&amp;mut buf[..])?;
    Ok(buf)
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 以下是有安全风险的代码示例：
impl&lt;R&gt; BufRead for GreedyAccessReader&lt;R&gt;
    where
        R: Read,
{
    fn fill_buf(&amp;mut self) -&gt; IoResult&lt;&amp;[u8]&gt; {
        if self.buf.capacity() == self.consumed {
            self.reserve_up_to(self.buf.capacity() + 16);
        }

        let b = self.buf.len();
        let buf = unsafe {
            // safe because it's within the buffer's limits
            // and we won't be reading uninitialized memory
            // 这里虽然没有读取未初始化内存，但是会导致用户读取
            std::slice::from_raw_parts_mut(
                self.buf.as_mut_ptr().offset(b as isize),
                self.buf.capacity() - b)
        };

        match self.inner.read(buf) {
            Ok(o) =&gt; {
                unsafe {
                    // reset the size to include the written portion,
                    // safe because the extra data is initialized
                    self.buf.set_len(b + o);
                }

                Ok(&amp;self.buf[self.consumed..])
            }
            Err(e) =&gt; Err(e),
        }
    }

    fn consume(&amp;mut self, amt: usize) {
        self.consumed += amt;
    }
}

// 另外一个漏洞代码
fn read_vec(&amp;mut self) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
    let len: u32 = de::Deserialize::deserialize(&amp;mut *self)?;
    // 创建了未初始化buf
    let mut buf = Vec::with_capacity(len as usize);
    unsafe { buf.set_len(len as usize) }
    self.read_size(u64::from(len))?;
    // 将其传递给了用户提供的`Read`实现
    self.reader.read_exact(&amp;mut buf[..])?;
    Ok(buf)
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#punssafeabstract04---要考虑-panic-safety-的情况" id="punssafeabstract04---要考虑-panic-safety-的情况">P.UNS.SafeAbstract.04   要考虑 Panic Safety 的情况</a></h2>
<p><strong>【描述】</strong></p>
<p>要注意 Panic Safety 的情况，避免双重释放（double free）的问题发生。</p>
<p>在使用 <code>std::ptr</code> 模块中接口需要注意，容易产生 UB 问题，要多多查看 API 文档。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! from_event_option_array_into_event_list(
    ($e:ty, $len:expr) =&gt; (
        impl&lt;'e&gt; From&lt;[Option&lt;$e&gt;; $len]&gt; for EventList {
            fn from(events: [Option&lt;$e&gt;; $len]) -&gt; EventList {
                let mut el = ManuallyDrop::new(
                    EventList::with_capacity(events.len())
                );

                for idx in 0..events.len() {
                    let event_opt = unsafe {
                        ptr::read(events.get_unchecked(idx))
                    };

                    if let Some(event) = event_opt {
                        // Use `ManuallyDrop` to guard against
                        // potential panic within `into()`.
                        // 当 into 方法发生 panic 当时候，这里 ManuallyDrop 可以保护其不会`double free`
                        let event = ManuallyDrop::into_inner(
                            ManuallyDrop::new(event)
                            .into()
                        );
                        el.push(event);
                    }
                }
                mem::forget(events);
                ManuallyDrop::into_inner(el)
            }
        }
    )
);
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//case 1
macro_rules! from_event_option_array_into_event_list(
    ($e:ty, $len:expr) =&gt; (
        impl&lt;'e&gt; From&lt;[Option&lt;$e&gt;; $len]&gt; for EventList {
                fn from(events: [Option&lt;$e&gt;; $len]) -&gt; EventList {
                    let mut el = EventList::with_capacity(events.len());
                    for idx in 0..events.len() {
                    // 这个 unsafe 用法在 `event.into()`调用panic的时候会导致双重释放
                        let event_opt = unsafe { ptr::read(events.get_unchecked(idx)) };
                        if let Some(event) = event_opt { el.push::&lt;Event&gt;(event.into()); }
                    }
                    // 此处 mem::forget 就是为了防止 `dobule free`。
                    // 因为 `ptr::read` 也会制造一次 drop。
                    // 所以上面如果发生了panic，那就相当于注释了 `mem::forget`，导致`dobule free`
                    mem::forget(events);
                    el
                }
        }
    )
);
<span class="boring">}
</span></code></pre></pre>
<hr />
<h2><a class="header" href="#gunssafeabstract01--在-公开的-unsafe-函数的文档中必须增加--safety-注释" id="gunssafeabstract01--在-公开的-unsafe-函数的文档中必须增加--safety-注释">G.UNS.SafeAbstract.01  在 公开的 unsafe 函数的文档中必须增加 <code># Safety</code> 注释</a></h2>
<h3><a class="header" href="#级别必须-16" id="级别必须-16">【级别：必须】</a></h3>
<p>必须按此规范执行。</p>
<h3><a class="header" href="#lint-检测-130" id="lint-检测-130">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>默认 level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/index.html#missing_safety_doc">missing_safety_doc</a></td><td>yes</td><td>no</td><td>Style</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-161" id="描述-161">【描述】</a></h3>
<p>在公开（pub）的 unsafe 函数文档中，必须增加 <code># Safety</code> 注释来解释该函数的安全边界，这样使用该函数的用户才可以安全地使用它。</p>
<p>说明： 该规则通过 cargo clippy 来检测。默认会发出警告。</p>
<h3><a class="header" href="#示例-32" id="示例-32">【示例】</a></h3>
<p>【正例】</p>
<p>示例来自于标准库文档： <a href="https://doc.rust-lang.org/stable/src/alloc/vec/mod.rs.html#1167">https://doc.rust-lang.org/stable/src/alloc/vec/mod.rs.html#1167</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Creates a `Vec&lt;T&gt;` directly from the raw components of another vector.
    ///
    /// # Safety
    ///
    /// This is highly unsafe, due to the number of invariants that aren't
    /// checked:
    ///
    /// * `ptr` needs to have been previously allocated via [`String`]/`Vec&lt;T&gt;`
    ///   (at least, it's highly likely to be incorrect if it wasn't).
    /// * `T` needs to have the same size and alignment as what `ptr` was allocated with.
    ///   (`T` having a less strict alignment is not sufficient, the alignment really
    ///   needs to be equal to satisfy the [`dealloc`] requirement that memory must be
    ///   allocated and deallocated with the same layout.)
    /// * `length` needs to be less than or equal to `capacity`.
    /// * `capacity` needs to be the capacity that the pointer was allocated with.
    pub unsafe fn from_raw_parts(ptr: *mut T, length: usize, capacity: usize) -&gt; Self {
        unsafe { Self::from_raw_parts_in(ptr, length, capacity, Global) }
    }
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Creates a `Vec&lt;T&gt;` directly from the raw components of another vector.
    pub unsafe fn from_raw_parts(ptr: *mut T, length: usize, capacity: usize) -&gt; Self {
        unsafe { Self::from_raw_parts_in(ptr, length, capacity, Global) }
    }
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gunssafeabstract02---在-unafe-函数中应该使用-assert-而非-debug_assert-去校验边界条件" id="gunssafeabstract02---在-unafe-函数中应该使用-assert-而非-debug_assert-去校验边界条件">G.UNS.SafeAbstract.02   在 Unafe 函数中应该使用 <code>assert!</code> 而非 <code>debug_assert!</code> 去校验边界条件</a></h2>
<h3><a class="header" href="#级别必须-17" id="级别必须-17">【级别：必须】</a></h3>
<p>必须按此规范执行。</p>
<h3><a class="header" href="#lint-检测-131" id="lint-检测-131">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>默认 level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/index.html#debug_assert_with_mut_call">debug_assert_with_mut_call</a></td><td>yes</td><td>no</td><td>nursery</td><td>allow</td></tr>
</tbody></table>
<p>注意该 lint 当前是 Nursery Group，意味着可能会产生误报 Bug。</p>
<h3><a class="header" href="#描述-162" id="描述-162">【描述】</a></h3>
<p><code>assert!</code> 宏 在 Release 和 Debug 模式下都会被检查，并且不能被禁用。它通常用来在  unsafe 函数中判断传入的参数是否满足某种边界条件，以此来防止不合法的参数传入导致未定义行为。</p>
<p>但是 <code>debug_assert!</code> 则可以通过配置 <code>-C debug-assertions</code> 来禁用它， 而且 <code>debug_assert!</code>    在 Release 模式下也会被编译器优化。所以，一旦使用了 <code>debug_assert!</code> 在 unsafe 函数中用来防范不合法参数，那有可能会失效。</p>
<p>【正例】</p>
<p>来自标准库 <code>slice</code> 的代码示例。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	pub fn split_at_mut(&amp;mut self, mid: usize) -&gt; (&amp;mut [T], &amp;mut [T]) {
        assert!(mid &lt;= self.len()); // 判断边界条件，杜绝非法参数
        // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which
        // fulfills the requirements of `from_raw_parts_mut`.
        unsafe { self.split_at_mut_unchecked(mid) }
    }
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	// 使用了 debug_assert! 那就说明这个校验在 Release 模式不一定有效
    // 那么该函数就要被标记为  unsafe
	pub unsafe fn split_at_mut(&amp;mut self, mid: usize) -&gt; (&amp;mut [T], &amp;mut [T]) {
        debug_assert!(mid &lt;= self.len()); // 注意，这里是 debug_assert!
        // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which
        // fulfills the requirements of `from_raw_parts_mut`.
        unsafe { self.split_at_mut_unchecked(mid) }
    }

   // or
   // 在 debug_assert_eq! 中包含可变引用的调用，
   // 也会因为 debug_assert_ 系列的断言宏在 Release 下产生不可预料的结果，它是 unsafe 的
   debug_assert_eq!(vec![3].pop(), Some(3));
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gunssafeabstract03----unsafe-代码中手动实现-auto-trait-需要注意" id="gunssafeabstract03----unsafe-代码中手动实现-auto-trait-需要注意">G.UNS.SafeAbstract.03    Unsafe 代码中手动实现 auto trait 需要注意</a></h2>
<h3><a class="header" href="#级别必须-18" id="级别必须-18">【级别：必须】</a></h3>
<p>必须严格按此规范执行。</p>
<h3><a class="header" href="#lint-检测-132" id="lint-检测-132">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制参考】</p>
<p>Lint 需要检测 手工实现 auto trait 的行为，比如 <code>Sync/Send</code>，对开发者发出警告，要注意考虑其安全性</p>
<h3><a class="header" href="#描述-163" id="描述-163">【描述】</a></h3>
<p>所谓 auto trait 是指 Safe Rust中由编译器自动实现的 trait，比如 <code>Send/Sync</code> 。在 Unsafe Rust中就需要手动实现这俩 trait 了。</p>
<p>所以，在手动实现的时候要充分考虑其安全性。</p>
<p>【示例】</p>
<p>Rust futures 库中发现的问题，错误的手工 <code>Send/Sync</code>实现 破坏了线程安全保证。</p>
<p>受影响的版本中，<code>MappedMutexGuard</code>的<code>Send/Sync</code>实现只考虑了<code>T</code>上的差异，而<code>MappedMutexGuard</code>则取消了对<code>U</code>的引用。</p>
<p>当<code>MutexGuard::map()</code>中使用的闭包返回与<code>T</code>无关的<code>U</code>时，这可能导致安全Rust代码中的数据竞争。</p>
<p>这个问题通过修正<code>Send/Sync</code>的实现，以及在<code>MappedMutexGuard</code>类型中添加一个<code>PhantomData&lt;&amp;'a mut U&gt;</code>标记来告诉编译器，这个防护也是在U之上。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// CVE-2020-35905: incorrect uses of Send/Sync on Rust's futures
pub struct MappedMutexGuard&lt;'a, T: ?Sized, U: ?Sized&gt; {
    mutex: &amp;'a Mutex&lt;T&gt;,
    value: *mut U,
    _marker: PhantomData&lt;&amp;'a mut U&gt;, // + 修复代码
}

impl&lt;'a, T: ?Sized&gt; MutexGuard&lt;'a, T&gt; {
    pub fn map&lt;U: ?Sized, F&gt;(this: Self, f: F)
        -&gt; MappedMutexGuard&lt;'a, T, U&gt;
        where F: FnOnce(&amp;mut T) -&gt; &amp;mut U {
            let mutex = this.mutex;
            let value = f(unsafe { &amp;mut *this.mutex.value.get() });
                mem::forget(this);
                // MappedMutexGuard { mutex, value }
                MappedMutexGuard { mutex, value, _marker: PhantomData } //  + 修复代码
    }
}

// unsafe impl&lt;T: ?Sized + Send, U: ?Sized&gt; Send
unsafe impl&lt;T: ?Sized + Send, U: ?Sized + Send&gt; Send // + 修复代码
for MappedMutexGuard&lt;'_, T, U&gt; {}
//unsafe impl&lt;T: ?Sized + Sync, U: ?Sized&gt; Sync
unsafe impl&lt;T: ?Sized + Sync, U: ?Sized + Sync&gt; Sync // + 修复代码
for MappedMutexGuard&lt;'_, T, U&gt; {}

// PoC: this safe Rust code allows race on reference counter
* MutexGuard::map(guard, |_| Box::leak(Box::new(Rc::new(true))));
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gunssafeabstract04----不要随便在公开的-api-中暴露裸指针" id="gunssafeabstract04----不要随便在公开的-api-中暴露裸指针">G.UNS.SafeAbstract.04    不要随便在公开的 API 中暴露裸指针</a></h2>
<h3><a class="header" href="#级别必须-19" id="级别必须-19">【级别：必须】</a></h3>
<p>必须严格按此规范执行。</p>
<h3><a class="header" href="#lint-检测-133" id="lint-检测-133">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制参考】</p>
<p>Lint需要检测在 pub 的结构体、枚举等类型中有裸指针字段或变体，对开发者发出警告，要注意考虑其安全性</p>
<h3><a class="header" href="#描述-164" id="描述-164">【描述】</a></h3>
<p>在公开的API中暴露裸指针，可能会被用户修改为空指针，从而有段错误风险。</p>
<p>【示例】</p>
<pre><pre class="playground"><code class="language-rust">use cache;


/**

    `cache crate` 内部代码：

    ```rust
    pub enum Cached&lt;'a, V: 'a&gt; {
        /// Value could not be put on the cache, and is returned in a box
        /// as to be able to implement `StableDeref`
        Spilled(Box&lt;V&gt;),
        /// Value resides in cache and is read-locked.
        Cached {
            /// The readguard from a lock on the heap
            guard: RwLockReadGuard&lt;'a, ()&gt;,
            /// A pointer to a value on the heap
            // 漏洞风险
            ptr: *const ManuallyDrop&lt;V&gt;,
        },
        /// A value that was borrowed from outside the cache.
        Borrowed(&amp;'a V),
    }
**/
fn main() {
    let c = cache::Cache::new(8, 4096);
    c.insert(1, String::from(&quot;test&quot;));
    let mut e = c.get::&lt;String&gt;(&amp;1).unwrap();

    match &amp;mut e {
        cache::Cached::Cached { ptr, .. } =&gt; {
            // 将 ptr 设置为 空指针，导致段错误
            *ptr = std::ptr::null();
        },
        _ =&gt; panic!(),
    }
    // 输出：3851，段错误
    println!(&quot;Entry: {}&quot;, *e);
}
</code></pre></pre>
<h1><a class="header" href="#裸指针操作" id="裸指针操作">裸指针操作</a></h1>
<p>Rust提供了<code>*const T</code>（不变）和<code>*mut T</code>（可变）两种指针类型。因为这两种指针和C语言中的指针十分相近，所以叫其原生指针（Raw Pointer）。</p>
<p>原生指针具有以下特点：</p>
<ul>
<li>并不保证指向合法的内存。比如很可能是一个空指针。</li>
<li>不能像智能指针那样自动清理内存。需要像 C 语言那样手动管理内存。</li>
<li>没有生命周期的概念，也就是说，编译器不会对其提供借用检查。</li>
<li>不能保证线程安全。</li>
</ul>
<p>可见，原生指针并不受Safe Rust提供的那一层“安全外衣”保护，所以也被称为“裸指针”。</p>
<hr />
<h2><a class="header" href="#punsptr01---不要将裸指针在多线程间共享" id="punsptr01---不要将裸指针在多线程间共享">P.UNS.PTR.01   不要将裸指针在多线程间共享</a></h2>
<p><strong>【描述】</strong></p>
<p>裸指针在 Rust 中不是线程安全的，将裸指针在多线程传递编译器也会编译出错。如果需要在多线程间共享裸指针，则考虑使用 <code>NewType</code> 模式来包装它。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyBox(*mut u8);

unsafe impl Send for MyBox {}
unsafe impl Sync for MyBox {}
<span class="boring">}
</span></code></pre></pre>
<hr />
<h2><a class="header" href="#gunsptr01---当指针类型被强转为和当前内存对齐不一致的指针类型时禁止对其解引用" id="gunsptr01---当指针类型被强转为和当前内存对齐不一致的指针类型时禁止对其解引用">G.UNS.PTR.01   当指针类型被强转为和当前内存对齐不一致的指针类型时，禁止对其解引用</a></h2>
<h3><a class="header" href="#级别建议-130" id="级别建议-130">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-134" id="lint-检测-134">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cast_ptr_alignment">cast_ptr_alignment</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-165" id="描述-165">【描述】</a></h3>
<p>该 Lint 会检查是否出现 指针类型被强转为和当前内存对齐不一致的指针类型 的情况，要注意不要对这类强转后的指针进行解引用操作，否则会有未定义行为。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = (&amp;1u8 as *const u8) as *const u8;
    let b = (&amp;mut 1u8 as *mut u8) as *mut u8;

    let c =  (&amp;1u8 as *const u8).cast::&lt;u8&gt;();
   
    // safe
    unsafe { *a }; 
    // safe
    unsafe { *b }; 
    // safe
    unsafe { *c }; 
}
</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = (&amp;1u8 as *const u8) as *const u16;
    let b = (&amp;mut 1u8 as *mut u8) as *mut u16;

    let c =  (&amp;1u8 as *const u8).cast::&lt;u16&gt;();

    // Undefined Behavior: dereferencing pointer failed: alloc1411 has size 1, so pointer to 2 bytes starting at offset 0 is out-of-bounds
    unsafe { *a }; 
    // Undefined Behavior: dereferencing pointer failed: alloc1411 has size 1, so pointer to 2 bytes starting at offset 0 is out-of-bounds
    unsafe { *b }; 
    // Undefined Behavior: dereferencing pointer failed: alloc1411 has size 1, so pointer to 2 bytes starting at offset 0 is out-of-bounds
    unsafe { *c }; 
}

</code></pre></pre>
<h2><a class="header" href="#gunsptr02---禁止将不可变指针手工转换为可变指针" id="gunsptr02---禁止将不可变指针手工转换为可变指针">G.UNS.PTR.02   禁止将不可变指针手工转换为可变指针</a></h2>
<h3><a class="header" href="#级别建议-131" id="级别建议-131">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-135" id="lint-检测-135">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cast_ref_to_mut">cast_ref_to_mut</a></td><td>yes</td><td>no</td><td><strong>correctness</strong></td><td>deny</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-166" id="描述-166">【描述】</a></h3>
<p>因为将不可变指针手工转换为可变指针可能会引发未定义行为。通常有这种需求，合法的手段是使用 <code>UnsafeCell&lt;T&gt;</code>。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::UnsafeCell;

fn x(r: &amp;UnsafeCell&lt;i32&gt;) {
   unsafe {
       *r.get() += 1;
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>【 反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn x(r: &amp;i32) {
    unsafe {
        *(r as *const _ as *mut _) += 1;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>【例外】</p>
<p>也有例外情况，当明确知道这种转换会出现什么风险的时候，可以使用，或者在找到合适的解决办法之前 作为一种临时方案，但要加上注释。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// https://docs.rs/crate/solana-runtime/1.7.11/source/src/append_vec.rs
#[allow(clippy::cast_ref_to_mut)]
fn set_data_len_unsafe(&amp;self, new_data_len: u64) {
    // UNSAFE: cast away &amp; (= const ref) to &amp;mut to force to mutate append-only (=read-only) AppendVec
    unsafe {
        *(&amp;self.meta.data_len as *const u64 as *mut u64) = new_data_len;
    }
}

// https://docs.rs/crate/mmtk/0.6.0/source/src/policy/space.rs
// This is a temporary solution to allow unsafe mut reference. We do not want several occurrence
// of the same unsafe code.
// FIXME: We need a safe implementation.
#[allow(clippy::cast_ref_to_mut)]
#[allow(clippy::mut_from_ref)]
unsafe fn mut_self(&amp;self) -&gt; &amp;mut Self {
    &amp;mut *(self as *const _ as *mut _)
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gunsptr03---尽量使用-pointercast-来代替-使用-as-强转指针" id="gunsptr03---尽量使用-pointercast-来代替-使用-as-强转指针">G.UNS.PTR.03   尽量使用 <code>pointer::cast</code> 来代替 使用 <code>as</code> 强转指针</a></h2>
<h3><a class="header" href="#级别建议-132" id="级别建议-132">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-136" id="lint-检测-136">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#ptr_as_ptr">ptr_as_ptr</a></td><td>yes</td><td>no</td><td><strong>correctness</strong></td><td>deny</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-167" id="描述-167">【描述】</a></h3>
<p>使用 <code>pointer::cast</code> 方法转换更加安全，它不会意外地改变指针的可变性，也不会将指针转换为其他类型。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ptr: *const u32 = &amp;42_u32;
let mut_ptr: *mut u32 = &amp;mut 42_u32;
let _ = ptr.cast::&lt;i32&gt;();
let _ = mut_ptr.cast::&lt;i32&gt;();
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ptr: *const u32 = &amp;42_u32;
let mut_ptr: *mut u32 = &amp;mut 42_u32;
let _ = ptr as *const i32;
let _ = mut_ptr as *mut i32;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gunsptr04---建议使用-nonnullt-来替代-mut-t" id="gunsptr04---建议使用-nonnullt-来替代-mut-t">G.UNS.PTR.04   建议使用 <code>NonNull&lt;T&gt;</code> 来替代 <code>*mut T</code></a></h2>
<h3><a class="header" href="#级别必须-20" id="级别必须-20">【级别：必须】</a></h3>
<p>必须严格按此规范执行。</p>
<h3><a class="header" href="#lint-检测-137" id="lint-检测-137">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制参考】</p>
<p>检测到包含 <code>*mut T</code>类型的结构体，应该给予开发者警告或建议去使用 <code>NonNull</code> 。</p>
<h3><a class="header" href="#描述-168" id="描述-168">【描述】</a></h3>
<p>尽量使用 <a href="https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html"><code>NonNull</code></a> 来包装 <code>*mut T</code>。</p>
<p><code>NonNull</code> 的优势：</p>
<ol>
<li>非空指针。会自动检查包装的指针是否为空。</li>
<li>协变。方便安全抽象。如果用裸指针，则需要配合 <code>PhantomData</code>类型来保证协变。</li>
</ol>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ptr::NonNull;

let mut x = 0u32;
let ptr = NonNull::&lt;u32&gt;::new(&amp;mut x as *mut _).expect(&quot;ptr is null!&quot;);

if let Some(ptr) = NonNull::&lt;u32&gt;::new(std::ptr::null_mut()) {
    unreachable!();
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gunsptr05---使用指针类型构造泛型结构体时需要使用-phantomdatat-来指定-t上的协变和所有权" id="gunsptr05---使用指针类型构造泛型结构体时需要使用-phantomdatat-来指定-t上的协变和所有权">G.UNS.PTR.05   使用指针类型构造泛型结构体时，需要使用 <code>PhantomData&lt;T&gt;</code> 来指定 <code>T</code>上的协变和所有权</a></h2>
<h3><a class="header" href="#级别必须-21" id="级别必须-21">【级别：必须】</a></h3>
<p>必须严格按此规范执行。</p>
<h3><a class="header" href="#lint-检测-138" id="lint-检测-138">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制参考】</p>
<p>检测使用指针类型构造泛型结构体时，如果没有 <code>PhantomData&lt;T&gt;</code> 类型的字段，则需要警告开发者，要考虑 为裸指针配合<code>PhantomData&lt;T&gt;</code>来指定协变和所有权</p>
<h3><a class="header" href="#描述-169" id="描述-169">【描述】</a></h3>
<p><code>PhantomData&lt;T&gt;</code> 是经常被用于 Unsafe Rust 中配合裸指针来指定协变和所有权的，为裸指针构建的类型保证安全性和有效性。否则，可能会产生未定义行为。</p>
<p>参考： <a href="https://doc.rust-lang.org/nomicon/phantom-data.html"><code>PhantomData&lt;T&gt;</code>  的型变（variance）模式表</a> </p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker;

struct Vec&lt;T&gt; {
    data: *const T, // *const for variance!
    len: usize,
    cap: usize,
    _marker: marker::PhantomData&lt;T&gt;, // 让 Vec&lt;T&gt; 拥有 T，并且让 指针有了协变
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Vec&lt;T&gt; 不拥有类型 T，并且 data 字段的裸指针不支持协变
// 这样的话，是有风险的。
// 为 Vec&lt;T&gt; 实现的 Drop 可能导致 UB
struct Vec&lt;T&gt; {
    data: *const T, 
    len: usize,
    cap: usize,
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#联合体union" id="联合体union">联合体（Union）</a></h1>
<p>Union 是没有 tag 的 Enum，Enum 是有 tag 的Union 。</p>
<p>内存布局 Union 和 Enum 相似。</p>
<p>正因为没有 tag，Rust 编译器无法检查当前使用的正是哪个变体，所以，访问 Union 的变体是 Unsafe 的。</p>
<hr />
<h2><a class="header" href="#gunsunion01--除了与-c-打交道尽量不要使用-union" id="gunsunion01--除了与-c-打交道尽量不要使用-union">G.UNS.Union.01  除了与 C 打交道，尽量不要使用 Union</a></h2>
<h3><a class="header" href="#级别必须-22" id="级别必须-22">【级别：必须】</a></h3>
<p>必须严格按此规范执行。</p>
<h3><a class="header" href="#lint-检测-139" id="lint-检测-139">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制化参考】</p>
<p>这条规则如果需要定制 Lint，则可以检测 Union 联合体上方是否有 <code>#[repr(C)]</code>属性定义与C兼容的数据布局，如果没有则给予警告。</p>
<h3><a class="header" href="#描述-170" id="描述-170">【描述】</a></h3>
<p>Rust 支持 Union 就是为了和 C 打交道。如果不是 FFi ，就避免使用 Union。</p>
<p>一般情况下请使用 枚举 或 结构体代替。</p>
<p>使用 Copy 类型的值和 <code>ManuallyDrop</code> 来初始化 Union 的变体，不需要使用 Unsafe 块。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
union MyUnion {
    f1: u32,
    f2: f32,
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>union MyUnion {
    f1: u32,
    f2: f32,
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gunsunion02---不要把联合体的不同变体用在不同生命周期内" id="gunsunion02---不要把联合体的不同变体用在不同生命周期内">G.UNS.Union.02   不要把联合体的不同变体用在不同生命周期内</a></h2>
<h3><a class="header" href="#级别必须-23" id="级别必须-23">【级别：必须】</a></h3>
<p>必须严格按此规范执行。</p>
<h3><a class="header" href="#lint-检测-140" id="lint-检测-140">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制化参考】</p>
<p>检测函数内同一个联合体实例的不同变体被用于不同的生命周期内。</p>
<h3><a class="header" href="#描述-171" id="描述-171">【描述】</a></h3>
<p>对联合体的变体进行借用的时候，要注意其他变体也将在同一个生命周期内。抛开内存布局、安全性和所有权之外，联合体的行为和结构体完全一致，你可以将联合体当中结构体来进行判断。</p>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ERROR: cannot borrow `u` (via `u.f2`) as mutable more than once at a time
fn test() {
    let mut u = MyUnion { f1: 1 };
    unsafe {
        let b1 = &amp;mut u.f1;
//                    ---- first mutable borrow occurs here (via `u.f1`)
        let b2 = &amp;mut u.f2;
//                    ^^^^ second mutable borrow occurs here (via `u.f2`)
        *b1 = 5;
    }
//  - first borrow ends here
    assert_eq!(unsafe { u.f1 }, 5);
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#内存-1" id="内存-1">内存</a></h1>
<p>这里指 Unsafe Rust 下的数据布局、内存管理和使用相关规范。</p>
<hr />
<h2><a class="header" href="#punsmem01---要注意选择合适的结构体元组枚举的数据布局" id="punsmem01---要注意选择合适的结构体元组枚举的数据布局">P.UNS.MEM.01   要注意选择合适的结构体、元组、枚举的数据布局</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 中结构体和元组 ，编译器会随意重排其字段来优化布局。请根据具体的场景来选择合适的数据布局。</p>
<p>可以通过 以下<code>#[repr]</code> 属性来控制结构体和元组的数据布局：</p>
<ul>
<li><code>#[repr(Rust)]</code> ，默认 Rust 数据布局</li>
<li><code>#[repr(C)]</code> ，与 C 兼容的布局</li>
<li><code>#[repr(align(N))]</code> ，指定对齐方式</li>
<li><code>#[repr(packed)]</code> ，指定字段将不在内部对齐</li>
<li><code>#[repr(transparent)]</code> ，让包含单个字段的结构体布局和其字段相同</li>
</ul>
<p>可以通过 以下<code>#[repr]</code> 属性来控制枚举体的数据布局：</p>
<ul>
<li>特定整数类型
<ul>
<li><code>#[repr(u8)]</code></li>
<li><code>#[repr(u16)]</code></li>
<li><code>#[repr(u32)]</code></li>
<li><code>#[repr(u64)]</code></li>
<li><code>#[repr(i8)]</code></li>
<li><code>#[repr(i16)]</code></li>
<li><code>#[repr(i32)]</code></li>
<li><code>#[repr(i64)]</code></li>
</ul>
</li>
<li>C 兼容布局
<ul>
<li><code>#[repr(C)]</code></li>
</ul>
</li>
<li>指定判别式大小的 C 兼容布局
<ul>
<li><code>#[repr(C, u8)]</code></li>
<li><code>#[repr(C, u16)]</code></li>
<li>以此类推</li>
</ul>
</li>
</ul>
<p>枚举需要注意的地方：</p>
<ul>
<li>枚举不允许通过<code>#[repr(align)] </code> 手动指定对齐方式。</li>
<li>空枚举不能使用 <code>repr</code> 属性</li>
<li>无字段枚举不允许指定判别式大小的 C 兼容布局，比如 <code>[repr(C, Int)]</code></li>
<li>数据承载（有字段）枚举则允许所有类型的 <code>repr</code>属性</li>
</ul>
<hr />
<h2><a class="header" href="#gunsmem01---使用-maybeuninitt-来处理未初始化的内存" id="gunsmem01---使用-maybeuninitt-来处理未初始化的内存">G.UNS.MEM.01   使用 <code>MaybeUninit&lt;T&gt;</code> 来处理未初始化的内存</a></h2>
<h3><a class="header" href="#级别建议-133" id="级别建议-133">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-141" id="lint-检测-141">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#uninit_assumed_init">uninit_assumed_init</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#uninit_vec">uninit_vec</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-172" id="描述-172">【描述】</a></h3>
<p>Rust 编译器要求变量要根据其类型正确初始化。</p>
<p>比如引用类型的变量必须对齐且非空。这是一个必须始终坚持的不变量，即使在 Unsafe 代码中也是如此。因此，零初始化引用类型的变量会导致立即未定义行为，无论该引用是否访问过内存。</p>
<p>编译器利用这一点，进行各种优化，并且可以省略运行时检查。</p>
<p>使用前请仔细查看 <code>MaybeUninit&lt;T&gt;</code> 相关文档。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem::MaybeUninit;

let mut x = MaybeUninit::&lt;bool&gt;::uninit();
x.write(true); // 这里正确进行了初始化
let x_init = unsafe { x.assume_init() }; // 通过 assume_init 对 MaybeUninit 的内存取值
assert_eq!(x_init, true);

// 下面数组应该是可以的
let _: [MaybeUninit&lt;bool&gt;; 5] = unsafe {
    MaybeUninit::uninit().assume_init()
};

// Vec 未初始化内存正确处理
let mut vec: Vec&lt;u8&gt; = vec![0; 1000];
reader.read(&amp;mut vec);
// or
let mut vec: Vec&lt;MaybeUninit&lt;T&gt;&gt; = Vec::with_capacity(1000);
vec.set_len(1000);  // `MaybeUninit` can be uninitialized
// or
let mut vec: Vec&lt;u8&gt; = Vec::with_capacity(1000);
let remaining = vec.spare_capacity_mut();  // `&amp;mut [MaybeUninit&lt;u8&gt;]`
// perform initialization with `remaining`
vec.set_len(...);  // Safe to call `set_len()` on initialized part
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<p>由调用者来保证<code>MaybeUninit&lt;T&gt;</code>确实处于初始化状态。当内存尚未完全初始化时调用 <code>assume_init()</code> 会导致立即未定义的行为。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem::{self, MaybeUninit};
// 零初始化引用
let x: &amp;i32 = unsafe { mem::zeroed() }; // undefined behavior! ⚠️
// The equivalent code with `MaybeUninit&lt;&amp;i32&gt;`:
let x: &amp;i32 = unsafe { MaybeUninit::zeroed().assume_init() }; // undefined behavior! 
// 布尔值必须初始化
let b: bool = unsafe { mem::uninitialized() }; // undefined behavior! ⚠️
// The equivalent code with `MaybeUninit&lt;bool&gt;`:
let b: bool = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior! 
// 整数类型也必须初始化
let x: i32 = unsafe { mem::uninitialized() }; // undefined behavior! ⚠️
// The equivalent code with `MaybeUninit&lt;i32&gt;`:
let x: i32 = unsafe { MaybeUninit::uninit().assume_init() }; 

// Vec未初始化内存使用 set_len 是未定义行为
let mut vec: Vec&lt;u8&gt; = Vec::with_capacity(1000);
unsafe { vec.set_len(1000); }
reader.read(&amp;mut vec); // undefined behavior!
<span class="boring">}
</span></code></pre></pre>
<p>【例外】</p>
<p>在能保证<code> MaybeUninit</code> 不需要初始化的情况下使用 <code>assume_init</code> 是安全的。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe trait Array: Sized {
  
    /// Same array but item is wrapped with
    /// [`MaybeUninit&lt;_&gt;`](core::mem::MaybeUninit).
    /// ```
    /// # use arraylib::Array; fn dummy&lt;T&gt;() where
    /// [T; 4]: Array&lt;Item = T, Maybe = [core::mem::MaybeUninit&lt;T&gt;; 4]&gt;
    /// # {}
    /// ```
    type Maybe: Array&lt;Item = MaybeUninit&lt;Self::Item&gt;&gt;;

    /// [`MaybeUninit&lt;T&gt;`]: core::mem::MaybeUninit
    #[inline]
    // Initializing generic type with uninitialized state seems insane, but is
    // unsafe trait and `Array` guarantees that it's an array. And `Array::Maybe`
    // is an array of `MaybeUninit` that doesn't require initialization, so
    // everything is ok
    // 这里是一个数组，可以保证不需要去初始化
    #[allow(clippy::uninit_assumed_init)]
    fn uninit() -&gt; Self::Maybe {
        unsafe {
            // ## Safety
            //
            // Completely safe as `MaybeUninit` don't require initialization
            MaybeUninit::uninit().assume_init()
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#punsmem02-不能修改其它进程动态库的存变量" id="punsmem02-不能修改其它进程动态库的存变量">P.UNS.MEM.02 不能修改其它进程/动态库的存变量</a></h2>
<h3><a class="header" href="#级别必须-24" id="级别必须-24">【级别：必须】</a></h3>
<p>必须按此规范执行。</p>
<h3><a class="header" href="#描述-173" id="描述-173">【描述】</a></h3>
<p>不要尝试修改其它进程/动态库的内存数据，否则会出现内存段错误(SIGSEGV)。</p>
<p>【反例】</p>
<p><code>sqlite3_libversion()</code> 返回的 sqlite 版本信息指针指向 <code>/usr/lib/libsqlite3.so</code> 动态库的 static 字符串。</p>
<p>libsqlite3.so 中分配的静态字符串不属于进程的内存范围中。</p>
<p>当进程尝试修改 sqlite 动态库的静态字符串内容，操作系统就会发送 SIGSEGV 信号终止进程，以保证 sqlite 动态库的内存数据安全。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;sqlite3&quot;)]
extern &quot;C&quot; {
    fn sqlite3_libversion() -&gt; *mut std::os::raw::c_char;
}

fn edit_sqlite_version() {
    unsafe {
        let mut sqlite_version = sqlite3_libversion();
        // SIGSEGV: invalid memory reference
        *sqlite_version = 3;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#punsmem03-不能让-stringvec-自动-drop-其它进程动态库的内存数据" id="punsmem03-不能让-stringvec-自动-drop-其它进程动态库的内存数据">P.UNS.MEM.03 不能让 String/Vec 自动 Drop 其它进程/动态库的内存数据</a></h2>
<h3><a class="header" href="#级别必须-25" id="级别必须-25">【级别：必须】</a></h3>
<p>必须按此规范执行。</p>
<h3><a class="header" href="#描述-174" id="描述-174">【描述】</a></h3>
<p>使用 String/Vec 指向其它进程/动态库的内存数据时，一定要手动禁止 String/Vec 的 Drop 方法(析构函数)的调用，避免 free 其它进程/动态库的内存数据。</p>
<p>【反例】</p>
<p><code>sqlite3_libversion()</code> 返回的 sqlite 版本信息指针指向 <code>/usr/lib/libsqlite3.so</code> 动态库的 static 字符串。</p>
<p>当进程在 String drop 的时候尝试释放 sqlite 动态库的静态字符串内存时，操作系统就会发送 SIGABRT 信号终止进程，以保证 sqlite 动态库的内存数据安全。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;sqlite3&quot;)]
extern &quot;C&quot; {
    fn sqlite3_libversion() -&gt; *mut std::os::raw::c_char;
}

fn print_sqlite_version() {
    unsafe {
        let ptr = sqlite3_libversion();
        let len = libc::strlen(ptr);
        let version = String::from_raw_parts(ptr.cast(), len, len);
        println!(&quot;found sqlite3 version={}&quot;, version);
        // SIGABRT: invalid free
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>【正例】</p>
<p>除了用 mem::forget 或者 ManualDrop 禁止 String drop 其它动态库的内存，也可以用标准库 ptr/slice 的 copy 或者 <code>libc::strdup</code> 将 sqlite 的版本信息字符串<strong>复制到当前进程的内存空间</strong>再进行操作</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_sqlite_version() {
    unsafe {
        let ptr = sqlite3_libversion();
        let len = libc::strlen(ptr);
        let version = String::from_raw_parts(ptr.cast(), len, len);
        println!(&quot;found sqlite3 version={}&quot;, version);
        // 手动禁止 String 的析构函数调用
        std::mem::forget(version);
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#punsmem04-尽量用可重入reentrant版本的-c-api系统调用" id="punsmem04-尽量用可重入reentrant版本的-c-api系统调用">P.UNS.MEM.04 尽量用可重入(reentrant)版本的 C API/系统调用</a></h2>
<h3><a class="header" href="#级别必须-26" id="级别必须-26">【级别：必须】</a></h3>
<p>必须按此规范执行。</p>
<h3><a class="header" href="#描述-175" id="描述-175">【描述】</a></h3>
<p>以 Linux 系统为例，在 <strong>glibc</strong>(/usr/lib/libc.so) 等知名 C 语言库中，</p>
<p>很多 API 会既提供不可重入版本和**可重入(reentrant)**版本，例如 ctime 和 ctime_r 这对系统调用。</p>
<p>可重入版本的函数命名一般带 <strong>_r</strong> 的后缀，<em>_r</em> 也就是单词可重入 reentrant 的缩写。</p>
<p>libc 中不可重入函数的执行过程一般是将函数的输出写到动态库的某个 static 命令内，然后再返回指向该 static 变量的指针返回给调用方，因此是一种「有状态」的函数，多线程环境下可能有<strong>线程安全问题</strong>。</p>
<p>例如线程 A 正在将 glibc 动态库的 gmtime 数据逐个复制回来，结果复制到一半线程 B 调用 gmtime 把后半部分的 gmtime 输出数据给更新掉了导致线程 A 得到的数据有误。</p>
<p>而无重入版本例如 libc::localtime_r 会比 libc::localtime 多一个入参叫 result，</p>
<p>允许调用方进程的内存空间内分配内存，再将调用方进程的可变指针传入到 glibc 中让 glibc 修改可知指针指向的数据。</p>
<p>应当通过工具搜索动态库的函数符号查找可重入版本的函数，或者通过 man 文档查询自己所用函数有没有可重入的版本。</p>
<pre><code>[w@ww repos]$ nm -D /usr/lib/libc.so.6 | grep &quot;_r@&quot;
00000000000bb030 W asctime_r@@GLIBC_2.2.5
00000000000bb100 T ctime_r@@GLIBC_2.2.5
0000000000040a30 T drand48_r@@GLIBC_2.2.5
</code></pre>
<p>使用不可重入函数的危害例如 P.UNS.MEM.02 和 P.UNS.MEM.03 规范的反例中的 sqlite3_libversion() 会导致开发人员带来很大的心智负担，需要人工 code review 确保没有线程安全和内存安全问题，因此必须尽量使用可重入版本的函数。</p>
<p>【正例】</p>
<p>chrono 库中用 libc::localtime_r 获取本地时间而不用 libc::localtime</p>
<p>ctime_r, gmtime_r, localtime_r, gethostbyname_r</p>
<p>【反例】</p>
<p>ctime, gmtime, localtime, gethostbyname</p>
<h1><a class="header" href="#ffi-规范" id="ffi-规范">FFi 规范</a></h1>
<p>Rust 可以通过C-ABI无缝与C语言打交道，也可以通过暴露 C-ABI 接口供其他语言调用。但是跨边界本质上是不安全的。</p>
<p>一般来说，FFi 是指在其他语言中调用 Rust 代码，Rust代码会按 C-ABI 来暴露接口。这类 Rust crate或模块，常以 <code>-ffi</code>后缀结尾。</p>
<p>另一类是 Rust 去调用 C-ABI 接口，相关代码通常被封装到以 <code>-sys</code> 为后缀命名的 crate 或 模块中。 </p>
<p>本小节内容，包含以上两种情况。</p>
<hr />
<h2><a class="header" href="#punsffi01----避免从公开的-rust-api--直接传字符串到-c--中" id="punsffi01----避免从公开的-rust-api--直接传字符串到-c--中">P.UNS.FFi.01    避免从公开的 Rust API  直接传字符串到 C  中</a></h2>
<p><strong>【描述】</strong></p>
<p>在跨越 C 边界的时候，应该对 字符串进行边界检查，避免传入一些非法字符串。</p>
<p>【示例】</p>
<p>这个示例中，从公开的 Rust API 传入非法字符串到 C ，导致字符串格式化漏洞。</p>
<pre><pre class="playground"><code class="language-rust">// From: https://github.com/RustSec/advisory-db/issues/106

extern crate pancurses;

use pancurses::{initscr, endwin};

fn main() {
    let crash = &quot;!~&amp;@%+ S&quot;; //  特意构造非法字符串

    let window = initscr();
    window.printw(crash); // 通过该函数跨 C边界传入非法字符串，引起字符串格式化漏洞
    window.refresh();
    window.getch();
    endwin();
}
</code></pre></pre>
<h2><a class="header" href="#punsffi02----在使用标准库-stdffi模块提供的类型时需要仔细查看其文档" id="punsffi02----在使用标准库-stdffi模块提供的类型时需要仔细查看其文档">P.UNS.FFi.02    在使用标准库 <code>std::ffi</code>模块提供的类型时需要仔细查看其文档</a></h2>
<p><strong>【描述】</strong></p>
<p>因为该模块中提供了用于和其他语言类 C 字符串打交道的 FFi 绑定和类型，在使用前务必要看清楚它们的文档，否则会因为所有权管理不当而导致无效内存访问、内存泄漏和其他内存错误。</p>
<h2><a class="header" href="#punsffi03----当使用-来自-c-的指针时如果该指针需要管理内存则需要为包装该指针的-rust-类型实现-drop-trait" id="punsffi03----当使用-来自-c-的指针时如果该指针需要管理内存则需要为包装该指针的-rust-类型实现-drop-trait">P.UNS.FFi.03    当使用 来自 C 的指针时，如果该指针需要管理内存，则需要为包装该指针的 Rust 类型实现 Drop trait</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 里通过结构体包装该指针，并且为该结构体实现 Drop 来保证相关资源可以安全释放。</p>
<h2><a class="header" href="#punsffi04----如果一个函数正在跨越-ffi-边界那么需要处理恐慌" id="punsffi04----如果一个函数正在跨越-ffi-边界那么需要处理恐慌">P.UNS.FFi.04    如果一个函数正在跨越 FFi 边界，那么需要处理恐慌</a></h2>
<p><strong>【描述】</strong></p>
<p>如果让恐慌在跨越 FFi 边界时发生，可能会产生未定义行为。</p>
<p>处理恐慌可以使用 <code>catch_unwind</code>，但是它只对实现了 <code>UnwindSafe</code> trait 的类型起作用。另外一种方法就是避免恐慌，而返回错误码。</p>
<p>【示例】</p>
<pre><pre class="playground"><code class="language-rust">use std::panic::catch_unwind;

#[no_mangle]
pub extern fn oh_no() -&gt; i32 {
    let result = catch_unwind(|| {
        panic!(&quot;Oops!&quot;); // 这里会发生恐慌，需要处理
    });
    match result {
        Ok(_) =&gt; 0,
        Err(_) =&gt; 1,
    }
}

fn main() {}
</code></pre></pre>
<h2><a class="header" href="#punsffi05----建议使用诸如标准库或-libc-crate所提供的可移植类型别名而不是特定平台的类型" id="punsffi05----建议使用诸如标准库或-libc-crate所提供的可移植类型别名而不是特定平台的类型">P.UNS.FFi.05    建议使用诸如标准库或 <code>libc</code> crate所提供的可移植类型别名，而不是特定平台的类型</a></h2>
<p><strong>【描述】</strong></p>
<p>当与外部(如C或c++)接口交互时，通常需要使用平台相关的类型，如C的<code>int</code>、<code>long</code>等。除了<code>std::ffi</code>(或<code>core::ffi</code>)中的c void外，标准库还在<code>std:os::raw</code>(或<code>core::os::raw</code>)中提供了可移植类型别名。<code>libc</code> crate 基本覆盖了所有的C标准库中的C兼容类型。</p>
<p>这样有助于编写跨平台的代码。</p>
<h2><a class="header" href="#punsffi06-rust-和-c-之间传递字符或字符串时需要注意字符串要符合-c-abi-以及-字符串的编码" id="punsffi06-rust-和-c-之间传递字符或字符串时需要注意字符串要符合-c-abi-以及-字符串的编码">P.UNS.FFi.06 Rust 和 C 之间传递字符或字符串时需要注意字符串要符合 C-ABI 以及 字符串的编码</a></h2>
<p><strong>【描述】</strong></p>
<p>注意要使用 <code>c_char</code> 对应 C 语言的字符。<code>libc::c_char</code> 和 <code>std::os::raw::c_char</code> 在大多数 64位 linux 上都是相同的。</p>
<p>FFi 接口使用的字符串要符合 C 语言约定，即使用 <code>\0</code> 结尾且中间不要包含 <code>\0</code>字符的字符串。</p>
<p>Rust 中字符串要求 <code>utf-8 </code>编码，而 C 字符串则没有这个要求。所以需要注意编码。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f = libc::fopen(&quot;/proc/uptime\0&quot;.as_ptr().cast(), &quot;r\0&quot;.as_ptr().cast());
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f = libc::fopen(&quot;/proc/uptime&quot;.as_ptr().cast(), &quot;r&quot;.as_ptr().cast());
// 即使 /proc/uptime 文件存在，fopen 系统调用也会返回 NULL
// 并且将错误码 errno 标记为 2 (&quot;No such file or directory&quot;)
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#punsffi07---不要为任何传入到外部的类型实现-drop" id="punsffi07---不要为任何传入到外部的类型实现-drop">P.UNS.FFi.07   不要为任何传入到外部的类型实现 Drop</a></h2>
<p><strong>【描述】</strong></p>
<p>因为有可能在传出去之前被析构。需要明确是由哪种语言负责分配和释放内存，谁分配内存，谁来释放。</p>
<h2><a class="header" href="#punsffi08----ffi-中要进行合理的错误处理" id="punsffi08----ffi-中要进行合理的错误处理">P.UNS.FFi.08    FFi 中要进行合理的错误处理</a></h2>
<p><strong>【描述】</strong></p>
<p>不同类型的错误代码，需要不同的处理方式：</p>
<ol>
<li>无字段枚举，应该转换为数字并且作为返回码。</li>
<li>数据承载（有字段）枚举，应该转换为携带错误信息的整数码。</li>
<li>自定义错误类型应该使用 兼容 C 的布局</li>
</ol>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 无字段枚举
enum DatabaseError {
    IsReadOnly = 1, // user attempted a write operation
    IOError = 2, // user should read the C errno() for what it was
    FileCorrupted = 3, // user should run a repair tool to recover it
}

impl From&lt;DatabaseError&gt; for libc::c_int {
    fn from(e: DatabaseError) -&gt; libc::c_int {
        (e as i8).into()
    }
}

// 数据承载（有字段）枚举
pub mod errors {
    enum DatabaseError {
        IsReadOnly,
        IOError(std::io::Error),
        FileCorrupted(String), // message describing the issue
    }

    impl From&lt;DatabaseError&gt; for libc::c_int {
        fn from(e: DatabaseError) -&gt; libc::c_int {
            match e {
                DatabaseError::IsReadOnly =&gt; 1,
                DatabaseError::IOError(_) =&gt; 2,
                DatabaseError::FileCorrupted(_) =&gt; 3,
            }
        }
    }
}

pub mod c_api {
    use super::errors::DatabaseError;

    #[no_mangle]
    pub extern &quot;C&quot; fn db_error_description(
        e: *const DatabaseError
        ) -&gt; *mut libc::c_char {

        let error: &amp;DatabaseError = unsafe {
            // SAFETY: pointer lifetime is greater than the current stack frame
            &amp;*e
        };

        let error_str: String = match error {
            DatabaseError::IsReadOnly =&gt; {
                format!(&quot;cannot write to read-only database&quot;);
            }
            DatabaseError::IOError(e) =&gt; {
                format!(&quot;I/O Error: {}&quot;, e);
            }
            DatabaseError::FileCorrupted(s) =&gt; {
                format!(&quot;File corrupted, run repair: {}&quot;, &amp;s);
            }
        };

        let c_error = unsafe {
            // SAFETY: copying error_str to an allocated buffer with a NUL
            // character at the end
            let mut malloc: *mut u8 = libc::malloc(error_str.len() + 1) as *mut _;

            if malloc.is_null() {
                return std::ptr::null_mut();
            }

            let src = error_str.as_bytes().as_ptr();

            std::ptr::copy_nonoverlapping(src, malloc, error_str.len());

            std::ptr::write(malloc.add(error_str.len()), 0);

            malloc as *mut libc::c_char
        };

        c_error
    }
}

// 自定义错误类型
struct ParseError {
    expected: char,
    line: u32,
    ch: u16
}

impl ParseError { /* ... */ }

/* Create a second version which is exposed as a C structure */
#[repr(C)]
pub struct parse_error {
    pub expected: libc::c_char,
    pub line: u32,
    pub ch: u16
}

impl From&lt;ParseError&gt; for parse_error {
    fn from(e: ParseError) -&gt; parse_error {
        let ParseError { expected, line, ch } = e;
        parse_error { expected, line, ch }
    }
}
<span class="boring">}
</span></code></pre></pre>
<hr />
<h2><a class="header" href="#gunsffi01---自定义数据类型要保证一致的数据布局" id="gunsffi01---自定义数据类型要保证一致的数据布局">G.UNS.FFi.01   自定义数据类型要保证一致的数据布局</a></h2>
<h3><a class="header" href="#级别必须-27" id="级别必须-27">【级别：必须】</a></h3>
<p>必须严格按此规范执行。</p>
<h3><a class="header" href="#lint-检测-142" id="lint-检测-142">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制化参考】</p>
<p>检测 <code>-sys</code> 或 <code>-ffi</code> 后缀的crate 或 模块内的自定义结构体、enum、union有没有指定 <code>repr</code> 布局</p>
<h3><a class="header" href="#描述-176" id="描述-176">【描述】</a></h3>
<p>Rust 编译器为了优化内存布局，会对结构体字段进行重排。所以在 FFi 边界，应该注意结构体内存布局和 C 的一致。</p>
<p>关于 如何选择合适的<code>repr</code> 属性可参考：<a href="safe-guides/coding_practice/unsafe_rust/./mem.html">P.UNS.MEM.01</a> </p>
<p>以下是不合适用于和 C 语言交互的类型：</p>
<ol>
<li>没有使用任何 <code>#[repr( )]</code> 属性修饰的自定义类型</li>
<li>动态大小类型 (dynamic sized type)</li>
<li>指向动态大小类型对象的指针或引用 (fat pointers)</li>
<li>str 类型、tuple 元组、闭包类型</li>
</ol>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
struct Data {
    a: u32,
    b: u16,
    c: u64,
}
#[repr(C, packed)]
struct PackedData {
    a: u32,
    b: u16,
    c: u64,
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gunsffi02----不要在-ffi-中使用-任何零大小类型" id="gunsffi02----不要在-ffi-中使用-任何零大小类型">G.UNS.FFi.02    不要在 FFi 中使用 任何零大小类型</a></h2>
<h3><a class="header" href="#级别必须-28" id="级别必须-28">【级别：必须】</a></h3>
<p>必须严格按此规范执行。</p>
<h3><a class="header" href="#lint-检测-143" id="lint-检测-143">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制参考】</p>
<p>Lint 可检测 <code>-sys</code>或<code>-ffi</code> 后缀的 crate 或 模块内有使用零大小类型，对其产生警告</p>
<p><strong>【描述】</strong></p>
<p>零大小类型在 C 中是无效的。也不要把 Rust 中的单元类型 <code>()</code> 和 C 中的 <code>void</code> 混为一谈。</p>
<h2><a class="header" href="#gunsffi03---从外部传入的不健壮类型的外部值要进行检查" id="gunsffi03---从外部传入的不健壮类型的外部值要进行检查">G.UNS.FFi.03   从外部传入的不健壮类型的外部值要进行检查</a></h2>
<h3><a class="header" href="#级别必须-29" id="级别必须-29">【级别：必须】</a></h3>
<p>必须严格按此规范执行。</p>
<h3><a class="header" href="#lint-检测-144" id="lint-检测-144">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制参考】</p>
<p>lint 可检测 <code>extern fn </code> 函数参数类型，如果是 布尔类型、引用类型、函数指针、枚举、浮点数、或包含前面类型的复合类型，则需要警告开发者注意对这些类型的健壮性检查。</p>
<p><strong>【描述】</strong></p>
<p>Safe Rust 会保证类型的有效性和安全性，但是 Unsafe Rust 中，特别是编写 FFi 的时候，很容易从外部传入无效值。</p>
<p>Rust 中很多类型都不太健壮：</p>
<ul>
<li>布尔类型。外部传入的 布尔类型可能是数字也可能是字符串。</li>
<li>引用类型。Rust 中的引用仅允许执行有效的内存对象，但是在Unsafe 中使用引用，任何偏差都可能引起未定义行为。</li>
<li>函数指针。跨越 FFi 边界的函数指针可能导致任意代码执行。</li>
<li>Enum。 跨 FFi 边界两端的 枚举值要经过合法转换。</li>
<li>浮点数。</li>
<li>包含上述类型的复合类型</li>
</ul>
<h1><a class="header" href="#unsafe-io" id="unsafe-io">Unsafe I/O</a></h1>
<p>Rust 标准库提供了 I/O 安全性，保证程序持有私有的原始句柄（raw handle），其他部分无法访问它。但是 <code>FromRawFd::from_raw_fd</code> 是 Unsafe 的，所以在 Safe Rust中无法做到 <code>File::from_raw(7)</code> 这种事。 在这个文件描述符上面进行<code> I/O</code> 操作，而这个文件描述符可能被程序的其他部分私自持有。</p>
<hr />
<h2><a class="header" href="#gunsio01--在使用原始句柄的时候要注意-io-安全性" id="gunsio01--在使用原始句柄的时候要注意-io-安全性">G.UNS.IO.01  在使用原始句柄的时候，要注意 I/O 安全性</a></h2>
<h3><a class="header" href="#级别必须-30" id="级别必须-30">【级别：必须】</a></h3>
<p>必须严格按此规范执行。</p>
<h3><a class="header" href="#lint-检测-145" id="lint-检测-145">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制参考】</p>
<p>检测在 IO 时使用  <code>as_raw_fd</code> 调用时，警告开发者这是 Unsafe 的，要对传入的原始文件描述符的安全性进行考察。</p>
<h3><a class="header" href="#描述-177" id="描述-177">【描述】</a></h3>
<p>很多 API 通过接受 原始句柄 来进行 I/O 操作：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn do_some_io&lt;FD: AsRawFd&gt;(input: &amp;FD) -&gt; io::Result&lt;()&gt; {
    some_syscall(input.as_raw_fd())
}
<span class="boring">}
</span></code></pre></pre>
<p><code>AsRawFd</code>并没有限制<code>as_raw_fd</code>的返回值，所以<code>do_some_io</code>最终可以在任意的<code>RawFd</code>值上进行 <code>I/O </code>操作。甚至可以写<code>do_some_io(&amp;7)</code>，因为<code>RawFd</code>本身实现了<code>AsRawFd</code>。这可能会导致程序访问错误的资源。甚至通过创建在其他部分私有的句柄别名来打破封装边界，导致一些诡异的 远隔作用（Action at a distance）。</p>
<blockquote>
<p><strong>远隔作用</strong>（<strong>Action at a distance</strong>）是一种程式设计中的<a href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E6%A8%A1%E5%BC%8F">反模式</a>，是指程式某一部分的行为会广泛的受到程式其他部分<a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4">指令</a>的影响，而且要找到影响其他程式的指令很困难，甚至根本无法进行。</p>
</blockquote>
<p>在一些特殊的情况下，违反 I/O 安全甚至会导致内存安全。</p>
<h1><a class="header" href="#no-std" id="no-std">no-std</a></h1>
<p><code>no-std</code> 是指 被标示为 <code>#![no_std]</code> 的 crate，意味着该 crate 将链接到 <code>core</code> crate 而非 <code>std</code> crate。</p>
<p><code>no-std</code>  代表 裸机编程，嵌入式 Rust。</p>
<p>Rust 也有 <code>#![no_core]</code> 属性，但是还未稳定，不建议使用。</p>
<blockquote>
<p>参考数据： <code>core</code> 在编译后文件大小中只占大约 3k 大小。</p>
</blockquote>
<hr />
<h2><a class="header" href="#pemb01---no-std-下必须定义一个恐慌处理程序panic_handler以确保安全" id="pemb01---no-std-下必须定义一个恐慌处理程序panic_handler以确保安全">P.EMB.01   <code>no-std</code> 下必须定义一个恐慌处理程序（<code>#[panic_handler]</code>）以确保安全</a></h2>
<p>【描述】</p>
<p>恐慌处理程序的编写应该非常谨慎，以确保程序的安全。</p>
<h2><a class="header" href="#pemb02---要确保程序中的类型有正确的内存布局" id="pemb02---要确保程序中的类型有正确的内存布局">P.EMB.02   要确保程序中的类型有正确的内存布局</a></h2>
<p>【描述】</p>
<p>链接器决定 no-std 程序的最终内存布局，但我们可以使用<a href="https://sourceware.org/binutils/docs/ld/Scripts.html">链接器脚本</a>对其进行一些控制。链接器脚本给我们的布局控制粒度是在 段（ Section） 级别。段是在连续内存中布置的 符号 集合。反过来，符号可以是数据（静态变量）或指令（Rust 函数）。</p>
<p>这些编译器生成的符号和段名称不能保证在 Rust 编译器的不同版本中保持不变。但是，Rust 允许我们通过以下属性控制符号名称和部分位置：</p>
<ul>
<li><code>#[export_name = &quot;foo&quot;]</code>将符号名称设置为<code>foo</code>.</li>
<li><code>#[no_mangle]</code>意思是：使用函数或变量名（不是它的完整路径）作为它的符号名。 <code>#[no_mangle] fn bar()</code>将产生一个名为 的符号<code>bar</code>。</li>
<li><code>#[link_section = &quot;.bar&quot;]</code>将符号放置在名为 的部分中<code>.bar</code>。</li>
</ul>
<p>通过这些属性，我们可以公开程序的稳定 ABI 并在链接描述文件中使用它。</p>
<h2><a class="header" href="#pemb03---将一些公用的类型函数宏等集中到一个自定义的-baremetal-std" id="pemb03---将一些公用的类型函数宏等集中到一个自定义的-baremetal-std">P.EMB.03   将一些公用的类型、函数、宏等集中到一个自定义的 <code>baremetal-std</code></a></h2>
<p>【描述】</p>
<p>虽然 <code>no-std</code> 下不能用Rust 的标准库，但是可以自定义 <code>no-std</code> 下的标准库 <code>baremetal-std</code>，用于积累 <code>no-std</code> 下常用的公共库。</p>
<h1><a class="header" href="#io" id="io">I/O</a></h1>
<p>在标准库中也提供了标准 I/O 类型，在 Safe Rust 下，I/O 操作是足够安全的，但是对于 原生句柄 (Raw Fd) 的操作，则属于不安全。</p>
<p>在 Unsafe Rust 下也有相关 I/O  的规范，请参加 <a href="safe-guides/coding_practice/./unsafe_rust/io.html">Unsafe Rust - I/O</a>   部分。</p>
<p>本部分只关注 Safe Rust 下 I/O 相关规范。</p>
<hr />
<h2><a class="header" href="#pio01---文件读取建议使用-bufreaderbufwriter-来代替-readerwrite" id="pio01---文件读取建议使用-bufreaderbufwriter-来代替-readerwrite">P.IO.01   文件读取建议使用 <code>BufReader/BufWriter</code> 来代替 <code>Reader/Write</code></a></h2>
<p><strong>【描述】</strong></p>
<p><code>BufReader/BufWriter</code> 使用缓冲区来减少 I/O 请求的次数，提升性能。访问磁盘一次读取 256 个字节显然比 访问磁盘256次每次一个字节 效率要更高。</p>
<p>【示例】</p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io::{BufReader, Read};

fn main() {
    let mut data = String::new();
    let f = File::open(&quot;/etc/hosts&quot;).expect(&quot;Unable to open file&quot;);
    let mut br = BufReader::new(f);
    br.read_to_string(&amp;mut data).expect(&quot;Unable to read string&quot;);
    println!(&quot;{}&quot;, data);
}
</code></pre></pre>
<p>写 I/O：</p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io::{BufWriter, Write};

fn main() {
    let data = &quot;Some data!&quot;;
    let f = File::create(&quot;/tmp/foo&quot;).expect(&quot;Unable to create file&quot;);
    let mut f = BufWriter::new(f);
    f.write_all(data.as_bytes()).expect(&quot;Unable to write data&quot;);
}
</code></pre></pre>
<p>逐行读： 注意返回的每行字符串都不含有换行字符。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{BufRead, BufReader};

pub fn scan() -&gt; Result&lt;(), io::Error&gt; {
    let mut file = BufReader::new(try!(File::open(&quot;foo.txt&quot;)));

    let mut line = String::new();
    while try!(file.read_line(&amp;mut line)) != 0 {
        if line.starts_with(&quot;x&quot;) {
            try!(file.seek(SeekFrom::Start(1000)));
        }
        do_stuff(&amp;line);
        line.clear();
    }

    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#pio02----使用-read_to_endread_to_string方法时注意文件的大小能否一次性读入内存中" id="pio02----使用-read_to_endread_to_string方法时注意文件的大小能否一次性读入内存中">P.IO.02    使用 <code>read_to_end/read_to_string</code>方法时注意文件的大小能否一次性读入内存中</a></h2>
<p><strong>【描述】</strong></p>
<p>对于内存可以一次性读完的文件，可以使用 <code>read_to_end/read_to_string</code>之类的方法。但是如果你想读任意大小的文件，则不适合使用它们。</p>
<h1><a class="header" href="#security" id="security">Security</a></h1>
<p>Security 用于规范可能引起信息安全（Security）缺陷的代码实现，而非功能安全（ Safety）类问题。</p>
<hr />
<h2><a class="header" href="#gsecurity01--代码中不要出现非法-unicode-字符也要防范非法-unicode-字符" id="gsecurity01--代码中不要出现非法-unicode-字符也要防范非法-unicode-字符">G.Security.01  代码中不要出现非法 Unicode 字符，也要防范非法 Unicode 字符</a></h2>
<h3><a class="header" href="#级别-必须" id="级别-必须">【级别： 必须】</a></h3>
<p>必须按此规范执行。</p>
<h3><a class="header" href="#lint-检测-146" id="lint-检测-146">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#invisible_characters"><code>invisible_characters</code></a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
<tr><td><a href="https://doc.rust-lang.org/rustc/lints/listing/deny-by-default.html#text-direction-codepoint-in-comment"><code>text-direction-codepoint-in-comment</code></a></td><td>no</td><td>yes</td><td>-</td><td>deny</td></tr>
<tr><td><a href="https://doc.rust-lang.org/rustc/lints/listing/deny-by-default.html#text-direction-codepoint-in-literal"><code>text_direction_codepoint_in_literal</code></a></td><td>no</td><td>yes</td><td>-</td><td>deny</td></tr>
<tr><td><a href="https://doc.rust-lang.org/rustc/lints/listing/warn-by-default.html#confusable-idents"><code>confusable_idents</code></a></td><td>no</td><td>yes</td><td>-</td><td>warn</td></tr>
<tr><td><a href="https://doc.rust-lang.org/rustc/lints/listing/warn-by-default.html#mixed-script-confusables"><code>mixed_script_confusables</code></a></td><td>no</td><td>yes</td><td>-</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-178" id="描述-178">【描述】</a></h3>
<p>非法 Unicode 字符可能引起安全问题。安全问题参见： <a href="https://blog.rust-lang.org/2021/11/01/cve-2021-42574.html">Rust 编译器安全公告（CVE-2021-42574）</a> </p>
<p>禁止的 Unicode 字符类别为：</p>
<ol>
<li>隐藏的 Unicode 字符</li>
<li>双向 Unicode 字符文本</li>
<li>同形 Unicode 字符</li>
</ol>
<p>Clippy Lint  目前只可以检测代码中出现的隐藏 Unicode 字符。</p>
<p>在 Rust 1.56.1 之后 新增两个 <code>lint</code> 拒绝代码中出现可以更改显示顺序的 <code>Unicode</code> 码点出现。并且特别禁止 <code>\u{202A}</code>，<code>\u{202B}</code>，<code>\u{202D}</code>，<code>\u{202E}</code>，<code>\u{2066}</code>， <code>\u{2067}</code>，<code>\u{2068}</code>，<code>\u{202C}</code>和<code>\u{2069}</code> 这几个特殊的 <code>Unicode</code> 码点。</p>
<p>Rust 的 <code>mixed_script_confusables</code> 和 <code>confusable_idents</code> 可以识别 同形字符。 </p>
<p>写代码的时候需要注意，尤其是开源代码，需要防范上述非法 Unicode 字符。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">#![deny(text_direction_codepoint_in_comment)]
fn main() {
    println!(&quot;{:?}&quot;); // '‮');
}

#![deny(text_direction_codepoint_in_literal)]
fn main() {
    println!(&quot;{:?}&quot;, '‮');
}
</code></pre></pre>
<p>【例外】</p>
<p>但也有例外，比如你的代码恰好是要处理这些特殊Unicode字符的。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From: https://docs.rs/crate/lingo/0.1.2/source/src/generated.rs
#[allow(clippy::invisible_characters)]
pub fn get_embed_languages() -&gt; FileContent {
    let mut f = FileContent::from_vec(vec![
        (
            Language::Afrikaans.name(),
            vec![
                &quot;e&quot;, &quot;a&quot;, &quot;i&quot;, &quot;n&quot;, &quot;s&quot;, &quot;r&quot;, &quot;o&quot;, &quot;t&quot;, &quot;d&quot;, &quot;e_&quot;, &quot;l&quot;, &quot;k&quot;, &quot;g&quot;, &quot;ie&quot;, &quot;n_&quot;,
                // 省略很多字符，包括特殊的隐藏 unicode 字符
            ]
        )
    )
 }
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#其他" id="其他">其他</a></h1>
<h2><a class="header" href="#goth01----对于某些场景下不建议使用的方法可以通过配置-clippytoml-来拒绝" id="goth01----对于某些场景下不建议使用的方法可以通过配置-clippytoml-来拒绝">G.OTH.01    对于某些场景下不建议使用的方法可以通过配置 <code>clippy.toml</code> 来拒绝</a></h2>
<h3><a class="header" href="#级别建议-134" id="级别建议-134">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-147" id="lint-检测-147">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#disallowed_method">disallowed_method</a></td><td>yes</td><td>no</td><td>nursery</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#disallowed_script_idents">disallowed_script_idents</a></td><td>yes</td><td>no</td><td><strong>restriction</strong></td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#disallowed_type">disallowed_type</a></td><td>yes</td><td>no</td><td><strong>nursery</strong></td><td>allow</td></tr>
</tbody></table>
<p>这些lint 作用相似，但注意<code>nursery</code> 的lint 还未稳定。 </p>
<h3><a class="header" href="#描述-179" id="描述-179">【描述】</a></h3>
<p>有些场合可能需要拒绝使用一些容易出错的方法或函数，可以在 <code>clippy.toml</code> 中通过配置 <code>disallowed_method</code> 来满足这个需求。</p>
<pre><code class="language-toml"># clippy.toml
disallowed-methods = [
    # Can use a string as the path of the disallowed method.
    &quot;std::boxed::Box::new&quot;,
    # Can also use an inline table with a `path` key.
    { path = &quot;std::time::Instant::now&quot; },
    # When using an inline table, can add a `reason` for why the method
    # is disallowed.
    { path = &quot;std::vec::Vec::leak&quot;, reason = &quot;no leaking memory&quot; },
]

# 允许 Lint 支持配置值对应的本地语言
# 配置时候从该列表取别名 https://www.unicode.org/iso15924/iso15924-codes.html
allowed-locales = [&quot;Latin&quot;, &quot;Cyrillic&quot;] 
</code></pre>
<p>【反例】</p>
<p>当 <code>clippy.toml</code> 做了上面配置时，下面代码会曝出警告。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example code where clippy issues a warning
let xs = vec![1, 2, 3, 4];
xs.leak(); // Vec::leak is disallowed in the config.
// The diagnostic contains the message &quot;no leaking memory&quot;.

let _now = Instant::now(); // Instant::now is disallowed in the config.

let _box = Box::new(3); // Box::new is disallowed in the config.
<span class="boring">}
</span></code></pre></pre>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example code which does not raise clippy warning
let mut xs = Vec::new(); // Vec::new is _not_ disallowed in the
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#goth02---标准库-计算秒级毫秒级微秒级的时间请使用对应的方法" id="goth02---标准库-计算秒级毫秒级微秒级的时间请使用对应的方法">G.OTH.02   【标准库】 计算秒级、毫秒级、微秒级的时间请使用对应的方法</a></h2>
<h3><a class="header" href="#级别建议-135" id="级别建议-135">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#lint-检测-148" id="lint-检测-148">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#duration_subsec">duration_subsec</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-180" id="描述-180">【描述】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::time::Duration;
</span>let dur = Duration::new(5, 0);

// Good
let _micros = dur.subsec_micros(); // 得到微秒
let _millis = dur.subsec_millis(); // 得到毫秒
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::time::Duration;
</span>let dur = Duration::new(5, 0);

// Bad
let _micros = dur.subsec_nanos() / 1_000;      // 用纳秒 计算
let _millis = dur.subsec_nanos() / 1_000_000;  // 用纳秒 计算

<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#附录" id="附录">附录</a></h1>
<ul>
<li><a href="safe-guides/Appendix/./test.html">测试</a>
<ul>
<li><a href="safe-guides/Appendix/./test/unit_test.html">单元测试</a></li>
<li><a href="safe-guides/Appendix/./test/benchmark.html">基准测试</a></li>
<li><a href="safe-guides/Appendix/./test/fuzz.html">模糊测试</a></li>
</ul>
</li>
<li><a href="safe-guides/Appendix/./terms.html">术语解释</a></li>
<li><a href="safe-guides/Appendix/./templates/intro.html">模板</a>
<ul>
<li><a href="safe-guides/Appendix/./templates/rustfmt.toml.html">rustfmt 模板</a></li>
<li><a href="safe-guides/Appendix/./templates/clippy.toml.html">clippy 模板</a></li>
<li><a href="safe-guides/Appendix/./templates/deny.toml.html">deny 模板</a></li>
</ul>
</li>
<li><a href="safe-guides/Appendix/./tools/intro.html">工具链</a>
<ul>
<li><a href="safe-guides/Appendix/./tools/rustfmt.html">rustfmt</a></li>
<li><a href="safe-guides/Appendix/./tools/noisy-clippy.html">noisy-clippy</a></li>
<li><a href="safe-guides/Appendix/./tools/cargo-udeps.html">cargo-udeps</a> </li>
</ul>
</li>
</ul>
<h1><a class="header" href="#测试" id="测试">测试</a></h1>
<h1><a class="header" href="#单元测试" id="单元测试">单元测试</a></h1>
<p>Rust 支持单元测试。</p>
<h2><a class="header" href="#测试代码组织" id="测试代码组织">测试代码组织</a></h2>
<p>对于内部函数，单元测试代码最好放到业务代码的同一个模块下。</p>
<p>对于外部接口，单元测试最好放到独立的 <code>tests</code> 目录。</p>
<h2><a class="header" href="#文档测试" id="文档测试">文档测试</a></h2>
<p>对所有对外接口进行文档测试是一个不错的开始。</p>
<h2><a class="header" href="#编译测试" id="编译测试">编译测试</a></h2>
<p>通过 <code>compiletest</code> 来测试某些代码可能无法编译。 参考： <a href="https://rustc-dev-guide.rust-lang.org/tests/adding.html#ui">Rustc开发指南</a></p>
<h2><a class="header" href="#随机测试" id="随机测试">随机测试</a></h2>
<p>使用 第三方库<code>proptest</code> 来进行随机测试。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use proptest::prelude::*;

proptest! {
    #[test]
    fn check_count_correct(haystack: Vec&lt;u8&gt;, needle: u8) {
        prop_assert_eq!(count(&amp;haystack, needle), naive_count(&amp;haystack, needle));
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#代码测试率覆盖检测工具" id="代码测试率覆盖检测工具">代码测试率覆盖检测工具</a></h2>
<p><a href="https://github.com/xd009642/tarpaulin">tarpaulin</a> 是 Cargo 构建系统的代码覆盖率报告工具，目前 <strong>仅支持运行 Linux 的 x86_64 处理器</strong>。</p>
<h1><a class="header" href="#基准测试" id="基准测试">基准测试</a></h1>
<p>说明： 借用 MogoDB 工程师 Patrick 的文章来了解 Rust 里做基准测试基本姿势。</p>
<blockquote>
<p>原文： <a href="https://patrickfreed.github.io/rust/2021/10/15/making-slow-rust-code-fast.html">https://patrickfreed.github.io/rust/2021/10/15/making-slow-rust-code-fast.html</a></p>
</blockquote>
<h2><a class="header" href="#使用-criterionrs-和-火焰图flamegraphs-进行性能调优" id="使用-criterionrs-和-火焰图flamegraphs-进行性能调优">使用 Criterion.rs 和 火焰图（flamegraphs） 进行性能调优</a></h2>
<p>性能是开发者为其应用程序选择 Rust 的首要原因之一。事实上，它是 <code>rust-lang.org</code> 主页上 <a href="https://www.rust-lang.org/#:%7E:text=Version%201.55.0-,Why%20Rust%3F,-Performance">&quot;为什么选择Rust？&quot;</a>一节中列出的第一个原因，甚至在内存安全之前。这也是有原因的，许多基准测试表明，用Rust编写的软件速度很快，有时甚至是<a href="https://www.techempower.com/benchmarks/#section=data-r18&amp;hw=ph&amp;test=fortune">最快</a>的。但这并不意味着所有用Rust编写的软件都能保证快速。事实上，写低性能的Rust代码是很容易的，特别是当试图通过Clone 或<code>Arc</code>替代借用来&quot;&quot;安抚&quot;&quot;借用检查器时，这种策略通常被推荐给 Rust 新手。这就是为什么对 Rust 代码进行剖析和基准测试是很重要的，可以看到任何瓶颈在哪里，并修复它们，就像在其他语言中那样。在这篇文章中，我将根据最近的工作经验，展示一些基本的工具和技术，以提高 <code>mongodb</code>  crate 的性能。</p>
<p>注意：本帖中使用的所有示例代码都可以在<a href="https://github.com/patrickfreed/benchmark-example">这里</a>找到。</p>
<h2><a class="header" href="#索引" id="索引">索引</a></h2>
<ul>
<li><a href="safe-guides/Appendix/test/benchmark.html#%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90">性能剖析(Profiling)</a>
<ul>
<li><a href="safe-guides/Appendix/test/benchmark.html#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95">基准测试(Benchmarking)</a></li>
<li><a href="safe-guides/Appendix/test/benchmark.html#%E7%81%AB%E7%84%B0%E5%9B%BE%E7%94%9F%E6%88%90">火焰图生成</a></li>
<li><a href="safe-guides/Appendix/test/benchmark.html#%E8%AF%86%E5%88%AB%E7%81%AB%E7%84%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E7%93%B6%E9%A2%88">识别火焰图中的瓶颈</a></li>
</ul>
</li>
<li><a href="safe-guides/Appendix/test/benchmark.html#%60Clone%60%E7%9A%84%E2%80%9C%E8%A2%AD%E5%87%BB%E2%80%9D"> <code>Clone</code> 的 “袭击”</a></li>
<li><a href="safe-guides/Appendix/test/benchmark.html#%E5%8A%A0%E9%80%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96">加速反序列化</a></li>
<li><a href="safe-guides/Appendix/test/benchmark.html#%E5%88%86%E6%9E%90%E7%BB%93%E6%9E%9C">分析结果</a>
<ul>
<li><a href="safe-guides/Appendix/test/%E6%9F%A5%E7%9C%8BCriterion%E7%9A%84HTML%E6%8A%A5%E5%91%8A">查看Criterion的HTML报告</a></li>
<li><a href="safe-guides/Appendix/test/benchmark.html#%E4%BD%BF%E7%94%A8%60wrk%60%E8%BF%9B%E8%A1%8C%E5%8E%8B%E6%B5%8B">使用<code>wrk</code>进行压测</a></li>
</ul>
</li>
<li><a href="safe-guides/Appendix/test/benchmark.html#%E4%B8%8B%E4%B8%80%E6%AD%A5">下一步</a></li>
<li><a href="safe-guides/Appendix/test/benchmark.html#%E6%80%BB%E7%BB%93">总结</a></li>
<li><a href="safe-guides/Appendix/test/benchmark.html#%E5%B9%BF%E5%91%8A%E6%97%B6%E9%97%B4">广告时间</a></li>
</ul>
<h2><a class="header" href="#性能剖析" id="性能剖析">性能剖析</a></h2>
<p>在进行任何性能调优工作时，在试图修复任何东西之前，绝对有必要对代码进行性能剖析（profiling），因为瓶颈往往位于意想不到的地方，而且怀疑的瓶颈往往不如你想的那样对性能有足够影响。如果不遵守这一原则，就会导致<a href="https://wiki.c2.com/?PrematureOptimization">过早优化</a>，这可能会不必要地使代码复杂化并浪费开发时间。这也是为什么建议新人在开始的时候自由地 Clone ，这样可以帮助提高可读性，而且可能不会对性能产生严重的影响，但是如果他们这样做了，以后的性能剖析会发现这一点，所以在那之前没有必要担心。</p>
<blockquote>
<p>过早优化（Premature Optimization）</p>
<p>Premature optimization is the root of all evil.  --  DonaldKnuth</p>
<p>在 DonaldKnuth 的论文 《 Structured Programming With GoTo Statements 》中，他写道：&quot;程序员浪费了大量的时间去考虑或担心程序中非关键部分的速度，而当考虑到调试和维护时，这些对效率的尝试实际上会产生强烈的负面影响。我们应该忘记这种微小的效率，比如说因为过早优化而浪费的大约97%的时间。然而，我们不应该放弃那关键的 3% 的机会&quot;。</p>
</blockquote>
<h3><a class="header" href="#基准测试-1" id="基准测试-1">基准测试</a></h3>
<p>剖析的第一步是建立一套一致的基准，可以用来确定性能的基线水平，并衡量任何渐进的改进。在 <code>mongodb</code> 的案例中，标准化的<a href="https://github.com/mongodb/specifications/blob/master/source/benchmarking/benchmarking.rst"><code>MongoDB</code> 驱动微基准集</a>在这方面发挥了很好的作用，特别是因为它允许在用其他编程语言编写的<code>MongoDB</code>驱动之间进行比较。由于这些是 &quot;微 &quot;基准，它们还可以很容易地测量单个组件的变化（例如，读与写），这在专注于在特定领域进行改进时是非常有用的。</p>
<p>一旦选择了基准，就应该建立一个稳定的环境，可以用来进行所有的定时测量。确保环境不发生变化，并且在分析时不做其他 &quot;工作&quot;（如浏览猫的图片），这对减少基准测量中的噪音很重要。</p>
<h4><a class="header" href="#用-cargo-bench-和-criterionrs-来执行基准测试" id="用-cargo-bench-和-criterionrs-来执行基准测试">用 <code>cargo bench</code> 和 <code>Criterion.rs</code> 来执行基准测试</a></h4>
<p>Rust 提供的基准测试只能在 Nightly 下使用，因为它还未稳定。它对简单的基准测试比较有用，但是功能有限，而且没有很好的文档。另一个选择是<a href="https://crates.io/crates/criterion"> <code>criterion</code></a> crate。它为基准测试提供了更多的可配置性和丰富的功能支持，同时支持稳定的Rust ！我将详细介绍基本的 criterion crate。</p>
<p>我将在这里详细介绍一个基本的 criterion 设置，但如果想了解更多信息，我强烈推荐你查看优秀的<a href="https://bheisler.github.io/criterion.rs/book/index.html"> Criterion.rs 用户指南</a>。</p>
<p>在对<code>mongodb</code>进行基准测试时，我首先使用<code>cargo new &lt;my-benchmark-project&gt;</code>创建了一个新项目，并在<code>Cargo.toml</code>中添加了以下几行。</p>
<pre><code class="language-toml">[dependencies]
tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] }
futures = { version = &quot;0.3&quot;, default-features = false }
mongodb = { path = &quot;/home/patrick/mongo-rust-driver&quot; }

[dev-dependencies]
criterion = { version = &quot;0.3.5&quot;, features = [&quot;async_tokio&quot;, &quot;html_reports&quot;] }

[[bench]]
name = &quot;find&quot;
harness = false
</code></pre>
<p>在我的基准测试中，使用了<code> tokio</code> 异步运行时，所以我需要把它指定为一个依赖项，并启用<code>async_tokio</code>的 <code>criterion </code> features，但如果你不使用<code>tokio</code>，这不是必需的。我还需要使用<code>futures</code> crate提供的一些功能，但这对于运行一个<code>criterion</code>  基准来说也是没有必要的。对于我的<code>mongodb</code>依赖，我指定了一个本地克隆库的路径，这样我就可以对我做的任何改动进行基准测试。另外，在这个例子中，我将专注于对<code>mongodb</code> crate的<a href="https://docs.rs/mongodb/2.0.0/mongodb/struct.Collection.html#method.find"><code>Collection::find</code></a>方法进行基准测试，所以我对基准进行了相应的命名，但你可以对你的基准测试进行任意命名。</p>
<p>接下来，需要创建一个<code>benches/find.rs</code>文件来包含基准测试。文件名需要与<code>Cargo.toml</code>中的名称字段中指定的值相匹配。下面是一个测试<code>Collection::find</code>性能的简单基准测试的例子。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use criterion::{criterion_group, criterion_main, Criterion};
use futures::TryStreamExt;
use mongodb::{
    bson::{doc, Document},
    Client,
};

pub fn find_bench(c: &amp;mut Criterion) {
    // begin setup

    // create the tokio runtime to be used for the benchmarks
    let rt = tokio::runtime::Builder::new_multi_thread()
        .enable_all()
        .build()
        .unwrap();

    // seed the data server side, get a handle to the collection
    let collection = rt.block_on(async {
        let client = Client::with_uri_str(&quot;mongodb://localhost:27017&quot;)
            .await
            .unwrap();

        let collection = client.database(&quot;foo&quot;).collection(&quot;bar&quot;);
        collection.drop(None).await.unwrap();

        let doc = doc! {
            &quot;hello&quot;: &quot;world&quot;,
            &quot;anotherKey&quot;: &quot;anotherValue&quot;,
            &quot;number&quot;: 1234
        };
        let docs = vec![&amp;doc; 10_000];
        collection.insert_many(docs, None).await.unwrap();
        collection
    });
    // end setup

    c.bench_function(&quot;find&quot;, |b| {
        b.to_async(&amp;rt).iter(|| {
            // begin measured portion of benchmark
            async {
                collection
                    .find(doc! {}, None)
                    .await
                    .unwrap()
                    .try_collect::&lt;Vec&lt;Document&gt;&gt;()
                    .await
                    .unwrap();
            }
        })
    });
}

criterion_group!(benches, find_bench);
criterion_main!(benches);
<span class="boring">}
</span></code></pre></pre>
<p><code>find_bench</code>函数包含设置和运行基准的所有代码。该函数可以被任意命名，但是它需要接收一个<code>&amp;mut Criterion</code>作为参数。该函数的第一部分包含设置代码，在基准运行前只执行一次，其运行时间根本不被测量。实际测量的部分是稍后被传入<code>Bencher::iter</code>的闭包。该闭包将被多次运行，每次运行的时间将被记录、分析，并包含在一个HTML报告中。</p>
<p>在这个特定的例子中，设置涉及到创建<code>tokio</code>运行时，该运行时将用于基准测试的其余部分。通常，这是在幕后通过<code>tokio::main</code>宏完成的，或者，在库的情况下，根本就不需要。然而，我们需要在这里手动创建一个运行时，以便我们以后可以通过<code>Bencher::to_async</code>方法将其传递给<code>criterion</code>。一旦运行时被创建，设置就会继续进行，即填充我们在实际基准中要查询的<code>MongoDB</code>集合。由于这涉及到异步<code>API</code>的使用，我们需要通过<code>Runtime::block_on</code>确保它们在异步运行时的上下文中执行。在实际测量部分，我们对设置时创建的集合中的所有文档进行查询。</p>
<p>所有这些都准备好了（并且我们的<code>MongoDB</code>实例正在运行），我们可以运行<code>cargo bench</code>来建立我们的基线。输出结果将如下。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>~/benchmark-example$ cargo bench
    Finished bench [optimized] target(s) in 0.07s
     Running unittests (target/release/deps/benchmark_example-b9c25fd0639c5e9c)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests (target/release/deps/find-e1f66bfc9cf31158)
Gnuplot not found, using plotters backend
Benchmarking find: Warming up for 3.0000 s
find                    time:   [55.442 ms 55.663 ms 55.884 ms]
<span class="boring">}
</span></code></pre></pre>
<p>这里最重要的信息是时间： <code>[55.442 ms 55.663 ms 55.884 ms]</code>。中间的值是对每次迭代所花时间的最佳估计，第一个和最后一个值定义了置信区间（Confidence interval）的上界和下界。默认情况下，使用的置信度是<code>95%</code>，这意味着该区间有<code>95%</code>的机会包含迭代的实际平均运行时间。关于这些值以及如何计算的更多信息，请查看<code>Criterion.rs</code>用户指南。</p>
<p>现在，如果我们再次执行<code>cargo bench</code>，它将记录更多的时间，并与之前的时间进行比较（之前的数据存储在目标/标准中），报告任何变化。鉴于我们根本没有改变代码，这应该报告说没有任何变化。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>find                    time:   [55.905 ms 56.127 ms 56.397 ms]
                        change: [+0.3049% +0.8337% +1.4904%] (p = 0.01 &lt; 0.05)
                        Change within noise threshold.
Found 5 outliers among 100 measurements (5.00%)
  1 (1.00%) low mild
  2 (2.00%) high mild
  2 (2.00%) high severe
<span class="boring">}
</span></code></pre></pre>
<p>正如预期的那样，criterion  报告说，与上次运行相比，任何性能的变化都可能是由于噪音造成的。现在我们已经建立了一个基线，现在是时候对代码进行剖析，看看它哪里慢。</p>
<h3><a class="header" href="#火焰图生成" id="火焰图生成">火焰图生成</a></h3>
<p><a href="https://perf.wiki.kernel.org/index.php/Main_Page">perf</a> 是一个Linux命令行工具，可以用来获取一个应用程序的性能信息。我们不会直接使用它，而是通过<a href="https://crates.io/crates/flamegraph"><code>flamegraph</code> </a> crate，它是一个基于Rust的flamegraph生成器，可以与<code>cargo</code>一起工作。</p>
<p>火焰图（<a href="https://github.com/brendangregg/FlameGraph"><code>Flamegraphs</code></a>）是程序在每个函数中花费时间的有用的可视化数据。在被测量的执行过程中调用的每个函数被表示为一个矩形，每个调用栈被表示为一个矩形栈。一个给定的矩形的宽度与在该函数中花费的时间成正比，更宽的矩形意味着更多的时间。火焰图对于识别程序中的慢速部分非常有用，因为它们可以让你快速识别代码库中哪些部分花费的时间不成比例。</p>
<p>要使用<code>cargo</code>生成<code>flamegraphs</code>，首先我们需要安装<code>perf</code>和<code>flamegraph </code>crate。这在<code>Ubuntu</code>上可以通过以下方式完成。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>sudo apt-get install linux-tools-common linux-tools-`uname -r`
cargo install flamegraph
<span class="boring">}
</span></code></pre></pre>
<p>一旦安装完成，我们就可以生成我们的基线的第一个<code>flamegraph</code>! 要做到这一点，请运行以下程序。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cargo flamegraph --bench find -o find-baseline.svg -- --bench
<span class="boring">}
</span></code></pre></pre>
<p>然后你可以在浏览器中打开<code>find-baseline.svg</code>来查看火焰图。如果你在运行<code>cargo flamegraph</code>时遇到权限问题，请参阅<code>flamegraph</code> crate的<code>README</code>中的说明。</p>
<p>生成 criterion 基准的<code>flamegraph</code>可能会有噪音，因为很多时间都花在了 criterion（例如测量时间）和设置上，而不是在被基准测试的部分。为了减少火焰图中的一些噪音，你可以写一个与基准的测量部分行为类似的程序，然后生成另一个火焰图来代替。</p>
<p>例如，我用下面的命令从一个普通的二进制程序中生成一个火焰图，该程序使用我的本地<code>mongodb</code> crate副本来执行没有criterion的查找。</p>
<pre><code>cargo flamegraph --bin my-binary -o find-baseline.svg
</code></pre>
<p>这里是生成的火焰图（在新的浏览器标签页中打开它来探索）。</p>
<p><img src="https://patrickfreed.github.io/resources/making-slow-rust-code-fast/find-baseline.svg" alt="`" /></p>
<p>现在我们可以看到时间花在哪里了，现在是时候深入研究，看看我们是否能找到瓶颈。</p>
<h3><a class="header" href="#识别火焰图中的瓶颈" id="识别火焰图中的瓶颈">识别火焰图中的瓶颈</a></h3>
<p>火焰图中的栈从底部开始，随着调用栈的加深而向上移动（左右无所谓），通常这是开始阅读它们的最佳方式。看一下上面火焰图的底部，最宽的矩形是<code>Future::poll</code>，但这并不是因为Rust 的 <code>Future</code> 超级慢，而是因为每个<code>.await</code>都涉及轮询（poll）<code>Future</code>。考虑到这一点，我们可以跳过任何轮询矩形，直到我们可以在<code>mongodb</code>中看到我们关心的信息的函数。下面火焰图的注释版本，突出了需要注意的部分。</p>
<p><img src="https://patrickfreed.github.io/resources/making-slow-rust-code-fast/flamegraph-annotated.png" alt="2" /></p>
<p>蓝色方块包含了调用<code>CommandResponse::body</code>所花费的时间，它显示几乎所有的时间都花在了<code>clone()</code>上。各个紫色矩形对应的是将<code>BSON</code>（MongoDB使用的二进制格式）解析到<code>Document</code>中所花费的时间，绿色矩形对应的是<code>Document</code>的<code>serde::Deserialize</code>实现中所花费的时间。最后，黑色虚线矩形对应的是释放内存的时间，黑色实线对应的是将命令序列化为<code>BSON</code>的时间。</p>
<p>现在我们知道了大部分时间花在哪里（只在少数几个地方），我们可以集中精力实际改变代码，使其更快。</p>
<h2><a class="header" href="#clone的袭击" id="clone的袭击"><code>Clone</code>的“袭击”</a></h2>
<p>无论做任何事，从最容易实现的地方开始，往往可以产生最好的回报。在这个例子中，只是  <code>clone</code> 就花费了一大块时间，所以我们能简单地消除 <code>clone</code>。从火焰图里知道，最昂贵的<code>clone</code> 就是 <code>CommandResponse::body</code> 中调用的那个，所以我们去看看这个<a href="https://github.com/mongodb/mongo-rust-driver/blob/v2.0.0-beta/src/cmap/conn/command.rs#L138">方法</a>。</p>
<p>在 <code>command.rs:149</code> 行，我们看到如下定义：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Deserialize the body of the response.
pub(crate) fn body&lt;T: DeserializeOwned&gt;(&amp;self) -&gt; Result&lt;T&gt; {
    match bson::from_bson(Bson::Document(self.raw_response.clone())) {
        Ok(body) =&gt; Ok(body),
        Err(e) =&gt; Err(ErrorKind::ResponseError {
            message: format!(&quot;{}&quot;, e),
        }
        .into()),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我们可以看到，这里确实有一个对<code>clone</code>的调用，所以它很可能是我们在火焰图中看到的耗费大量时间的那个。<code>clone</code>是必须的，因为我们需要从<code>self</code>所拥有的<code>raw_response</code>中反序列化，但我们只有对<code>self</code>的引用，所以我们不能从其中移出(move out)。我们也不能通过引用来使用<code>raw_response</code>，因为<code>bson::from_bson</code>期望一个有所有权的值。让我们研究一下 <code>body</code> 本身被调用的地方，看看我们是否可以改变它以获得 <code>self </code>的所有权，从而避免<code>clone</code>。</p>
<p>具体来看这个基准的使用情况，在<code>Find::handle_response</code>中，查找操作使用它来反序列化服务端上的<code>response</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_response(&amp;self, response: CommandResponse) -&gt; Result&lt;Self::O&gt; {    let body: CursorBody = response.body()?;    Ok(CursorSpecification::new(        self.ns.clone(),        response.source_address().clone(),        body.cursor.id,        self.options.as_ref().and_then(|opts| opts.batch_size),        self.options.as_ref().and_then(|opts| opts.max_await_time),        body.cursor.first_batch,    ))}
<span class="boring">}
</span></code></pre></pre>
<p>正如我们在这里看到的，<code>response</code>只在调用<code>body</code>后使用了一次，而且这一次的使用可以在它之前没有问题，所以如果 <code>body</code> 取得了<code>self</code>的所有权，这个调用点至少还能工作。对其余的调用点重复这个过程，我们看到<code>body</code>实际上可以取得<code>self</code>的所有权，从而避免<code>clone</code>，所以让我们做这个改变，看看它对性能有什么影响。</p>
<p>在做了这个改变之后，重新运行<code>cargo bench</code>的结果如下。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>find                    time:   [47.495 ms 47.843 ms 48.279 ms]                        change: [-15.488% -14.760% -13.944%] (p = 0.00 &lt; 0.05)                        Performance has improved.Found 4 outliers among 100 measurements (4.00%)  4 (4.00%) high severe
<span class="boring">}
</span></code></pre></pre>
<p>很好! 即使在这样一个简单的改变之后，我们已经观察到了性能上的明显改善。既然一些简单的问题已经被解决了，让我们调查一下其他花费大量时间的地方。</p>
<h2><a class="header" href="#加速反序列化" id="加速反序列化">加速反序列化</a></h2>
<p>回顾一下火焰图，我们可以看到很大一部分时间都花在了解析来自 <code>MongoDB Wire</code> 协议（紫色）的响应上，然后通过<code>serde</code>（绿色）将它们反序列化为 Rust 数据结构。尽管每一个步骤都在执行类似的任务，但这两个步骤是需要的，因为<code>bson</code> crate只支持从<code>Bson</code>和<code>Document</code> Rust类型反序列化，而不是实际的<code>BSON</code>，即<code>MongoDB wire</code> 协议中使用的二进制格式。火焰图表明，这个过程消耗了大量的时间，因此如果这两个步骤可以合并为一个，有可能会带来显著的性能优势。</p>
<p>本质上，我们想从以下几个方面入手。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bytes = socket.read(&amp;mut bytes).await?; // read message from databaselet document = Document::from_reader(bytes.as_slice())?; // parse into Documentlet rust_data_type: MyType = bson::from_document(document)?; // deserialize via serde
<span class="boring">}
</span></code></pre></pre>
<p>合并为：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bytes = socket.read(&amp;mut bytes).await?; // read message from databaselet rust_data_type: MyType = bson::from_slice(bytes.as_slice())?; // deserialize via serde
<span class="boring">}
</span></code></pre></pre>
<p>要做到这一点，我们需要实现一个新的<code>serde</code> 的 <code>Deserializer</code>，它可以与原始<code>BSON</code>一起工作。这方面的工作相当广泛，而且相当复杂，所以我就不说细节了。<code>serde</code>文档中的 &quot; <a href="https://serde.rs/impl-deserializer.html">实现 Deserializer</a> &quot;部分为那些感兴趣的人提供了一个实现<code>JSON</code>的优秀例子。</p>
<p>那么，现在我们<a href="https://github.com/mongodb/bson-rust/commit/7ccf82b3dc66141d8292a5c1e253362abaa13d5c">实现了 Deserializer</a>并 <a href="https://github.com/mongodb/mongo-rust-driver/commit/0fa2a905c1f5411a6f0109debe18c3cfa35c94be">更新了驱动程序</a> 以使用它，让我们重新运行<code>cargo bench</code>，看看它是否对性能有任何影响。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>find                    time:   [30.624 ms 30.719 ms 30.822 ms]                        change: [-36.409% -35.791% -35.263%] (p = 0.00 &lt; 0.05)                        Performance has improved.Found 5 outliers among 100 measurements (5.00%)  1 (1.00%) low mild  1 (1.00%) high mild  3 (3.00%) high severe
<span class="boring">}
</span></code></pre></pre>
<p>棒极了! 平均迭代时间比上一次大约减少了36%，这与最初的基线相比已经有了很大的减少。现在我们已经实施了一些改进，让我们仔细看看结果。</p>
<h2><a class="header" href="#分析结果" id="分析结果">分析结果</a></h2>
<h3><a class="header" href="#查看criterion的html报告" id="查看criterion的html报告">查看Criterion的HTML报告</a></h3>
<p><code>Criterion</code>支持生成一个<code>HTML</code>报告，总结最近的运行情况，并与之前的运行情况进行比较。要访问该报告，只需在浏览器中打开<code>target/criterion/report/index.html</code>。</p>
<p>作为一个例子，<a href="https://patrickfreed.github.io/resources/making-slow-rust-code-fast/criterion/find/report/index.html">这里</a>是比较基线和最优化的报告。</p>
<p>在报告的顶部，我们可以看到最优化运行的总结，包括一个说明平均执行时间的图表和一个显示所有样本标准的散点图，以及一些其他图表的链接。下面是最近一次查找基准运行的该部分的屏幕截图。</p>
<p><img src="https://patrickfreed.github.io/resources/making-slow-rust-code-fast/report-summary.png" alt="3" /></p>
<p>在报告的底部，有一个最近两次运行的比较，较旧的运行（基线）为红色，较新的运行（优化后的）为蓝色。下面是优化后的<code>mongodb</code>版本与未优化的基线比较的部分的截图。在其中，我们可以看到，未优化的基线显然要比优化的慢得多。从分布的广度来看，我们也可以看到，优化版的性能比基线版的更稳定。</p>
<p><img src="https://patrickfreed.github.io/resources/making-slow-rust-code-fast/report-comparison.png" alt="4" /></p>
<p>这些报告是超级有用的工具，可以直观地看到因性能调优而发生的变化，而且对于向他人介绍结果特别有用。它们还可以作为过去性能数据的记录，消除了手动记录结果的需要。</p>
<h3><a class="header" href="#使用wrk进行压测" id="使用wrk进行压测">使用<code>wrk</code>进行压测</a></h3>
<p>虽然微基准对隔离行为和识别瓶颈非常有用，但它们并不总是代表真实的工作负载。为了证明所做的改变确实提高了性能，并且没有过度适应微基准，在真实世界的场景中进行测量也是很有用的。</p>
<p>对于像<code>mongodb</code>这样的异步数据库驱动来说，这意味着有大量并发请求的情况。一个生成这种请求的有用工具是<code>wrk</code>工作负载生成器。</p>
<p>要安装<code>wrk</code>，你需要<code>clone repo</code>并从源代码中构建它。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>git clone https://github.com/wg/wrkcd wrkmake./wrk --version
<span class="boring">}
</span></code></pre></pre>
<p>如果成功了，你应该看到<code>wrk</code>的版本信息。关于更具体的安装说明，请看 <code>wrk</code> 的 <code>INSTALL</code> 页面。</p>
<p>在启动了一个<code>actix-web</code>服务器（在release 模式下运行），它将对每个<code>GET</code>请求执行查找，我用下面的调用将<code>wrk</code>指向它。</p>
<pre><code>./wrk -t8 -c100 -d10s http://127.0.0.1:8080
</code></pre>
<p>这将在<code>10</code>秒内运行一个基准，使用<code>8</code>个线程，并保持<code>100</code>个HTTP连接开放。</p>
<p>使用未经优化的驱动程序，我看到了以下结果。</p>
<pre><code>Running 10s test @ http://127.0.0.1:8080  8 threads and 100 connections  Thread Stats   Avg      Stdev     Max   +/- Stdev    Latency     7.83ms    2.06ms  26.52ms   73.81%    Req/Sec     1.54k   379.64     7.65k    91.02%  122890 requests in 10.10s, 205.45MB readRequests/sec:  12168.39Transfer/sec:     20.34MB
</code></pre>
<p>优化后，我看到的却是这样的结果。</p>
<pre><code>Running 10s test @ http://127.0.0.1:8080  8 threads and 100 connections  Thread Stats   Avg      Stdev     Max   +/- Stdev    Latency     4.03ms    1.31ms  52.06ms   97.77%    Req/Sec     3.03k   292.52     6.00k    92.41%  242033 requests in 10.10s, 404.63MB readRequests/sec:  23964.39Transfer/sec:     40.06MB
</code></pre>
<p>.这意味着吞吐量几乎增加了<code>100％</code>，真棒！这意味着我们基于微基准的优化对实际工作负载有非常显著改善。</p>
<h2><a class="header" href="#下一步" id="下一步">下一步</a></h2>
<p>在这篇文章中，我们已经看到了如何只用一些基本的性能技术（生成火焰图、基准测试）就能在你的Rust应用程序中实现显著的性能改进。这方面的过程可以总结为以下步骤。</p>
<ol>
<li>使用 <code>criterion </code> 运行一个基准，以建立一个基线</li>
<li>通过<code>cargo flamegraph</code>识别瓶颈</li>
<li>尝试解决瓶颈问题</li>
<li>重新运行基准测试，看看瓶颈是否得到解决</li>
<li>重复进行以上步骤</li>
</ol>
<p>这个过程可以反复进行，直到达到一个令人满意的性能水平。然而，随着你的迭代，改进可能会变得不那么显著，需要更多的努力来实现。例如，在<code>mongodb</code>的例子中，第一个大的改进来自于更明智地使用<code>clone()</code>，但为了达到类似的改进水平，需要实现整个<code>serde</code> 的  <code>Deserializer</code> 。这就引出了性能剖析如此重要的另一个原因：除了识别需要优化的地方外，它还可以帮助确定何时需要优化（或者反过来说，何时应该停止优化）。如果剩下的改进不值得努力，性能剖析可以表明这一点，让你把精力集中在其他地方。这一点很重要，因为无论某件事情如何优化，总是有改进的余地，而且很容易陷入过度优化的无底洞中。</p>
<h2><a class="header" href="#总结" id="总结">总结</a></h2>
<p>我希望这个关于 Rust 中性能剖析和基准测试的概述是有帮助的。请注意，将你的 Rust 应用程序或库，优化到技术上尽可能快，并不总是必须的。因为优化的代码往往比简单但缓慢的代码更难理解和维护。</p>
<p>更重要的是，你的应用程序或库要满足其性能预期。例如，如果一个<code>CLI</code>工具的自我更新需要<code>50</code>毫秒或<code>100</code>毫秒，尽管有可能减少<code>50%</code>的运行时间，这并没有什么区别，因为<code>100</code>毫秒完全在这种功能的预期性能水平之内。然而，对于那些性能没有达到预期的情况，这篇文章中所概述的过程可以非常有效地产生优化，正如我们最近对<code>mongodb </code>crate所做的改进中所看到的。</p>
<h2><a class="header" href="#广告时间" id="广告时间">广告时间</a></h2>
<p>我们最近发布了<a href="https://crates.io/crates/mongodb"><code>mongodb</code></a> crate的<a href="https://github.com/mongodb/mongo-rust-driver/releases/tag/v2.0.0"> <code>v2.0.0</code></a>版本，其中包含了这篇文章中提到的性能改进，以及大量的新功能，包括对事务的支持。如果你对用Rust编写Web应用程序感兴趣，如果你需要一个数据库，请查看<code>MongoDB</code> Rus t驱动。</p>
<h2><a class="header" href="#" id=""></a></h2>
<h1><a class="header" href="#模糊测试" id="模糊测试">模糊测试</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Fuzz_testing">模糊测试（Fuzz testing）</a>是一种软件测试技术，用于通过向软件提供伪随机数据作为输入来发现安全性和稳定性问题。</p>
<p>关于模糊测试可以参考：</p>
<ul>
<li><a href="https://rust-fuzz.github.io/book/introduction.html">Rust Fuzz Book</a> </li>
<li><a href="https://github.com/rust-fuzz">https://github.com/rust-fuzz</a> </li>
<li><a href="https://about.gitlab.com/blog/2020/12/03/how-to-fuzz-rust-code/">How to fuzz Rust code continuously</a></li>
</ul>
<h1><a class="header" href="#术语解释" id="术语解释">术语解释</a></h1>
<h2><a class="header" href="#语言元素术语表" id="语言元素术语表">语言元素术语表</a></h2>
<table><thead><tr><th>术语</th><th>中文翻译</th><th>备注</th></tr></thead><tbody>
<tr><td><strong>A</strong></td><td></td><td></td></tr>
<tr><td>Abstract Syntax Tree</td><td>抽象语法树</td><td></td></tr>
<tr><td>ABI</td><td>应用程序二进制接口</td><td>Application Binary Interface 缩写</td></tr>
<tr><td>accumulator</td><td>累加器</td><td></td></tr>
<tr><td>accumulator variable</td><td>累加器变量</td><td></td></tr>
<tr><td>ahead-of-time compiled</td><td>预编译</td><td></td></tr>
<tr><td>ahead-of-time compiled language</td><td>预编译语言</td><td></td></tr>
<tr><td>alias</td><td>别名</td><td></td></tr>
<tr><td>aliasing</td><td>别名使用</td><td>参见 <a href="https://en.wikipedia.org/wiki/Pointer_aliasing">Wikipedia</a></td></tr>
<tr><td>angle brackets</td><td>尖括号，“&lt;”和“&gt;”</td><td></td></tr>
<tr><td>annotate</td><td>标注，注明（动词）</td><td></td></tr>
<tr><td>annotation</td><td>标注，注明（名词）</td><td></td></tr>
<tr><td>Arc</td><td>原子引用计数器</td><td>Atomic Referecne Counter</td></tr>
<tr><td>anonymity</td><td>匿名</td><td></td></tr>
<tr><td>argument</td><td>参数，实参，实际参数</td><td>不严格区分的话， argument（参数）和 <br> parameter（参量）可以互换地使用</td></tr>
<tr><td>argument type</td><td>参数类型</td><td></td></tr>
<tr><td>assignment</td><td>赋值</td><td></td></tr>
<tr><td>associated functions</td><td>关联函数</td><td></td></tr>
<tr><td>associated items</td><td>关联项</td><td></td></tr>
<tr><td>associated types</td><td>关联类型</td><td></td></tr>
<tr><td>asterisk</td><td>星号（*)</td><td></td></tr>
<tr><td>atomic</td><td>原子的</td><td></td></tr>
<tr><td>attribute</td><td>属性</td><td></td></tr>
<tr><td>automated building</td><td>自动构建</td><td></td></tr>
<tr><td>automated test</td><td>自动测试，自动化测试</td><td></td></tr>
<tr><td><strong>B</strong></td><td></td><td></td></tr>
<tr><td>baroque macro</td><td>巴洛克宏</td><td></td></tr>
<tr><td>benchmark</td><td>基准</td><td></td></tr>
<tr><td>binary</td><td>二进制的</td><td></td></tr>
<tr><td>binary executable</td><td>二进制的可执行文件</td><td></td></tr>
<tr><td>bind</td><td>绑定</td><td></td></tr>
<tr><td>block</td><td>语句块，代码块</td><td></td></tr>
<tr><td>boolean</td><td>布尔型，布尔值</td><td></td></tr>
<tr><td>borrow check</td><td>借用检查</td><td></td></tr>
<tr><td>borrower</td><td>借用者，借入者</td><td></td></tr>
<tr><td>borrowing</td><td>借用</td><td></td></tr>
<tr><td>bound</td><td>约束，限定，限制</td><td>此词和 constraint 意思相近，<br>constraint 在 C# 语言中翻译成“约束”</td></tr>
<tr><td>box</td><td>箱子，盒子，装箱类型</td><td>一般不译，作动词时翻译成“装箱”，<br>具有所有权的智能指针</td></tr>
<tr><td>boxed</td><td>装箱，装包</td><td></td></tr>
<tr><td>boxing</td><td>装箱，装包</td><td></td></tr>
<tr><td>brace</td><td>大括号，“{”或“}”</td><td></td></tr>
<tr><td>buffer</td><td>缓冲，缓冲区，缓冲器，缓存</td><td></td></tr>
<tr><td>build</td><td>构建</td><td></td></tr>
<tr><td>builder pattern</td><td>创建者模式</td><td></td></tr>
<tr><td><strong>C</strong></td><td></td><td></td></tr>
<tr><td>call</td><td>调用</td><td></td></tr>
<tr><td>caller</td><td>调用者</td><td></td></tr>
<tr><td>capacity</td><td>容器</td><td></td></tr>
<tr><td>capture</td><td>捕获</td><td></td></tr>
<tr><td>cargo</td><td>(Rust 包管理器，不译)</td><td>该词作名词时意思是“货物”，<br>作动词时意思是“装载货物”</td></tr>
<tr><td>cargo-fy</td><td>Cargo 化，使用 Cargo 创建项目</td><td></td></tr>
<tr><td>case analysis</td><td>事例分析</td><td></td></tr>
<tr><td>cast</td><td>类型转换，转型</td><td></td></tr>
<tr><td>casting</td><td>类型转换</td><td></td></tr>
<tr><td>chaining method call</td><td>链式方法调用</td><td></td></tr>
<tr><td>channel</td><td>信道，通道</td><td></td></tr>
<tr><td>closure</td><td>闭包</td><td></td></tr>
<tr><td>coercion</td><td>强制类型转换，强制转换</td><td>coercion 原意是“强制，胁迫”</td></tr>
<tr><td>collection</td><td>集合</td><td>参见 <a href="https://zh.wikipedia.org/wiki/%E9%9B%86%E5%90%88_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">Wikipedia</a></td></tr>
<tr><td>combinator</td><td>组合算子，组合器</td><td></td></tr>
<tr><td>comma</td><td>逗号，“,”</td><td></td></tr>
<tr><td>command</td><td>命令</td><td></td></tr>
<tr><td>command line</td><td>命令行</td><td></td></tr>
<tr><td>comment</td><td>注释</td><td></td></tr>
<tr><td>compile</td><td>编译（动词）</td><td></td></tr>
<tr><td>compile time</td><td>编译期，编译期间，编译时</td><td></td></tr>
<tr><td>compilation</td><td>编译（名词）</td><td></td></tr>
<tr><td>compilation unit</td><td>编译单元</td><td></td></tr>
<tr><td>compiler</td><td>编译器</td><td></td></tr>
<tr><td>compiler intrinsics</td><td>编译器固有功能</td><td></td></tr>
<tr><td>compound</td><td>复合（类型，数据）</td><td></td></tr>
<tr><td>concurrency</td><td>并发</td><td></td></tr>
<tr><td>conditional compilation</td><td>条件编译</td><td></td></tr>
<tr><td>configuration</td><td>配置</td><td></td></tr>
<tr><td>constructor</td><td>构造器</td><td></td></tr>
<tr><td>consumer</td><td>消费者</td><td></td></tr>
<tr><td>container</td><td>容器</td><td></td></tr>
<tr><td>container type</td><td>容器类型</td><td></td></tr>
<tr><td>convert</td><td>转换，转化，转</td><td></td></tr>
<tr><td>copy</td><td>复制，拷贝</td><td></td></tr>
<tr><td>crate</td><td>包，包装箱，装包</td><td>一般不译，crate 是 Rust 的基本编译单元</td></tr>
<tr><td>curly braces</td><td>大括号，包含“{”和“}”</td><td></td></tr>
<tr><td>custom type</td><td>自定义类型</td><td></td></tr>
<tr><td><strong>D</strong></td><td></td><td></td></tr>
<tr><td>dangling pointer</td><td>悬垂指针</td><td>use after free 在释放后使用</td></tr>
<tr><td>data race</td><td>数据竞争</td><td></td></tr>
<tr><td>dead code</td><td>死代码，无效代码，不可达代码</td><td></td></tr>
<tr><td>deallocate</td><td>释放，重新分配</td><td></td></tr>
<tr><td>declare</td><td>声明</td><td></td></tr>
<tr><td>deep copy</td><td>深拷贝，深复制</td><td></td></tr>
<tr><td>dependency</td><td>依赖</td><td></td></tr>
<tr><td>deref coercions</td><td>强制多态</td><td></td></tr>
<tr><td>dereference</td><td>解引用</td><td>Rust  文章中有时简写为 Deref</td></tr>
<tr><td>derive</td><td>派生</td><td></td></tr>
<tr><td>designator</td><td>指示符</td><td></td></tr>
<tr><td>destruction</td><td>销毁，毁灭</td><td></td></tr>
<tr><td>destructor</td><td>析构器，析构函数</td><td></td></tr>
<tr><td>destructure</td><td>解构</td><td></td></tr>
<tr><td>destructuring</td><td>解构，解构赋值</td><td></td></tr>
<tr><td>desugar</td><td>脱糖</td><td></td></tr>
<tr><td>diverge function</td><td>发散函数</td><td></td></tr>
<tr><td>device drive</td><td>设备驱动</td><td></td></tr>
<tr><td>directory</td><td>目录</td><td></td></tr>
<tr><td>dispatch</td><td>分发</td><td></td></tr>
<tr><td>diverging functions</td><td>发散函数</td><td></td></tr>
<tr><td>documentation</td><td>文档</td><td></td></tr>
<tr><td>dot operator</td><td>点运算符</td><td></td></tr>
<tr><td>DST</td><td>动态大小类型</td><td>dynamic sized type，一般不译，<br>使用英文缩写形式</td></tr>
<tr><td>dynamic language</td><td>动态类型语言</td><td></td></tr>
<tr><td>dynamic trait type</td><td>动态特质类型</td><td></td></tr>
<tr><td><strong>E</strong></td><td></td><td></td></tr>
<tr><td>enumeration</td><td>枚举</td><td></td></tr>
<tr><td>encapsulation</td><td>封装</td><td></td></tr>
<tr><td>equality test</td><td>相等测试</td><td></td></tr>
<tr><td>elision</td><td>省略</td><td></td></tr>
<tr><td>exhaustiveness checking</td><td>穷尽性检查，无遗漏检查</td><td></td></tr>
<tr><td>expression</td><td>表达式</td><td></td></tr>
<tr><td>expression-oriented language</td><td>面向表达式的语言</td><td></td></tr>
<tr><td>explicit</td><td>显式</td><td></td></tr>
<tr><td>explicit discriminator</td><td>显式的辨别值</td><td></td></tr>
<tr><td>explicit type conversion</td><td>显式类型转换</td><td></td></tr>
<tr><td>extension</td><td>扩展名</td><td></td></tr>
<tr><td>extern</td><td>外，外部</td><td>作关键字时不译</td></tr>
<tr><td><strong>F</strong></td><td></td><td></td></tr>
<tr><td>fat pointer</td><td>胖指针</td><td></td></tr>
<tr><td>feature gate</td><td>功能开关</td><td></td></tr>
<tr><td>field</td><td>字段</td><td></td></tr>
<tr><td>field-level mutability</td><td>字段级别可变性</td><td></td></tr>
<tr><td>file</td><td>文件</td><td></td></tr>
<tr><td>fmt</td><td>格式化，是 format 的缩写</td><td></td></tr>
<tr><td>formatter</td><td>格式化程序，格式化工具，格式器</td><td></td></tr>
<tr><td>floating-point number</td><td>浮点数</td><td></td></tr>
<tr><td>flow control</td><td>流程控制</td><td></td></tr>
<tr><td>Foreign Function Interface（FFI）</td><td>外部语言函数接口</td><td></td></tr>
<tr><td>fragment specifier</td><td>片段分类符</td><td></td></tr>
<tr><td>free variables</td><td>自由变量</td><td></td></tr>
<tr><td>freeze</td><td>冻结</td><td></td></tr>
<tr><td>function</td><td>函数</td><td></td></tr>
<tr><td>function declaration</td><td>函数声明</td><td></td></tr>
<tr><td>functional</td><td>函数式</td><td></td></tr>
<tr><td><strong>G</strong></td><td></td><td></td></tr>
<tr><td>garbage collector</td><td>垃圾回收</td><td></td></tr>
<tr><td>generalize</td><td>泛化，泛型化</td><td></td></tr>
<tr><td>generator</td><td>生成器</td><td></td></tr>
<tr><td>generic</td><td>泛型</td><td></td></tr>
<tr><td>generic type</td><td>泛型类型</td><td></td></tr>
<tr><td>growable</td><td>可增长的</td><td></td></tr>
<tr><td>guard</td><td>守卫</td><td></td></tr>
<tr><td><strong>H</strong></td><td></td><td></td></tr>
<tr><td>handle error</td><td>句柄错误</td><td></td></tr>
<tr><td>hash</td><td>哈希，哈希值，散列</td><td></td></tr>
<tr><td>hash map</td><td>散列映射，哈希表</td><td></td></tr>
<tr><td>heap</td><td>堆</td><td></td></tr>
<tr><td>hierarchy</td><td>层次，分层，层次结构</td><td></td></tr>
<tr><td>higher rank lifetime</td><td>高阶生命周期</td><td></td></tr>
<tr><td>higher rank trait bound</td><td>高阶特质约束</td><td></td></tr>
<tr><td>higher tank type</td><td>高阶类型</td><td></td></tr>
<tr><td>hygiene</td><td>卫生</td><td></td></tr>
<tr><td>hygienic macro system</td><td>卫生宏系统</td><td></td></tr>
<tr><td><strong>I</strong></td><td></td><td></td></tr>
<tr><td>ICE</td><td>编译内部错误</td><td>internal comppiler error 的缩写</td></tr>
<tr><td>immutable</td><td>不可变的</td><td></td></tr>
<tr><td>implement</td><td>实现</td><td></td></tr>
<tr><td>implementor</td><td>实现者</td><td></td></tr>
<tr><td>implicit</td><td>隐式</td><td></td></tr>
<tr><td>implicit discriminator</td><td>隐式的辨别值</td><td></td></tr>
<tr><td>implicit type conversion</td><td>隐式类型转换</td><td></td></tr>
<tr><td>import</td><td>导入</td><td></td></tr>
<tr><td>in assignment</td><td>在赋值（语句）</td><td></td></tr>
<tr><td>index</td><td>索引</td><td>英语复数形式：indices</td></tr>
<tr><td>infer</td><td>推导（动词）</td><td></td></tr>
<tr><td>inference</td><td>推导（名词）</td><td></td></tr>
<tr><td>inherited mutability</td><td>承袭可变性</td><td></td></tr>
<tr><td>inheritance</td><td>继承</td><td></td></tr>
<tr><td>integrated development <br>environment(IDE)</td><td>集成开发环境</td><td>中文著作中通常直接写成 IDE</td></tr>
<tr><td>integration-style test</td><td>集成测试</td><td></td></tr>
<tr><td>interior mutability</td><td>内部可变性</td><td></td></tr>
<tr><td>installer</td><td>安装程序，安装器</td><td></td></tr>
<tr><td>instance</td><td>实例</td><td></td></tr>
<tr><td>instance method</td><td>实例方法</td><td></td></tr>
<tr><td>integer</td><td>整型，整数</td><td></td></tr>
<tr><td>interact</td><td>相互作用，相互影响</td><td></td></tr>
<tr><td>interior mutability</td><td>内部可变性</td><td></td></tr>
<tr><td>intrinsic</td><td>固有的</td><td></td></tr>
<tr><td>invoke</td><td>调用</td><td></td></tr>
<tr><td>item</td><td>项，条目，项目</td><td></td></tr>
<tr><td>iterate</td><td>重复</td><td></td></tr>
<tr><td>iteration</td><td>迭代</td><td></td></tr>
<tr><td>iterator</td><td>迭代器</td><td></td></tr>
<tr><td>iterator adaptors</td><td>迭代器适配器</td><td></td></tr>
<tr><td>iterator invalidation</td><td>迭代器失效</td><td></td></tr>
<tr><td><strong>L</strong></td><td></td><td></td></tr>
<tr><td>LHS</td><td>左操作数</td><td>left-hand side 的非正式缩写，<br>与 RHS 相对</td></tr>
<tr><td>lender</td><td>借出者</td><td></td></tr>
<tr><td>library</td><td>库</td><td></td></tr>
<tr><td>lifetime</td><td>生存期/ 寿命 / 生命周期</td><td></td></tr>
<tr><td>lifetime elision</td><td>生命周期省略</td><td></td></tr>
<tr><td>link</td><td>链接</td><td></td></tr>
<tr><td>linked-list</td><td>链表</td><td></td></tr>
<tr><td>lint</td><td>（不译）</td><td>lint 英文本义是“纱布，绒毛”，此词在<br>计算机领域中表示程序代码中可疑和<br>不具结构性的片段，参见 <a href="https://en.wikipedia.org/wiki/Lint_%28software%29">Wikipedia</a></td></tr>
<tr><td>list</td><td>列表</td><td></td></tr>
<tr><td>listener</td><td>监听器</td><td></td></tr>
<tr><td>literal</td><td>数据，常量数据，字面值，字面量，<br>字面常量，字面上的</td><td>英文意思：字面意义的（内容）</td></tr>
<tr><td>LLVM</td><td>（不译）</td><td>Low Level Virtual Machine 的缩写，<br>是构建编译器的系统</td></tr>
<tr><td>loop</td><td>循环</td><td>作关键字时不译</td></tr>
<tr><td>low-level code</td><td>底层代码</td><td></td></tr>
<tr><td>low-level language</td><td>底层语言</td><td></td></tr>
<tr><td>l-value</td><td>左值</td><td></td></tr>
<tr><td><strong>M</strong></td><td></td><td></td></tr>
<tr><td>main function</td><td>main 函数，主函数</td><td></td></tr>
<tr><td>macro</td><td>宏</td><td></td></tr>
<tr><td>map</td><td>映射</td><td>一般不译</td></tr>
<tr><td>match guard</td><td>匹配守卫</td><td></td></tr>
<tr><td>memory</td><td>内存</td><td></td></tr>
<tr><td>memory leak</td><td>内存泄露</td><td></td></tr>
<tr><td>memory safe</td><td>内存安全</td><td></td></tr>
<tr><td>meta</td><td>原则，元</td><td></td></tr>
<tr><td>metadata</td><td>元数据</td><td></td></tr>
<tr><td>metaprogramming</td><td>元编程</td><td></td></tr>
<tr><td>metavariable</td><td>元变量</td><td></td></tr>
<tr><td>method call syntax</td><td>方法调用语法</td><td></td></tr>
<tr><td>method chaining</td><td>方法链</td><td></td></tr>
<tr><td>method definition</td><td>方法定义</td><td></td></tr>
<tr><td>modifier</td><td>修饰符</td><td></td></tr>
<tr><td>module</td><td>模块</td><td></td></tr>
<tr><td>monomorphization</td><td>单态</td><td>mono: one, morph: form</td></tr>
<tr><td>move</td><td>移动，转移</td><td>按照 Rust 所规定的内容，<br>英语单词 transfer 的意思<br>比 move 更贴合实际描述<br>参考：<a href="http://rustwiki.org/rust-by-example/scope/move.html">Rust by Example</a></td></tr>
<tr><td>move semantics</td><td>移动语义</td><td></td></tr>
<tr><td>mutability</td><td>可变性</td><td></td></tr>
<tr><td>mutable</td><td>可变</td><td></td></tr>
<tr><td>mutable reference</td><td>可变引用</td><td></td></tr>
<tr><td>multiple bounds</td><td>多重约束</td><td></td></tr>
<tr><td>mutiple patterns</td><td>多重模式</td><td></td></tr>
<tr><td><strong>N</strong></td><td></td><td></td></tr>
<tr><td>nest</td><td>嵌套</td><td></td></tr>
<tr><td>Nightly Rust</td><td>Rust 开发版</td><td>nightly本意是“每夜，每天晚上”，<br>指代码每天都更新</td></tr>
<tr><td>NLL</td><td>非词法生命周期</td><td>non lexical lifetime 的缩写，<br>一般不译</td></tr>
<tr><td>non-copy type</td><td>非复制类型</td><td></td></tr>
<tr><td>non-generic</td><td>非泛型</td><td></td></tr>
<tr><td>no-op</td><td>空操作，空运算</td><td>(此词出现在类型转换章节中）</td></tr>
<tr><td>non-commutative</td><td>非交换的</td><td></td></tr>
<tr><td>non-scalar cast</td><td>非标量转换</td><td></td></tr>
<tr><td>notation</td><td>符号，记号</td><td></td></tr>
<tr><td>numeric</td><td>数值，数字</td><td></td></tr>
<tr><td><strong>O</strong></td><td></td><td></td></tr>
<tr><td>optimization</td><td>优化</td><td></td></tr>
<tr><td>out-of-bounds accessing</td><td>越界访问</td><td></td></tr>
<tr><td>orphan rule</td><td>孤儿规则</td><td></td></tr>
<tr><td>overflow</td><td>溢出，越界</td><td></td></tr>
<tr><td>own</td><td>占有，拥有</td><td></td></tr>
<tr><td>owner</td><td>所有者，拥有者</td><td></td></tr>
<tr><td>ownership</td><td>所有权</td><td></td></tr>
<tr><td><strong>P</strong></td><td></td><td></td></tr>
<tr><td>package manager</td><td>包管理器，软件包管理器</td><td></td></tr>
<tr><td>panic</td><td>（不译）</td><td>此单词直接翻译是“恐慌”，<br>在 Rust 中用于不可恢复的错误处理</td></tr>
<tr><td>parameter</td><td>参量，形参，形式参量</td><td>不严格区分的话， argument（参数）和 <br> parameter（参量）可以互换地使用</td></tr>
<tr><td>parametric polymorphism</td><td>参数多态</td><td></td></tr>
<tr><td>parent scope</td><td>父级作用域</td><td></td></tr>
<tr><td>parentheses</td><td>小括号，包括“(”和“)”</td><td></td></tr>
<tr><td>parse</td><td>分析，解析</td><td></td></tr>
<tr><td>parser</td><td>（语法）分析器，解析器</td><td></td></tr>
<tr><td>pattern</td><td>模式</td><td></td></tr>
<tr><td>pattern match</td><td>模式匹配</td><td></td></tr>
<tr><td>phantom type</td><td>虚类型，虚位类型</td><td>phantom 相关的专有名词：<br>phantom bug 幻影指令<br>phantom power 幻象电源<br>参见：<a href="https://wiki.haskell.org/Phantom_type">Haskell</a>、<a href="https://en.wikibooks.org/wiki/Haskell/Phantom_types">Haskell/Phantom_type</a>、<br></td></tr>
<tr><td><a href="http://rustwiki.org/rust-by-example/generics/phantom.html">Rust/Phantom</a>、<a href="https://doc.rust-lang.org/std/marker/struct.PhantomData.html">stdlib/PhantomData</a></td><td></td><td></td></tr>
<tr><td>platform</td><td>平台</td><td></td></tr>
<tr><td>polymorphism</td><td>多态</td><td></td></tr>
<tr><td>powershell</td><td>（不译）</td><td>Windows 系统的一种命令行外壳程序<br>和脚本环境</td></tr>
<tr><td>possibility of absence</td><td>不存在的可能性</td><td></td></tr>
<tr><td>precede</td><td>预先？，在...发生（或出现）</td><td></td></tr>
<tr><td>prelude</td><td>（不译）</td><td>预先导入模块，英文本意：序曲，前奏</td></tr>
<tr><td>primitive types</td><td>原生类型，基本类型，简单类型</td><td></td></tr>
<tr><td>print</td><td>打印</td><td></td></tr>
<tr><td>process</td><td>进程</td><td></td></tr>
<tr><td>procedural macros</td><td>过程宏，程序宏</td><td></td></tr>
<tr><td>project</td><td>项目，工程</td><td></td></tr>
<tr><td>prototype</td><td>原型</td><td></td></tr>
<tr><td><strong>R</strong></td><td></td><td></td></tr>
<tr><td>race condition</td><td>竞态条件</td><td></td></tr>
<tr><td>RAII</td><td>资源获取即初始化（一般不译）</td><td>resource acquisition is initialization 的缩写</td></tr>
<tr><td>range</td><td>区间，范围</td><td></td></tr>
<tr><td>range expression</td><td>区间表达式</td><td></td></tr>
<tr><td>raw identifier</td><td>原始标识符</td><td></td></tr>
<tr><td>raw pointer</td><td>原始指针，裸指针</td><td></td></tr>
<tr><td>RC</td><td>引用计数</td><td>reference counted</td></tr>
<tr><td>Reader</td><td>读取器</td><td></td></tr>
<tr><td>recursive macro</td><td>递归宏</td><td></td></tr>
<tr><td>reference</td><td>引用</td><td></td></tr>
<tr><td>reference cycle</td><td>引用循环</td><td></td></tr>
<tr><td>release</td><td>发布</td><td></td></tr>
<tr><td>resource</td><td>资源</td><td></td></tr>
<tr><td>resource leak</td><td>资源泄露</td><td></td></tr>
<tr><td>RHS</td><td>右操作数</td><td>right-hand side 的非正式缩写，<br>与 LHS 相对</td></tr>
<tr><td>root directory</td><td>根目录</td><td></td></tr>
<tr><td>runtime</td><td>运行时</td><td></td></tr>
<tr><td>runtime behavior</td><td>运行时行为</td><td></td></tr>
<tr><td>runtime overhead</td><td>运行时开销</td><td></td></tr>
<tr><td>Rust</td><td>（不译）</td><td>一种编程语言</td></tr>
<tr><td>Rustacean</td><td>（不译）</td><td>编写 Rust 的程序员或爱好者的通称</td></tr>
<tr><td>rustc</td><td>（不译）</td><td>Rust 语言编译器</td></tr>
<tr><td>r-value</td><td>右值</td><td></td></tr>
<tr><td><strong>S</strong></td><td></td><td></td></tr>
<tr><td>scalar</td><td>标量，数量</td><td></td></tr>
<tr><td>schedule</td><td>调度</td><td></td></tr>
<tr><td>scope</td><td>作用域</td><td></td></tr>
<tr><td>screen</td><td>屏幕</td><td></td></tr>
<tr><td>script</td><td>脚本</td><td></td></tr>
<tr><td>semicolon</td><td>分号，“;”</td><td></td></tr>
<tr><td>self</td><td>自身，作关键字时不译</td><td></td></tr>
<tr><td>shadow</td><td>遮蔽，隐蔽，隐藏，覆盖</td><td></td></tr>
<tr><td>shallow copy</td><td>浅拷贝，浅复制</td><td></td></tr>
<tr><td>signature</td><td>标记</td><td></td></tr>
<tr><td>slice</td><td>切片</td><td></td></tr>
<tr><td>snake case</td><td>蛇形命名</td><td>参见：<a href="https://en.wikipedia.org/wiki/Snake_case">Snake case</a></td></tr>
<tr><td>source file</td><td>源文件</td><td></td></tr>
<tr><td>source code</td><td>源代码</td><td></td></tr>
<tr><td>specialization</td><td>泛型特化</td><td></td></tr>
<tr><td>square</td><td>平方，二次方，二次幂</td><td></td></tr>
<tr><td>square brackets</td><td>中括号，“[”和“]”</td><td></td></tr>
<tr><td>src</td><td>（不译）</td><td>source 的缩写，指源代码</td></tr>
<tr><td>stack</td><td>栈</td><td></td></tr>
<tr><td>stack unwind</td><td>栈解开、栈展开</td><td></td></tr>
<tr><td>statement</td><td>语句</td><td></td></tr>
<tr><td>statically allocated</td><td>静态分配</td><td></td></tr>
<tr><td>statically allocated string</td><td>静态分配的字符串</td><td></td></tr>
<tr><td>statically dispatch</td><td>静态分发</td><td></td></tr>
<tr><td>static method</td><td>静态方法</td><td></td></tr>
<tr><td>string</td><td>字符串</td><td></td></tr>
<tr><td>string literal</td><td>字符串常量</td><td></td></tr>
<tr><td>string slices</td><td>字符串片段</td><td></td></tr>
<tr><td>stringify</td><td>字符串化</td><td></td></tr>
<tr><td>subscript notation</td><td>下标</td><td></td></tr>
<tr><td>sugar</td><td>糖</td><td></td></tr>
<tr><td>super</td><td>父级，作关键字时不译</td><td></td></tr>
<tr><td>syntax context</td><td>语法上下文</td><td></td></tr>
<tr><td>systems programming language</td><td>系统级编程语言</td><td></td></tr>
<tr><td><strong>T</strong></td><td></td><td></td></tr>
<tr><td>tagged union</td><td>标记联合</td><td></td></tr>
<tr><td>target triple</td><td>多层次指标，三层/重 指标/目标</td><td>triple 本义是“三”，但此处虚指“多”，<br>此词翻译需要更多讨论</td></tr>
<tr><td>terminal</td><td>终端</td><td></td></tr>
<tr><td>testing</td><td>测试</td><td></td></tr>
<tr><td>testsuit</td><td>测试套件</td><td></td></tr>
<tr><td>the least significant bit (LSB)</td><td>最低数字位</td><td></td></tr>
<tr><td>the most significant bit (MSB)</td><td>最高数字位</td><td></td></tr>
<tr><td>thread</td><td>线程</td><td></td></tr>
<tr><td>TOML</td><td>（不译）</td><td>Tom's Obvious, Minimal Language <br>的缩写，一种配置语言</td></tr>
<tr><td>token tree</td><td>令牌树？</td><td>待进一步斟酌</td></tr>
<tr><td>trait</td><td>特质</td><td>其字面上有“特性，特征”之意</td></tr>
<tr><td>trait bound</td><td>特质约束</td><td>bound 有“约束，限制，限定”之意</td></tr>
<tr><td>trait object</td><td>特质对象</td><td></td></tr>
<tr><td>transmute</td><td>（不译）</td><td>其字面上有“变化，变形，变异”之意，<br>不作翻译</td></tr>
<tr><td>trivial</td><td>平凡的</td><td></td></tr>
<tr><td>troubleshooting</td><td>疑难解答，故障诊断，<br>故障排除，故障分析</td><td></td></tr>
<tr><td>tuple</td><td>元组</td><td></td></tr>
<tr><td>two's complement</td><td>补码，二补数</td><td></td></tr>
<tr><td>two-word object</td><td>双字对象</td><td></td></tr>
<tr><td>type annotation</td><td>类型标注</td><td></td></tr>
<tr><td>type erasure</td><td>类型擦除</td><td></td></tr>
<tr><td>type inference</td><td>类型推导</td><td></td></tr>
<tr><td>type inference engine</td><td>类型推导引擎</td><td></td></tr>
<tr><td>type parameter</td><td>类型参量</td><td></td></tr>
<tr><td>type placeholder</td><td>类型占位符</td><td></td></tr>
<tr><td>type signature</td><td>类型标记</td><td></td></tr>
<tr><td><strong>U</strong></td><td></td><td></td></tr>
<tr><td>undefined behavior</td><td>未定义行为</td><td></td></tr>
<tr><td>uninstall</td><td>卸载</td><td></td></tr>
<tr><td>unit-like struct</td><td>类单元结构体</td><td></td></tr>
<tr><td>unit struct</td><td>单元结构体</td><td></td></tr>
<tr><td>&quot;unit-style&quot; tests</td><td>单元测试</td><td></td></tr>
<tr><td>unit test</td><td>单元测试</td><td></td></tr>
<tr><td>unit type</td><td>单元类型</td><td></td></tr>
<tr><td>universal function call syntax <br>(UFCS)</td><td>通用函数调用语法</td><td></td></tr>
<tr><td>unsized types</td><td>不定长类型</td><td></td></tr>
<tr><td>unwind</td><td>展开</td><td></td></tr>
<tr><td>unwrap</td><td>解包</td><td>暂译！</td></tr>
<tr><td><strong>V</strong></td><td></td><td></td></tr>
<tr><td>variable binding</td><td>变量绑定</td><td></td></tr>
<tr><td>variable shadowing</td><td>变量遮蔽，变量隐蔽,<br>变量隐藏，变量覆盖</td><td></td></tr>
<tr><td>variable capture</td><td>变量捕获</td><td></td></tr>
<tr><td>variant</td><td>变量</td><td></td></tr>
<tr><td>vector</td><td>（动态数组，一般不译）</td><td>vector 本义是“向量”</td></tr>
<tr><td>visibility</td><td>可见性</td><td></td></tr>
<tr><td>vtable</td><td>虚表</td><td></td></tr>
<tr><td><strong>W</strong></td><td></td><td></td></tr>
<tr><td>where clause</td><td>where 子句，where 从句，where 分句</td><td>在数据库的官方手册中多翻译成“子句”，英语语法中翻译成“从句”</td></tr>
<tr><td>wrap</td><td>包裹</td><td>暂译！</td></tr>
<tr><td>wrapped</td><td>装包</td><td></td></tr>
<tr><td>wrapper</td><td>装包</td><td></td></tr>
<tr><td><strong>Y</strong></td><td></td><td></td></tr>
<tr><td>yield</td><td>产生(收益、效益等)，产出，提供</td><td></td></tr>
<tr><td><strong>Z</strong></td><td></td><td></td></tr>
<tr><td>zero-cost abstractions</td><td>零开销抽象</td><td></td></tr>
<tr><td>zero-width space(ZWSP)</td><td>零宽空格</td><td></td></tr>
</tbody></table>
<p><strong>参考</strong></p>
<p><a href="https://github.com/rust-lang-cn/english-chinese-glossary-of-rust/blob/master/rust-glossary.md">Rust 语言术语中英文对照表</a></p>
<h2><a class="header" href="#编译器相关术语表" id="编译器相关术语表">编译器相关术语表</a></h2>
<table><thead><tr><th>术语</th><th>中文</th><th>意义</th></tr></thead><tbody>
<tr><td><span id="arena">arena/arena allocation</span>  </td><td><span id="arena">竞技场分配</span>  </td><td>arena 是一个大内存缓冲区，从中可以进行其他内存分配，这种分配方式称为竞技场分配。</td></tr>
<tr><td><span id="ast">AST</span>                       </td><td><span id="ast">抽象语法树</span>  </td><td>由<code>rustc_ast</code> crate 产生的抽象语法树。</td></tr>
<tr><td><span id="binder">binder</span>                 </td><td><span id="binder">绑定器</span>  </td><td>绑定器是声明变量和类型的地方。例如，<code>&lt;T&gt;</code> 是<code>fn foo&lt;T&gt;(..)</code>中泛型类型参数 <code>T</code>的绑定器，以及 |<code>a</code>|<code> ...</code>  是 参数<code>a</code>的绑定器。</td></tr>
<tr><td><span id="body-id">BodyId</span>                </td><td><span id="body-id"> 主体ID</span>  </td><td>一个标识符，指的是crate 中的一个特定主体（函数或常量的定义）。</td></tr>
<tr><td><span id="bound-var">bound variable</span>      </td><td><span id="bound-var">绑定变量</span>      </td><td>&quot;绑定变量 &quot;是在表达式/术语中声明的变量。例如，变量<code>a</code>被绑定在闭包表达式中|<code>a</code>|<code> a * 2</code>。</td></tr>
<tr><td><span id="codegen">codegen</span>               </td><td><span id="codegen">代码生成</span>               </td><td>由 MIR 转译为 LLVM IR。</td></tr>
<tr><td><span id="codegen-unit">codegen unit</span>     </td><td><span id="codegen-unit">代码生成单元</span>     </td><td>当生成LLVM IR时，编译器将Rust代码分成若干个代码生成单元（有时缩写为CGU）。这些单元中的每一个都是由LLVM独立处理的，实现了并行化。它们也是增量编译的单位。</td></tr>
<tr><td><span id="completeness">completeness</span>     </td><td><span id="completeness">完整性</span>     </td><td>类型理论中的一个技术术语，它意味着每个类型安全的程序也会进行类型检查。同时拥有健全性（soundness）和完整性（completeness）是非常困难的，而且通常健全性（soundness）更重要。</td></tr>
<tr><td><span id="cfg">control-flow graph</span>        </td><td><span id="cfg">控制流图</span>        </td><td>程序的控制流表示。</td></tr>
<tr><td><span id="ctfe">CTFE</span>                     </td><td><span id="ctfe">编译时函数求值</span>                     </td><td>编译时函数求值（Compile-Time Function Evaluation）的简称，是指编译器在编译时计算 &quot;const fn &quot;的能力。这是编译器常量计算系统的一部分。</td></tr>
<tr><td><span id="cx">cx</span>                         </td><td><span id="cx">上下文</span>                         </td><td>Rust 编译器内倾向于使用 &quot;cx &quot;作为上下文的缩写。另见 &quot;tcx&quot;、&quot;infcx &quot;等。</td></tr>
<tr><td><span id="ctxt">ctxt</span>                     </td><td><span id="ctxt">上下文（另一个缩写）</span>                     </td><td>我们也使用 &quot;ctxt &quot;作为上下文的缩写，例如， <a href="safe-guides/Appendix/terms.html#TyCtxt"><code>TyCtxt</code></a>，以及 <a href="safe-guides/Appendix/terms.html#cx">cx</a> 或 <a href="safe-guides/Appendix/terms.html#tcx">tcx</a>。</td></tr>
<tr><td><span id="dag">DAG</span>                       </td><td><span id="dag">有向无环图</span>                       </td><td>在编译过程中，一个有向无环图被用来跟踪查询之间的依赖关系</td></tr>
<tr><td><span id="data-flow">data-flow analysis</span>  </td><td><span id="data-flow">数据流分析</span>  </td><td>静态分析，找出程序控制流中每一个点的属性。</td></tr>
<tr><td><span id="debruijn">DeBruijn Index</span>       </td><td><span id="debruijn">德布鲁因索引</span>       </td><td>一种只用整数来描述一个变量被绑定的绑定器的技术。它的好处是，在变量重命名下，它是不变的。</td></tr>
<tr><td><span id="def-id">DefId</span>                  </td><td><span id="def-id">定义Id</span>                  </td><td>一个识别定义的索引（见<code>rustc_middle/src/hir/def_id.rs</code>）。<code>DefPath</code>的唯一标识。</td></tr>
<tr><td><span id="discriminant">discriminant</span>     </td><td><span id="discriminant">判别式</span>     </td><td>与枚举变体或生成器状态相关的基础值，以表明它是 &quot;激活的（avtive）&quot;（但不要与它的<a href="safe-guides/Appendix/terms.html#variant-idx">&quot;变体索引&quot;</a>混淆）。在运行时，激活变体的判别值被编码在<a href="safe-guides/Appendix/terms.html#tag">tag</a>中。</td></tr>
<tr><td><span id="double-ptr">double pointer</span>     </td><td><span id="double-ptr">双指针</span>     </td><td>一个带有额外元数据的指针。同指「胖指针」。</td></tr>
<tr><td><span id="drop-glue">drop glue</span>           </td><td><span id="drop-glue">drop胶水</span>           </td><td>(内部）编译器生成的指令，处理调用数据类型的析构器（<code>Drop</code>）。</td></tr>
<tr><td><span id="dst">DST</span>                       </td><td><span id="dst">DST</span>                       </td><td>Dynamically-Sized Type的缩写，这是一种编译器无法静态知道内存大小的类型（例如：<code>str'或</code>[u8]<code>）。这种类型没有实现</code>Sized<code>，不能在栈中分配。它们只能作为结构中的最后一个字段出现。它们只能在指针后面使用（例如：</code>&amp;str<code>或</code>&amp;[u8]`）。</td></tr>
<tr><td><span id="ebl">early-bound lifetime</span>      </td><td><span id="ebl">早绑定生存期</span>      </td><td>一个在其定义处被替换的生存期区域（region）。绑定在一个项目的<code>Generics'中，并使用</code>Substs'进行替换。与<strong>late-bound lifetime</strong>形成对比。</td></tr>
<tr><td><span id="empty-type">empty type</span>         </td><td><span id="empty-type">空类型</span>         </td><td>参考 &quot;uninhabited type&quot;.</td></tr>
<tr><td><span id="fat-ptr">fat pointer</span>           </td><td><span id="fat-ptr">胖指针</span>           </td><td>一个两字（word）的值，携带着一些值的地址，以及一些使用该值所需的进一步信息。Rust包括两种 &quot;胖指针&quot;：对切片（slice）的引用和特质（trait）对象。对切片的引用带有切片的起始地址和它的长度。特质对象携带一个值的地址和一个指向适合该值的特质实现的指针。&quot;胖指针 &quot;也被称为 &quot;宽指针&quot;，和 &quot;双指针&quot;。</td></tr>
<tr><td><span id="free-var">free variable</span>        </td><td><span id="free-var">自由变量</span>        </td><td>自由变量 是指没有被绑定在表达式或术语中的变量；</td></tr>
<tr><td><span id="generics">generics</span>             </td><td><span id="generics">泛型</span>             </td><td>通用类型参数集。</td></tr>
<tr><td><span id="hir">HIR</span>                       </td><td><span id="hir">高级中间语言</span>                       </td><td>高级中间语言，通过对AST进行降级（lowering）和去糖（desugaring）而创建。</td></tr>
<tr><td><span id="hir-id">HirId</span>                  </td><td><span id="hir-id">HirId</span>                  </td><td>通过结合“def-id”和 &quot;intra-definition offset&quot;来识别HIR中的一个特定节点。</td></tr>
<tr><td><span id="hir-map">HIR map</span>               </td><td><span id="hir-map">HIR map</span>               </td><td>通过<code>tcx.hir()</code>访问的HIR Map，可以让你快速浏览HIR并在各种形式的标识符之间进行转换。</td></tr>
<tr><td><span id="ice">ICE</span>                       </td><td><span id="ice">ICE</span>                       </td><td>内部编译器错误的简称，这是指编译器崩溃的情况。</td></tr>
<tr><td><span id="ich">ICH</span>                       </td><td><span id="ich">ICH</span>                       </td><td>增量编译哈希值的简称，它们被用作HIR和crate metadata等的指纹，以检查是否有变化。这在增量编译中是很有用的，可以查看crate的一部分是否发生了变化，应该重新编译。</td></tr>
<tr><td><span id="infcx">infcx</span>                   </td><td><span id="infcx">类型推导上下文</span>                   </td><td>类型推导上下文（<code>InferCtxt</code>）。</td></tr>
<tr><td><span id="inf-var">inference variable</span>    </td><td><span id="inf-var">推导变量</span>    </td><td>在进行类型或区域推理时，&quot;推导变量 &quot;是一种特殊的类型/区域，代表你试图推理的内容。想想代数中的X。例如，如果我们试图推断一个程序中某个变量的类型，我们就创建一个推导变量来代表这个未知的类型。</td></tr>
<tr><td><span id="intern">intern</span>                 </td><td><span id="intern">intern</span>                 </td><td>intern是指存储某些经常使用的常量数据，如字符串，然后用一个标识符（如`符号'）而不是数据本身来引用这些数据，以减少内存的使用和分配的次数。</td></tr>
<tr><td><span id="intrinsic">intrinsic</span>           </td><td><span id="intrinsic">内部函数</span>           </td><td>内部函数是在编译器本身中实现的特殊功能，但向用户暴露（通常是不稳定的）。它们可以做神奇而危险的事情。</td></tr>
<tr><td><span id="ir">IR</span>                         </td><td><span id="ir">IR</span>                         </td><td>Intermediate Representation的简称，是编译器中的一个通用术语。在编译过程中，代码被从原始源码（ASCII文本）转换为各种IR。在Rust中，这些主要是HIR、MIR和LLVM IR。每种IR都适合于某些计算集。例如，MIR非常适用于借用检查器，LLVM IR非常适用于codegen，因为LLVM接受它。</td></tr>
<tr><td><span id="irlo">IRLO</span>                     </td><td><span id="irlo">IRLO</span>                     </td><td><code>IRLO</code>或<code>irlo</code>有时被用作<a href="https://internals.rust-lang.org">internals.rust-lang.org</a>的缩写。</td></tr>
<tr><td><span id="item">item</span>                     </td><td><span id="item">语法项</span>                     </td><td>语言中的一种 &quot;定义&quot;，如静态、常量、使用语句、模块、结构等。具体来说，这对应于 &quot;item&quot;类型。</td></tr>
<tr><td><span id="lang-item">lang item</span>           </td><td><span id="lang-item">语言项</span>           </td><td>代表语言本身固有的概念的项目，如特殊的内置特质，如<code>同步</code>和<code>发送</code>；或代表操作的特质，如<code>添加</code>；或由编译器调用的函数。</td></tr>
<tr><td><span id="lbl">late-bound lifetime</span>       </td><td><span id="lbl">晚绑定生存期</span>       </td><td>一个在其调用位置被替换的生存期区域。绑定在HRTB中，由编译器中的特定函数替代，如<code>liberate_late_bound_regions</code>。与<strong>早绑定的生存期</strong>形成对比。</td></tr>
<tr><td><span id="local-crate">local crate</span>       </td><td><span id="local-crate">本地crate</span>       </td><td>目前正在编译的crate。这与 &quot;上游crate&quot;相反，后者指的是本地crate的依赖关系。</td></tr>
<tr><td><span id="lto">LTO</span>                       </td><td><span id="lto">LTO</span>                       </td><td>链接时优化（Link-Time Optimizations）的简称，这是LLVM提供的一套优化，在最终二进制文件被链接之前进行。这些优化包括删除最终程序中从未使用的函数，例如。_<a href="https://clang.llvm.org/docs/ThinLTO.html">ThinLTO</a>_是LTO的一个变种，旨在提高可扩展性和效率，但可能牺牲了一些优化。</td></tr>
<tr><td><span id="llvm">LLVM</span>                   </td><td><span id="llvm">LLVM</span>                   </td><td>(实际上不是一个缩写 :P) 一个开源的编译器后端。它接受LLVM IR并输出本地二进制文件。然后，各种语言（例如Rust）可以实现一个编译器前端，输出LLVM IR，并使用LLVM编译到所有LLVM支持的平台。</td></tr>
<tr><td><span id="memoization">memoization</span>       </td><td><span id="memoization">memoization</span>       </td><td>储存（纯）计算结果（如纯函数调用）的过程，以避免在未来重复计算。这通常是执行速度和内存使用之间的权衡。</td></tr>
<tr><td><span id="mir">MIR</span>                       </td><td><span id="mir">中级中间语言</span>                       </td><td>在类型检查后创建的中级中间语言，供borrowck和codegen使用。</td></tr>
<tr><td><span id="miri">miri</span>                     </td><td><span id="miri">mir解释器</span>                     </td><td>MIR的一个解释器，用于常量计算。</td></tr>
<tr><td><span id="mono">monomorphization</span>         </td><td><span id="mono">单态化</span>         </td><td>采取类型和函数的通用实现并将其与具体类型实例化的过程。例如，在代码中可能有<code>Vec&lt;T&gt;</code>，但在最终的可执行文件中，将为程序中使用的每个具体类型有一个<code>Vec</code>代码的副本（例如，<code>Vec&lt;usize&gt;</code>的副本，<code>Vec&lt;MyStruct&gt;</code>的副本，等等）。</td></tr>
<tr><td><span id="normalize">normalize</span>           </td><td><span id="normalize">归一化</span>           </td><td>转换为更标准的形式的一般术语，但在rustc的情况下，通常指的是关联类型归一化。</td></tr>
<tr><td><span id="newtype">newtype</span>               </td><td><span id="newtype">newtype</span>               </td><td>对其他类型的封装（例如，<code>struct Foo(T)</code>是<code>T</code>的一个 &quot;新类型&quot;）。这在Rust中通常被用来为索引提供一个更强大的类型。</td></tr>
<tr><td><span id="niche">niche</span>                   </td><td><span id="niche">利基</span>                   </td><td>一个类型的无效位模式<em>可用于</em>布局优化。有些类型不能有某些位模式。例如，&quot;非零*&quot;整数或引用&quot;&amp;T &quot;不能用0比特串表示。这意味着编译器可以通过利用无效的 &quot;利基值 &quot;来进行布局优化。这方面的一个应用实例是<a href="https://rust-lang.github.io/unsafe-code-guidelines/layout/enums.html#discriminant-elision-on-option-like-enums"><em>Discriminant elision on <code>Option</code>-like enums</em></a>，它允许使用一个类型的niche作为一个<code>enum</code>的<a href="safe-guides/Appendix/terms.html#tag">&quot;标签&quot;</a>，而不需要一个单独的字段。</td></tr>
<tr><td><span id="nll">NLL</span>                       </td><td><span id="nll">NLL</span>                       </td><td>这是非词法作用域生存期的简称，它是对Rust的借用系统的扩展，使其基于控制流图。</td></tr>
<tr><td><span id="node-id">node-id or NodeId</span>     </td><td><span id="node-id">node-id or NodeId</span>     </td><td>识别AST或HIR中特定节点的索引；逐渐被淘汰，被<code>HirId</code>取代。</td></tr>
<tr><td><span id="obligation">obligation</span>         </td><td><span id="obligation">obligation</span>         </td><td>必须由特质系统证明的东西。</td></tr>
<tr><td><span id="placeholder">placeholder</span>       </td><td><span id="placeholder">placeholder</span>       </td><td><strong>注意：skolemization被placeholder废弃</strong>一种处理围绕 &quot;for-all &quot;类型的子类型的方法（例如，<code>for&lt;'a&gt; fn(&amp;'a u32)</code>），以及解决更高等级的trait边界（例如，<code>for&lt;'a&gt; T: Trait&lt;'a&gt;</code>）。</td></tr>
<tr><td><span id="point">point</span>                   </td><td><span id="point">point</span>                   </td><td>在NLL分析中用来指代MIR中的某个特定位置；通常用来指代控制流图中的一个节点。</td></tr>
<tr><td><span id="polymorphize">polymorphize</span>     </td><td><span id="polymorphize">多态化</span>     </td><td>一种避免不必要的单态化的优化。</td></tr>
<tr><td><span id="projection">projection</span>         </td><td><span id="projection">投影</span>         </td><td>一个 &quot;相对路径 &quot;的一般术语，例如，<code>x.f</code>是一个 &quot;字段投影&quot;，而<code>T::Item</code>是一个&quot;关联类型投影&quot;</td></tr>
<tr><td><span id="pc">promoted constants</span>         </td><td><span id="pc">常量提升</span>         </td><td>从函数中提取的常量，并提升到静态范围</td></tr>
<tr><td><span id="provider">provider</span>             </td><td><span id="provider">provider</span>             </td><td>执行查询的函数。</td></tr>
<tr><td><span id="quantified">quantified</span>         </td><td><span id="quantified">量化</span>         </td><td>在数学或逻辑学中，存在量词和普遍量词被用来提出诸如 &quot;是否有任何类型的T是真的？&quot;或 &quot;这对所有类型的T都是真的吗？&quot;这样的问题</td></tr>
<tr><td><span id="query">query</span>                   </td><td><span id="query">查询</span>                   </td><td>编译过程中的一个子计算。查询结果可以缓存在当前会话中，也可以缓存到磁盘上，用于增量编译。</td></tr>
<tr><td><span id="recovery">recovery</span>             </td><td><span id="recovery">恢复</span>             </td><td>恢复是指在解析过程中处理无效的语法（例如，缺少逗号），并继续解析AST。这可以避免向用户显示虚假的错误（例如，当结构定义包含错误时，显示 &quot;缺少字段 &quot;的错误）。</td></tr>
<tr><td><span id="region">region</span>                 </td><td><span id="region">区域</span>                 </td><td>和生存期精彩使用的另一个术语。</td></tr>
<tr><td><span id="rib">rib</span>                       </td><td><span id="rib">rib</span>                       </td><td>名称解析器中的一个数据结构，用于跟踪名称的单一范围。</td></tr>
<tr><td><span id="scrutinee">scrutinee</div>            </td><td><span id="scrutinee">审查对象</div>            </td><td>审查对象是在<code>match</code>表达式和类似模式匹配结构中被匹配的表达式。例如，在<code>match x { A =&gt; 1, B =&gt; 2 }</code>中，表达式<code>x</code>是被审查者。</td></tr>
<tr><td><span id="sess">sess</span>                     </td><td><span id="sess">sess</span>                     </td><td>编译器会话，它存储了整个编译过程中使用的全局数据</td></tr>
<tr><td><span id="side-tables">side tables</span>       </td><td><span id="side-tables">side tables</span>       </td><td>由于AST和HIR一旦创建就不可改变，我们经常以哈希表的形式携带关于它们的额外信息，并以特定节点的ID为索引。</td></tr>
<tr><td><span id="sigil">sigil</span>                   </td><td><span id="sigil">符号</span>                   </td><td>就像一个关键词，但完全由非字母数字的标记组成。例如，<code>&amp;</code>是引用的标志。</td></tr>
<tr><td><span id="soundness">soundness</span>           </td><td><span id="soundness">健全性</span>           </td><td>类型理论中的一个技术术语。粗略的说，如果一个类型系统是健全的，那么一个进行类型检查的程序就是类型安全的。也就是说，人们永远不可能（在安全的Rust中）把一个值强加到一个错误类型的变量中。</td></tr>
<tr><td><span id="span">span</span>                     </td><td><span id="span">span</span>                     </td><td>用户的源代码中的一个位置，主要用于错误报告。这就像一个文件名/行号/列的立体元组：它们携带一个开始/结束点，也跟踪宏的扩展和编译器去糖。所有这些都被装在几个字节里（实际上，它是一个表的索引）。</td></tr>
<tr><td><span id="substs">substs</span>                 </td><td><span id="substs">替换</span>                 </td><td>给定的通用类型或项目的替换（例如，<code>HashMap&lt;i32, u32&gt;</code>中的<code>i32'、</code>u32'）。</td></tr>
<tr><td><span id="sysroot">sysroot</span>               </td><td><span id="sysroot">sysroot</span>               </td><td>用于编译器在运行时加载的构建工件的目录。</td></tr>
<tr><td><span id="tag">tag</span>                       </td><td><span id="tag">tag</span>                       </td><td>枚举/生成器的 &quot;标签 &quot;编码激活变体/状态的判别式(discriminant)。 标签可以是 &quot;直接的&quot;（简单地将判别式存储在一个字段中）或使用&quot;利基&quot;。</td></tr>
<tr><td><span id="tcx">tcx</span>                       </td><td><span id="tcx">tcx</span>                       </td><td>&quot;类型化上下文&quot;（<code>TyCtxt</code>），编译器的主要数据结构。</td></tr>
<tr><td><span id="lifetime-tcx">'tcx</span>           </td><td><span id="lifetime-tcx">'tcx</span>           </td><td><code>TyCtxt'所使用的分配区域的生存期。在编译过程中，大多数数据都会使用这个生存期，但HIR数据除外，它使用</code>'hir`生存期。</td></tr>
<tr><td><span id="token">token</span>                   </td><td><span id="token">词条</span>                   </td><td>解析的最小单位。词条是在词法运算后产生的</td></tr>
<tr><td><span id="tls">TLS</span>                     </td><td><span id="tls">TLS</span>                     </td><td>线程本地存储。变量可以被定义为每个线程都有自己的副本（而不是所有线程都共享该变量）。这与LLVM有一些相互作用。并非所有平台都支持TLS。</td></tr>
<tr><td><span id="trait-ref">trait reference</span>     </td><td><span id="trait-ref">trait 引用</span>     </td><td>一个特质的名称，以及一组合适的输入类型/生存期。</td></tr>
<tr><td><span id="trans">trans</span>                   </td><td><span id="trans">trans</span>                   </td><td>是 &quot;转译&quot;的简称，是将MIR转译成LLVM IR的代码。已经重命名为codegen。</td></tr>
<tr><td><span id="ty">Ty</span>                       </td><td><span id="ty">Ty</span>                       </td><td>一个类型的内部表示。</td></tr>
<tr><td><span id="tyctxt">TyCtxt</span>                 </td><td><span id="tyctxt">TyCtxt</span>                 </td><td>在代码中经常被称为tcx的数据结构，它提供对会话数据和查询系统的访问。</td></tr>
<tr><td><span id="ufcs">UFCS</span>                     </td><td><span id="ufcs">UFCS</span>                     </td><td>通用函数调用语法（Universal Function Call Syntax）的简称，这是一种调用方法的明确语法。</td></tr>
<tr><td><span id="ut">uninhabited type</span>           </td><td><span id="ut">孤类型</span>           </td><td>一个没有值的类型。这与ZST不同，ZST正好有一个值。一个孤类型的例子是<code>enum Foo {}</code>，它没有变体，所以，永远不能被创建。编译器可以将处理孤类型的代码视为死代码，因为没有这样的值可以操作。<code>！</code>（从未出现过的类型）是一个孤类型。孤类型也被称为 &quot;空类型&quot;。</td></tr>
<tr><td><span id="upvar">upvar</span>                   </td><td><span id="upvar">upvar</span>                   </td><td>一个闭合体从闭合体外部捕获的变量</td></tr>
<tr><td><span id="variance">variance</span>             </td><td><span id="variance">型变</span>             </td><td>确定通用类型/寿命参数的变化如何影响子类型；例如，如果<code>T</code>是<code>U</code>的子类型，那么<code>Vec&lt;T&gt;</code>是<code>Vec&lt;U&gt;</code>的子类型，因为<code>Vec</code>在其通用参数中是协变的。</td></tr>
<tr><td><span id="variant-idx">variant index</span>     </td><td><span id="variant-idx">变体索引</span>     </td><td>在一个枚举中，通过给它们分配从0开始的索引来识别一个变体。这纯粹是内部的，不要与&quot;判别式&quot;相混淆，后者可以被用户覆盖（例如，<code>enum Bool { True = 42, False = 0 }</code>）。</td></tr>
<tr><td><span id="wide-ptr">wide pointer</span>         </td><td><span id="wide-ptr">宽指针</span>         </td><td>一个带有额外元数据的指针。</td></tr>
<tr><td><span id="zst">ZST</span>                       </td><td><span id="zst">ZST</span>                       </td><td>零大小类型。这种类型，其值的大小为0字节。由于<code>2^0 = 1</code>，这种类型正好有一个值。例如，<code>()</code>（单位）是一个ZST。<code>struct Foo;</code>也是一个ZST。编译器可以围绕ZST做一些很好的优化。</td></tr>
</tbody></table>
<p><strong>参考</strong></p>
<p><a href="https://rustcrustc.github.io/rustc-dev-guide-zh/appendix/glossary.html">Rust 编译器内部术语中英文对照表</a></p>
<h1><a class="header" href="#模版" id="模版">模版</a></h1>
<p>这里记录一些 rustfmt 和 clippy 等相关工具等配置文件模版。</p>
<ul>
<li><a href="safe-guides/Appendix/templates/./rustfmt.toml.html">rustfmt</a></li>
<li><a href="safe-guides/Appendix/templates/./clippy.toml.html">clippy</a></li>
<li><a href="safe-guides/Appendix/templates/./deny.toml.html">deny</a></li>
</ul>
<h1><a class="header" href="#rustfmt-模板" id="rustfmt-模板">Rustfmt 模板</a></h1>
<p>为了方便 Rust 开发者，这里提供一个 Rustfmt 的模板，以供参考。</p>
<p>以下内容可以放到 <code>rustfmt.toml</code> 或 <code>.rustfmt.toml</code> 文件中。因为部分选项还未稳定，所以要使用 <code>cargo +nightly fmt</code> 执行。</p>
<p>很多选项都是默认的，无需配置。以下配置的都不是默认值。</p>
<pre><code class="language-toml"># 万一你要使用 rustfmt 2.0 就需要指定这个·
version = &quot;Two&quot;

# 统一管理宽度设置，但不包含 comment_width
use_small_heuristics=&quot;MAX&quot;
# 使多个标识符定义保持对齐风格，代码看上去可以非常工整
indent_style=&quot;Visual&quot; 
# 设置让自定义具有判别式的枚举体按等号对齐的宽度
enum_discrim_align_threshold = 10 
# 在match分支中，如果包含了块，也需要加逗号以示分隔
match_block_trailing_comma=true
# 自动将同一个 crate 的模块导入合并到一起
imports_granularity=&quot;Crate&quot; 
# StdExternalCrate 导入模块分组规则
# 1. 导入来自 std、core 和 alloc 的模块需要置于前面一组。
# 2. 导入来自 第三方库的模块 应该置于中间一组。
# 3. 导入来自本地 self、super和crate前缀的模块，置于后面一组。
group_imports=&quot;StdExternalCrate&quot; 
# format_macro_matchers 规则说明：
# 声明宏 模式匹配分支（=&gt; 左侧）中要使用紧凑格式
# 默认声明宏分支代码体（=&gt; 右侧） 使用宽松格式
format_macro_matchers=true 
# 当使用 extern 指定外部函数时，不需要显式指定 C-ABI ，默认就是 C-ABI
force_explicit_abi=false 
# 指定一行注释允许的最大宽度
comment_width=100
# wrap_comments 配合 comment_width 使用，自动将一行超过宽带限制的注释切分为多行注释
wrap_comments=true
# 将 /**/ 注释转为 //
normalize_comments=true
# 会报告注释中的 FIXIME
report_fixme=&quot;Unnumbered&quot;
# 元组模式匹配的时候允许使用 `..` 来匹配剩余元素
condense_wildcard_suffixes=true
# 如果项目只在 Unix 平台下跑，可以设置该项为 Unix，表示换行符只依赖 Unix
newline_style=&quot;Unix&quot;
# 不要将多个 Derive 宏合并为同一行
merge_derives = false

# 指定 fmt 忽略的目录
ignore = [
     &quot;src/test&quot;,
     &quot;test&quot;,
     &quot;docs&quot;,
]
</code></pre>
<h1><a class="header" href="#clippy-模板" id="clippy-模板">Clippy 模板</a></h1>
<p>有些 Clippy 的 Lint，依赖于一些配置项，如果不想要默认值，可以在 <code>clippy.toml</code> 中进行设置。</p>
<pre><code class="language-toml"># for `disallowed_method`:
# https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_method
disallowed-methods = []

# 函数参数最长不要超过5个
too-many-arguments-threshold=5
</code></pre>
<h2><a class="header" href="#clippy-lint-配置模板" id="clippy-lint-配置模板">Clippy lint 配置模板</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 参考： https://github.com/serde-rs/serde/blob/master/serde/src/lib.rs
#![allow(unknown_lints, bare_trait_objects, deprecated)]
#![cfg_attr(feature = &quot;cargo-clippy&quot;, allow(renamed_and_removed_lints))]
#![cfg_attr(feature = &quot;cargo-clippy&quot;, deny(clippy, clippy_pedantic))]
// Ignored clippy and clippy_pedantic lints
#![cfg_attr(
    feature = &quot;cargo-clippy&quot;,
    allow(
        // clippy bug: https://github.com/rust-lang/rust-clippy/issues/5704
        unnested_or_patterns,
        // clippy bug: https://github.com/rust-lang/rust-clippy/issues/7768
        semicolon_if_nothing_returned,
        // not available in our oldest supported compiler
        checked_conversions,
        empty_enum,
        redundant_field_names,
        redundant_static_lifetimes,
        // integer and float ser/de requires these sorts of casts
        cast_possible_truncation,
        cast_possible_wrap,
        cast_sign_loss,
        // things are often more readable this way
        cast_lossless,
        module_name_repetitions,
        option_if_let_else,
        single_match_else,
        type_complexity,
        use_self,
        zero_prefixed_literal,
        // correctly used
        enum_glob_use,
        let_underscore_drop,
        map_err_ignore,
        result_unit_err,
        wildcard_imports,
        // not practical
        needless_pass_by_value,
        similar_names,
        too_many_lines,
        // preference
        doc_markdown,
        unseparated_literal_suffix,
        // false positive
        needless_doctest_main,
        // noisy
        missing_errors_doc,
        must_use_candidate,
    )
)]
// Rustc lints.
#![deny(missing_docs, unused_imports)]
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#embark-studios-的标准-lint-配置" id="embark-studios-的标准-lint-配置">Embark Studios 的标准 Lint 配置</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BEGIN - Embark standard lints v5 for Rust 1.55+
// do not change or add/remove here, but one can add exceptions after this section
// for more info see: &lt;https://github.com/EmbarkStudios/rust-ecosystem/issues/59&gt;
#![deny(unsafe_code)]
#![warn(
    clippy::all,
    clippy::await_holding_lock,
    clippy::char_lit_as_u8,
    clippy::checked_conversions,
    clippy::dbg_macro,
    clippy::debug_assert_with_mut_call,
    clippy::disallowed_method,
    clippy::disallowed_type,
    clippy::doc_markdown,
    clippy::empty_enum,
    clippy::enum_glob_use,
    clippy::exit,
    clippy::expl_impl_clone_on_copy,
    clippy::explicit_deref_methods,
    clippy::explicit_into_iter_loop,
    clippy::fallible_impl_from,
    clippy::filter_map_next,
    clippy::flat_map_option,
    clippy::float_cmp_const,
    clippy::fn_params_excessive_bools,
    clippy::from_iter_instead_of_collect,
    clippy::if_let_mutex,
    clippy::implicit_clone,
    clippy::imprecise_flops,
    clippy::inefficient_to_string,
    clippy::invalid_upcast_comparisons,
    clippy::large_digit_groups,
    clippy::large_stack_arrays,
    clippy::large_types_passed_by_value,
    clippy::let_unit_value,
    clippy::linkedlist,
    clippy::lossy_float_literal,
    clippy::macro_use_imports,
    clippy::manual_ok_or,
    clippy::map_err_ignore,
    clippy::map_flatten,
    clippy::map_unwrap_or,
    clippy::match_on_vec_items,
    clippy::match_same_arms,
    clippy::match_wild_err_arm,
    clippy::match_wildcard_for_single_variants,
    clippy::mem_forget,
    clippy::mismatched_target_os,
    clippy::missing_enforced_import_renames,
    clippy::mut_mut,
    clippy::mutex_integer,
    clippy::needless_borrow,
    clippy::needless_continue,
    clippy::needless_for_each,
    clippy::option_option,
    clippy::path_buf_push_overwrite,
    clippy::ptr_as_ptr,
    clippy::rc_mutex,
    clippy::ref_option_ref,
    clippy::rest_pat_in_fully_bound_structs,
    clippy::same_functions_in_if_condition,
    clippy::semicolon_if_nothing_returned,
    clippy::single_match_else,
    clippy::string_add_assign,
    clippy::string_add,
    clippy::string_lit_as_bytes,
    clippy::string_to_string,
    clippy::todo,
    clippy::trait_duplication_in_bounds,
    clippy::unimplemented,
    clippy::unnested_or_patterns,
    clippy::unused_self,
    clippy::useless_transmute,
    clippy::verbose_file_reads,
    clippy::zero_sized_map_values,
    future_incompatible,
    nonstandard_style,
    rust_2018_idioms
)]
// END - Embark standard lints v0.5 for Rust 1.55+
// crate-specific exceptions:
#![allow()]

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#clippy-配置的相关问题" id="clippy-配置的相关问题">Clippy 配置的相关问题</a></h2>
<p>目前 Clippy 不支持配置文件来配置Lint ，目前 像 Embark 公司有两种解决方法：</p>
<ol>
<li>将 lint 放到一个<a href="https://github.com/EmbarkStudios/rust-ecosystem/blob/main/lints.rs">统一文件</a>中，然后复制粘贴到使用的地方。</li>
<li>通过 <code>.cargo/config.toml</code> 来配置 <code>rustflags</code>  ，参考： <a href="https://github.com/EmbarkStudios/rust-ecosystem/blob/main/lints.toml">lints.toml</a> </li>
</ol>
<p>Embark 也在跟踪和推动在 Cargo 中支持 Lint 配置的功能，相关 issues：</p>
<ul>
<li><a href="https://github.com/EmbarkStudios/rust-ecosystem/issues/22">Be able to disable/enable Clippy lints globally</a></li>
<li><a href="https://github.com/rust-lang/cargo/issues/5034">Support defining enabled and disabled lints in a configuration file</a></li>
<li>[[Roadmap] Configuration file for lints](https://github.com/rust-lang/rust-clippy/issues/6625)</li>
</ul>
<h1><a class="header" href="#cargo-deny-配置模板" id="cargo-deny-配置模板">Cargo Deny 配置模板</a></h1>
<p><a href="https://github.com/EmbarkStudios/cargo-deny">cargo-deny</a>  是检查 Cargo 依赖的一个 Lint 工具。它检查的范围包括：</p>
<ul>
<li>Licenses，检查依赖crate许可证是否合规。</li>
<li>Bans， 检查被禁止使用的依赖 crate。</li>
<li>Advisories ，检查有安全缺陷漏洞或停止维护的 依赖 crate。</li>
<li>Source，检查依赖crate 的来源，确保只来自于可信任的来源。</li>
</ul>
<p>以下是模板（参考 <a href="https://github.com/vectordotdev/vector/blob/master/deny.toml">vectordotdev/vector  的 deny.toml</a>）：</p>
<pre><code class="language-toml">[licenses]
allow = [
  &quot;MIT&quot;,
  &quot;CC0-1.0&quot;,
  &quot;ISC&quot;,
  &quot;OpenSSL&quot;,
  &quot;Unlicense&quot;,
  &quot;BSD-2-Clause&quot;,
  &quot;BSD-3-Clause&quot;,
  &quot;Apache-2.0&quot;,
  &quot;Apache-2.0 WITH LLVM-exception&quot;,
  &quot;Zlib&quot;,
]

unlicensed = &quot;warn&quot;
default = &quot;warn&quot;

private = { ignore = true }

[[licenses.clarify]]
name = &quot;ring&quot;
version = &quot;*&quot;
expression = &quot;MIT AND ISC AND OpenSSL&quot;
license-files = [
    { path = &quot;LICENSE&quot;, hash = 0xbd0eed23 }
]

[advisories]
ignore = [
    # term is looking for a new maintainer
    # https://github.com/timberio/vector/issues/6225
    &quot;RUSTSEC-2018-0015&quot;,

    # `net2` crate has been deprecated; use `socket2` instead
    # https://github.com/timberio/vector/issues/5582
    &quot;RUSTSEC-2020-0016&quot;,

    # Type confusion if __private_get_type_id__ is overriden
    # https://github.com/timberio/vector/issues/5583
    &quot;RUSTSEC-2020-0036&quot;,

    # stdweb is unmaintained
    # https://github.com/timberio/vector/issues/5585
    &quot;RUSTSEC-2020-0056&quot;,
]
</code></pre>
<h1><a class="header" href="#介绍-1" id="介绍-1">介绍</a></h1>
<p>这里介绍一些检测工具，比如 Cargo fmt 和 Cargo Clippy.</p>
<h2><a class="header" href="#参考资料" id="参考资料">参考资料</a></h2>
<ol>
<li><a href="https://doc.rust-lang.org/rustc/lints/groups.html">https://doc.rust-lang.org/rustc/lints/groups.html</a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html">https://rust-lang.github.io/rust-clippy/master/index.html</a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html">https://rust-lang.github.io/rust-clippy/master/index.html</a></li>
<li><a href="https://github.com/dtolnay/noisy-clippy">Dtolnay 对 crates.io 中 clippy lint 应用统计</a></li>
</ol>
<h1><a class="header" href="#rustfmt-配置相关说明" id="rustfmt-配置相关说明">Rustfmt 配置相关说明</a></h1>
<h2><a class="header" href="#在-stable-rust-下使用未稳定配置项的方法" id="在-stable-rust-下使用未稳定配置项的方法">在 Stable Rust 下使用未稳定配置项的方法</a></h2>
<ol>
<li>CI Job 可以分为 <code>Stable</code> 和 <code>Nightly</code>。在 <code>Stable CI</code> 下进行编译，在<code>Nightly CI</code>下执行<code>cargo fmt</code> 和 <code>cargo clippy</code>。</li>
<li>在项目本地可以使用 <code>cargo +nightly fmt</code> 代替 <code>cargo fmt</code>。</li>
</ol>
<p>注意： 一定要在文件保存之后再运行 rustfmt`，否则容易出错。</p>
<h2><a class="header" href="#真实项目中的配置案例" id="真实项目中的配置案例">真实项目中的配置案例</a></h2>
<ol>
<li>来自 <a href="https://github.com/rust-lang/rust/blob/master/rustfmt.toml">Rust 语言自身项目</a>。</li>
</ol>
<pre><code class="language-toml"># Run rustfmt with this config (it should be picked up automatically).
version = &quot;Two&quot;
use_small_heuristics = &quot;Max&quot;
merge_derives = false

# by default we ignore everything in the repository
# tidy only checks files which are not ignored, each entry follows gitignore style
ignore = [
    &quot;/build/&quot;,
    &quot;/*-build/&quot;,
    &quot;/build-*/&quot;,
    &quot;/vendor/&quot;,

    # tests for now are not formatted, as they are sometimes pretty-printing constrained
    # (and generally rustfmt can move around comments in UI-testing incompatible ways)
    &quot;src/test&quot;,

    # do not format submodules
    &quot;library/backtrace&quot;,
    &quot;library/stdarch&quot;,
    &quot;compiler/rustc_codegen_cranelift&quot;,
    &quot;src/doc/book&quot;,
    &quot;src/doc/edition-guide&quot;,
    &quot;src/doc/embedded-book&quot;,
    &quot;src/doc/nomicon&quot;,
    &quot;src/doc/reference&quot;,
    &quot;src/doc/rust-by-example&quot;,
    &quot;src/doc/rustc-dev-guide&quot;,
    &quot;src/llvm-project&quot;,
    &quot;src/tools/cargo&quot;,
    &quot;src/tools/clippy&quot;,
    &quot;src/tools/miri&quot;,
    &quot;src/tools/rls&quot;,
    &quot;src/tools/rust-analyzer&quot;,
    &quot;src/tools/rustfmt&quot;,
    &quot;src/tools/rust-installer&quot;,
]

</code></pre>
<ol>
<li>来自 <a href="https://cs.opensource.google/fuchsia/fuchsia/+/main:rustfmt.toml">Google Fuchsia 操作系统</a>。</li>
</ol>
<pre><code class="language-toml"># Fuchsia Format Style
# last reviewed: Jan 29, 2019

# Fuchsia uses 2018 edition only
edition = &quot;2018&quot;

# The &quot;Default&quot; setting has a heuristic which splits lines too aggresively.
# We are willing to revisit this setting in future versions of rustfmt.
# Bugs:
#   * https://github.com/rust-lang/rustfmt/issues/3119
#   * https://github.com/rust-lang/rustfmt/issues/3120
use_small_heuristics = &quot;Max&quot;

# Prevent carriage returns
newline_style = &quot;Unix&quot;
</code></pre>
<ol start="2">
<li>来自 <a href="https://github.com/tikv/tikv/blob/master/rustfmt.toml">Tikv</a> 。</li>
</ol>
<pre><code class="language-toml">version = &quot;Two&quot;
unstable_features = true

condense_wildcard_suffixes = true
license_template_path = &quot;etc/license.template&quot;
newline_style = &quot;Unix&quot;
use_field_init_shorthand = true
use_try_shorthand = true
</code></pre>
<pre><code class="language-toml">
edition = &quot;2018&quot;
newline_style = &quot;unix&quot;
# comments
normalize_comments=true
wrap_comments=true
# imports 
imports_granularity=&quot;Crate&quot;
group_imports=&quot;StdExternalCrate&quot;

</code></pre>
<h2><a class="header" href="#一些全局配置项" id="一些全局配置项">一些全局配置项</a></h2>
<h3><a class="header" href="#rustfml-格式化版本" id="rustfml-格式化版本">rustfml 格式化版本</a></h3>
<p>【描述】</p>
<p><code>Version::One</code> 向后兼容 Rustfmt 1.0。 其他版本仅在主要版本号内向后兼容。目前 <code>version</code> 可选值只有 <code>One</code> 和 <code>Two</code>。</p>
<p>【对应配置项】</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#version"><code>version</code></a></td><td>One（默认）</td><td>No</td><td>指定 rustfmlt 格式化版本</td></tr>
</tbody></table>
<p>【示例】</p>
<pre><code class="language-toml"># Run rustfmt with this config (it should be picked up automatically).
version = &quot;Two&quot;
</code></pre>
<h3><a class="header" href="#指定文件或目录跳过格式化" id="指定文件或目录跳过格式化">指定文件或目录跳过格式化</a></h3>
<p>【描述】</p>
<p>跳过与指定模式匹配的格式化文件和目录。 模式格式与 <code>.gitignore</code> 相同。 一定要使用 <code>Unix/forwardslash/style</code> 路径，此路径样式适用于所有平台。 不支持带有反斜杠 <code>\</code> 的 Windows 样式路径。</p>
<p>【对应配置项】</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#ignore"><code>ignore</code></a></td><td>格式化每一个Rust文件（默认）</td><td>No</td><td>指定文件或目录跳过格式化</td></tr>
</tbody></table>
<p>【示例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 跳过指定文件
ignore = [
    &quot;src/types.rs&quot;,
    &quot;src/foo/bar.rs&quot;,
]
// 跳过指定目录
ignore = [
    &quot;examples&quot;,
]
// 跳过项目内所有文件
ignore = [&quot;/&quot;]
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#禁用格式化" id="禁用格式化">禁用格式化</a></h3>
<p>【描述】</p>
<p>可以通过 <code>disable_all_formatting=true</code> 配置来禁用格式化。默认是开启的。</p>
<p>【对应配置项】</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#disable_all_formatting"><code>disable_all_formatting</code></a></td><td>false（默认）</td><td>No</td><td>禁止格式化</td></tr>
</tbody></table>
<h3><a class="header" href="#配置-edition-版次" id="配置-edition-版次">配置 edition 版次</a></h3>
<p>【描述】</p>
<p>如果通过 Cargo 的格式化工具 cargo fmt 执行，Rustfmt 能够通过读取 Cargo.toml 文件来获取使用的版本。 否则，需要在配置文件中指定版本。</p>
<p>【对应配置项】</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#edition"><code>edition</code></a></td><td>2015（默认）</td><td>No</td><td>配置 edition 版次</td></tr>
</tbody></table>
<p>【示例】</p>
<pre><code class="language-toml">edition = &quot;2018&quot;
</code></pre>
<h3><a class="header" href="#开启未稳定特性" id="开启未稳定特性">开启未稳定特性</a></h3>
<p>【描述】</p>
<p>默认未启用，但是可以通过配置此功能在 Nightly 上启用此功能。</p>
<p>【对应配置项】</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#unstable_features"><code>unstable_features</code></a></td><td>false（默认）</td><td>No</td><td>开启未稳定特性</td></tr>
</tbody></table>
<h2><a class="header" href="#其他-1" id="其他-1">其他</a></h2>
<h1><a class="header" href="#在-rust-生态中被拒绝的一些默认开启的lint" id="在-rust-生态中被拒绝的一些默认开启的lint">在 Rust 生态中被拒绝的一些默认开启的lint</a></h1>
<p>来源：<a href="https://github.com/dtolnay/noisy-clippy">https://github.com/dtolnay/noisy-clippy</a></p>
<p>以下按字母顺序排列。</p>
<h2><a class="header" href="#absurd_extreme_comparisons" id="absurd_extreme_comparisons"><code>absurd_extreme_comparisons</code></a></h2>
<p><a href="https://rust-lang.github.io/rust-clippy/master/index.html#absurd_extreme_comparisons">https://rust-lang.github.io/rust-clippy/master/index.html#absurd_extreme_comparisons</a></p>
<p>【描述】</p>
<p>默认为 <code>Deny</code>，但在实际应用中，多被设置为 <code>allow</code>。</p>
<h2><a class="header" href="#blacklisted_name" id="blacklisted_name"><code>blacklisted_name</code></a></h2>
<p><a href="https://rust-lang.github.io/rust-clippy/master/index.html#blacklisted_name">https://rust-lang.github.io/rust-clippy/master/index.html#blacklisted_name</a></p>
<p>【描述】</p>
<p>该 lint 不允许代码中出现 「内置黑名单」中定义的命名，比如 <code>foo</code>、<code>baz</code>。</p>
<p>默认为 <code>Warn</code>，但在实际应用中，可能被设置为<code>allow</code>，因为在某些样板代码、文档或测试代码中可能需要使用 <code>foo</code>。</p>
<h2><a class="header" href="#blanket_clippy_restriction_lints" id="blanket_clippy_restriction_lints"><code>blanket_clippy_restriction_lints</code></a></h2>
<p><a href="https://rust-lang.github.io/rust-clippy/master/index.html#blanket_clippy_restriction_lints">https://rust-lang.github.io/rust-clippy/master/index.html#blanket_clippy_restriction_lints</a></p>
<p>【描述】</p>
<p>用于检查针对整个 <code>clippy::restriction</code> 类别的警告/拒绝/禁止属性。Restriction lint 有时与其他 lint 形成对比，甚至与惯用的 Rust 背道而驰。 这些 lint 应仅在逐个 lint 的基础上启用并仔细考虑。</p>
<p>默认为 <code>suspicious/warn</code>，但实际有些项目中会将其设置为 <code>allow</code>。</p>
<h1><a class="header" href="#cargo-udeps" id="cargo-udeps">Cargo Udeps</a></h1>
<p><a href="https://github.com/est31/cargo-udeps">cargo-udeps</a> 检查 <code>Cargo.toml</code> 中未使用的依赖。</p>
<p><code>cargo udeps</code> 对标的是<code> rustc</code> 的<code> unused_crate_dependencies lint</code></p>
<p>虽然 rustc 也能检查一些未使用依赖，但是在 lib 和 bin 混合的项目中误报率高</p>
<pre><code>RUSTFLAGS=&quot;-Dunused_crate_dependencies&quot; cargo c
</code></pre>
<p><code>cargo udeps</code> 的最大优点就是<strong>几乎没有误报</strong>。</p>
<p>但是检查力度不如<code>rustc unused_crate_dependencies lint</code>仔细，建议二者搭配使用</p>
<h1><a class="header" href="#最佳实践" id="最佳实践">最佳实践</a></h1>
<h1><a class="header" href="#嵌入式-rust" id="嵌入式-rust">嵌入式 Rust</a></h1>
<h1><a class="header" href="#数据库" id="数据库">数据库</a></h1>
<h1><a class="header" href="#游戏" id="游戏">游戏</a></h1>
<h1><a class="header" href="#cli-app" id="cli-app">Cli App</a></h1>
<h1><a class="header" href="#gui" id="gui">GUI</a></h1>
<h1><a class="header" href="#web-开发" id="web-开发">Web 开发</a></h1>
<h1><a class="header" href="#网络服务" id="网络服务">网络服务</a></h1>
<h1><a class="header" href="#webassembly" id="webassembly">WebAssembly</a></h1>
<h1><a class="header" href="#cheat-sheet" id="cheat-sheet">Cheat Sheet</a></h1>
<p>这里用于梳理 Rust 相关的 Cheat Sheet。</p>
<h2><a class="header" href="#资源" id="资源">资源</a></h2>
<p><a href="https://cheats.rs/">https://cheats.rs/</a></p>
<h1><a class="header" href="#介绍-2" id="介绍-2">介绍</a></h1>
<p>优化包括性能优化、编译文件大小优化和编译时间优化。</p>
<h2><a class="header" href="#参考资料-1" id="参考资料-1">参考资料</a></h2>
<p>Rust 性能优化：</p>
<ol>
<li>https://nnethercote.github.io/perf-book/</li>
</ol>
<p>编译文件大小裁剪：</p>
<ol>
<li>
<p>https://github.com/johnthagen/min-sized-rust</p>
</li>
<li>
<p>https://docs.rust-embedded.org/book/unsorted/speed-vs-size.html</p>
</li>
<li>
<p>https://arusahni.net/blog/2020/03/optimizing-rust-binary-size.html</p>
</li>
<li>
<p>https://mender.io/blog/building-mender-rust-in-yocto-and-minimizing-the-binary-size</p>
</li>
<li>
<p>https://github.com/RazrFalcon/cargo-bloat</p>
</li>
<li>
<p>https://github.com/orf/cargo-bloat-action CI 里构建 cargo bloat</p>
</li>
<li>
<p>https://oknozor.github.io/blog/optimize-rust-binary-size/</p>
</li>
</ol>
<p>编译时间优化：</p>
<ol>
<li>https://jondot.medium.com/8-steps-for-troubleshooting-your-rust-build-times-2ffc965fd13e</li>
</ol>
<h1><a class="header" href="#cookbook-介绍" id="cookbook-介绍">CookBook 介绍</a></h1>
<p>这里是对 Rust 生态系统中常用库或框架的使用介绍。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="mermaid.min.js"></script>
        
        <script type="text/javascript" src="mermaid-init.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
